<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>「OpenFlow」基于Packet-In消息处理机制修改IP协议号</title>
    <link href="/2020/04/06/%E3%80%8COpenFlow%E3%80%8D%E5%9F%BA%E4%BA%8EPacket-In%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%BF%AE%E6%94%B9IP%E5%8D%8F%E8%AE%AE%E5%8F%B7/"/>
    <url>/2020/04/06/%E3%80%8COpenFlow%E3%80%8D%E5%9F%BA%E4%BA%8EPacket-In%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%BF%AE%E6%94%B9IP%E5%8D%8F%E8%AE%AE%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-目录"><a href="#0x00-目录" class="headerlink" title="0x00 目录"></a>0x00 目录</h2><p>[TOC]</p><a id="more"></a><h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>如图1所示，OpenFlow 1.0中定义了Set动作，用于修改数据包的首部字段，这包括源宿MAC地址、源宿IP地址、源宿端口号等字段。通过将指定IP地址段与Set动作绑定作为流表项，即可在OpenFlow交换机上实现NAT的功能。</p><p><img src="/imgs/Packet-In_Based_Set_IP_Protocol/OpenFlow1.0%E4%B8%ADAction%E5%AE%9A%E4%B9%89.png" srcset="/img/loading.gif" alt="图1 OpenFlow1.0中Action定义"></p><p>假设现在需要通过修改IP协议号，来实现一个数据包的伪装。例如：原本是ICMP的包，通过修改IP协议号（1-&gt;6）后，对外表现为TCP包。</p><p>此时OpenFlow 1.0显然不能满足需求，原因就是OpenFlow 1.0只能提供有限的数据包首部字段修改。</p><p><code>注：OpenFlow 1.3以后的版本，增加SET_FIELD动作，支持按照OXM TLV格式来修改任意数据包首部字段</code></p><p>为了在OpenFlow 1.0中实现修改IP协议号，可以利用Packet-In的消息处理机制。</p><h2 id="0x02-基于Packet-In消息处理机制修改IP协议号"><a href="#0x02-基于Packet-In消息处理机制修改IP协议号" class="headerlink" title="0x02 基于Packet-In消息处理机制修改IP协议号"></a>0x02 基于Packet-In消息处理机制修改IP协议号</h2><p>基于Packet-In消息处理机制实现IP协议号修改的基本思路：</p><ol><li>显示下发流表，对指定要修改IP协议号的数据包通过Packet-In消息上传到控制器</li><li>修改控制器上的Packet-In消息处理函数，解析数据包首部，修改IP首部中IP协议号字段</li></ol><p>例子：如图2所示，假设有主机H1向H2发送ICMP包，现在希望将这个ICMP包的IP协议号字段进行修改，使其对外表现为TCP包，按照上面提到的思路即可实现。</p><p><img src="/imgs/Packet-In_Based_Set_IP_Protocol/%E5%9F%BA%E4%BA%8EPacket-In%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%BF%AE%E6%94%B9IP%E5%8D%8F%E8%AE%AE%E5%8F%B7.png" srcset="/img/loading.gif" alt="图2 基于Packet-In消息处理机制修改IP协议号"></p><p><code>注：上图中H1通过ping发送给H2的ICMP包经过控制器修改IP协议号后变为TCP包，H2在收到这个包之后，实际上不会进行ICMP响应，因此最终H1上会显示ping失败</code></p><h2 id="0x03-POX-Mininet实验验证"><a href="#0x03-POX-Mininet实验验证" class="headerlink" title="0x03 POX + Mininet实验验证"></a>0x03 POX + Mininet实验验证</h2><p>按照0x02中的例子，使用POX和Mininet进行验证。</p><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p><img src="/imgs/Packet-In_Based_Set_IP_Protocol/%E5%AE%9E%E9%AA%8C%E6%8B%93%E6%89%91.png" srcset="/img/loading.gif" alt="图3 实验拓扑"></p><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><ol><li>H1向H2发送ICMP包（h1 ping h2 -c 1）</li><li>SW1将ICMP包Packet-In上传到控制器</li><li>控制器修改IP协议号（ICMP -&gt; TCP），变换后的TCP包（原ICMP包）Packet-Out至SW2并指示SW2转发给H2</li><li>在SW2与H1的链路、SW2与H2的链路上抓包，预期实验结果：前者抓到ICMP包，后者抓到TCP包，并且H1上显示ping失败</li></ol><h3 id="编写POX应用"><a href="#编写POX应用" class="headerlink" title="编写POX应用"></a>编写POX应用</h3><p>为了实现IP协议号的修改，需要在POX上编写一个应用transfer_ipproto（存放在POX源码的ext文件夹下），从而实现下面两个功能：</p><ol><li>下发流表给SW1，指定ICMP包通过Packet-In上传到控制器处理</li><li>添加Packet-In消息处理函数，解析数据包首部，修改IP协议号后通过Packet-Out消息转发至SW2，并指导SW2将修改IP协议号后的数据包转发至H2</li></ol><p>transfer_ipproto源码如下所示：</p><pre><code class="python">   # -*- coding: utf-8 -*-# 功能：# 通过Packet-In机制修改IP协议号及TCP选项# 模块Packet-In处理函数中下发默认流表，构建路径## 网络拓扑：# h1 - sw1 - sw2 - h2## @Update History:# @Author  Date            Content# @CTZ     2020-03-24      添加必要的注释# @CTZ     2020-03-31      完成代码编写及调试from pox.core import coreimport pox.openflow.libopenflow_01 as offrom pox.lib.packet.ethernet import ethernetfrom pox.lib.packet.icmp import icmpfrom pox.lib.packet.ipv4 import ipv4from pox.lib.addresses import IPAddrfrom pox.lib.util import dpid_to_str, str_to_dpidlog = core.getLogger()class transfer_ipproto(object):    def __init__(self):        log.info(&quot;初始化模块&quot;)        # h1信息        self.h1_info = {}        self.h1_info[&#39;ip&#39;] = &quot;10.0.0.1&quot;        self.h1_info[&#39;mac&#39;] = &quot;00:00:00:00:00:01&quot;        # h2信息        self.h2_info = {}        self.h2_info[&#39;ip&#39;] = &quot;10.0.0.2&quot;        self.h2_info[&#39;mac&#39;] = &quot;00:00:00:00:00:02&quot;        # sw1信息        self.sw1_info = {}        self.sw1_info[&#39;dpid&#39;] = str_to_dpid(&quot;0x0000000000000001&quot;)        self.sw1_info[&#39;h1&#39;] = {}        self.sw1_info[&#39;h1&#39;][&#39;port&#39;] = 1        self.sw1_info[&#39;sw2&#39;] = {}        self.sw1_info[&#39;sw2&#39;][&#39;port&#39;] = 2        # sw2信息        self.sw2_info = {}        self.sw2_info[&#39;dpid&#39;] = str_to_dpid(&quot;0x0000000000000002&quot;)        self.sw2_info[&#39;sw1&#39;] = {}        self.sw2_info[&#39;sw1&#39;][&#39;port&#39;] = 1        self.sw2_info[&#39;h2&#39;] = {}        self.sw2_info[&#39;h2&#39;][&#39;port&#39;] = 2        # 虚拟IP协议号        #self.ipproto = ipv4.ICMP_PROTOCOL        self.ipproto = ipv4.TCP_PROTOCOL        # 统计packetin处理次数        self.packetin_count = 0        core.openflow.addListeners(self)    def _handle_PacketIn (self, event):        self.packetin_count = self.packetin_count+1        log.info(str(self.packetin_count) + &quot; ： PacketIn处理开始&quot;)        #下发初始流表        if self.packetin_count == 1:            #sw1 -&gt; sw2            msg = of.ofp_flow_mod()            msg.match.dl_type = 0x800            msg.match.nw_src = IPAddr(self.h1_info[&quot;ip&quot;])            msg.match.nw_dst = IPAddr(self.h2_info[&quot;ip&quot;])            msg.actions.append(of.ofp_action_output(port=self.sw1_info[&#39;sw2&#39;][&#39;port&#39;]))            core.openflow.sendToDPID(self.sw1_info[&#39;dpid&#39;], msg)            msg = of.ofp_flow_mod()            msg.match.dl_type = 0x800            msg.match.nw_src = IPAddr(self.h2_info[&quot;ip&quot;])            msg.match.nw_dst = IPAddr(self.h1_info[&quot;ip&quot;])            msg.actions.append(of.ofp_action_output(port=self.sw1_info[&#39;h1&#39;][&#39;port&#39;]))            core.openflow.sendToDPID(self.sw1_info[&#39;dpid&#39;], msg)            # sw1 -&gt; controller            msg = of.ofp_flow_mod()            msg.match.dl_type = 0x800            msg.match.nw_src = IPAddr(self.h1_info[&quot;ip&quot;])            msg.match.nw_dst = IPAddr(self.h2_info[&quot;ip&quot;])            msg.match.nw_proto = ipv4.TCP_PROTOCOL            msg.priority = 0x8001  # 大于默认优先级0x8000            msg.actions.append(of.ofp_action_output(port=of.ofp_port_rev_map[&#39;OFPP_CONTROLLER&#39;]))            core.openflow.sendToDPID(self.sw1_info[&#39;dpid&#39;], msg)            msg = of.ofp_flow_mod()            msg.match.dl_type = 0x800            msg.match.nw_src = IPAddr(self.h1_info[&quot;ip&quot;])            msg.match.nw_dst = IPAddr(self.h2_info[&quot;ip&quot;])            msg.match.nw_proto = ipv4.ICMP_PROTOCOL            msg.priority = 0x8001  # 大于默认优先级0x8000            msg.actions.append(of.ofp_action_output(port=of.ofp_port_rev_map[&#39;OFPP_CONTROLLER&#39;]))            core.openflow.sendToDPID(self.sw1_info[&#39;dpid&#39;], msg)            # sw2 -&gt; sw1            msg = of.ofp_flow_mod()            msg.match.dl_type = 0x800            msg.match.nw_src = IPAddr(self.h2_info[&quot;ip&quot;])            msg.match.nw_dst = IPAddr(self.h1_info[&quot;ip&quot;])            msg.actions.append(of.ofp_action_output(port=self.sw2_info[&#39;sw1&#39;][&#39;port&#39;]))            core.openflow.sendToDPID(self.sw2_info[&#39;dpid&#39;], msg)            msg = of.ofp_flow_mod()            msg.match.dl_type = 0x800            msg.match.nw_src = IPAddr(self.h1_info[&quot;ip&quot;])            msg.match.nw_dst = IPAddr(self.h2_info[&quot;ip&quot;])            msg.actions.append(of.ofp_action_output(port=self.sw2_info[&#39;h2&#39;][&#39;port&#39;]))            core.openflow.sendToDPID(self.sw2_info[&#39;dpid&#39;], msg)            # sw2 -&gt; controller            msg = of.ofp_flow_mod()            msg.match.dl_type = 0x800            msg.match.nw_src = IPAddr(self.h2_info[&quot;ip&quot;])            msg.match.nw_dst = IPAddr(self.h1_info[&quot;ip&quot;])            msg.match.nw_proto = ipv4.TCP_PROTOCOL            msg.priority = 0x8001  # 大于默认优先级0x8000            msg.actions.append(of.ofp_action_output(port=of.ofp_port_rev_map[&#39;OFPP_CONTROLLER&#39;]))            core.openflow.sendToDPID(self.sw2_info[&#39;dpid&#39;], msg)            msg = of.ofp_flow_mod()            msg.match.dl_type = 0x800            msg.match.nw_src = IPAddr(self.h2_info[&quot;ip&quot;])            msg.match.nw_dst = IPAddr(self.h1_info[&quot;ip&quot;])            msg.match.nw_proto = ipv4.ICMP_PROTOCOL            msg.priority = 0x8001  # 大于默认优先级0x8000            msg.actions.append(of.ofp_action_output(port=of.ofp_port_rev_map[&#39;OFPP_CONTROLLER&#39;]))            core.openflow.sendToDPID(self.sw2_info[&#39;dpid&#39;], msg)            log.info(&quot;已经下发初始流表&quot;)        dpid = event.connection.dpid        in_port = event.port        packet = event.parsed        if not packet.parsed:            log.warning(&quot;%i %i ignoring unparsed packet&quot;, dpid, in_port)            return        if isinstance(packet, ethernet):            log.info(&quot;解析包：eth&quot;)            eth_packet = packet            #if eth_packet.type == packet.IP_TYPE:            if isinstance(eth_packet.payload, ipv4):                log.info(&quot;解析包：ipv4&quot;)                ip_packet = eth_packet.payload                if isinstance(ip_packet.payload, icmp):                    log.info(&quot;解析包：icmp&quot;)                    icmp_packet = ip_packet.payload                    i = ipv4(v=ip_packet.v,                             hl=ip_packet.hl,                             tos=ip_packet.tos,                             iplen=ip_packet.iplen,                             id=ip_packet.id,                             flags=ip_packet.flags,                             frag=ip_packet.frag,                             ttl=ip_packet.ttl,                             srcip=ip_packet.srcip,                             dstip=ip_packet.dstip,                             protocol=self.ipproto)  # 修改IP协议号                             #csum                    i.set_payload(icmp_packet)                    e = ethernet(type=ethernet.IP_TYPE,                                 src=eth_packet.src,                                 dst=eth_packet.dst                                 )                    e.set_payload(i)                    # h1 -&gt; h2的ICMP包执行协议号变换                    if ip_packet.srcip == IPAddr(self.h1_info[&quot;ip&quot;]) and ip_packet.dstip == IPAddr(self.h2_info[&quot;ip&quot;]):                        msg = of.ofp_packet_out()                        msg.data = e.pack()                        msg.actions.append(of.ofp_action_output(port=self.sw2_info[&#39;h2&#39;][&#39;port&#39;]))                        core.openflow.sendToDPID(self.sw2_info[&#39;dpid&#39;], msg)                        log.info(&quot;h1 -&gt; h2的ICMP包处理结束：IP协议号变换&quot;)                    # h2 -&gt; h1的ICMP包执行协议号变换                    elif ip_packet.srcip == self.h2_info[&quot;ip&quot;] and ip_packet.dstip == self.h1_info[&quot;ip&quot;]:                        msg = of.ofp_packet_out()                        msg.data = e.pack()                        msg.actions.append(of.ofp_action_output(port=self.sw1_info[&#39;h1&#39;][&#39;port&#39;]))                        core.openflow.sendToDPID(self.sw1_info[&#39;dpid&#39;], msg)                        log.info(&quot;h2 -&gt; h1的ICMP包处理结束：IP协议号变换&quot;)        log.info(&quot;PacketIn处理结束&quot;)        returndef launch():    core.registerNew(transfer_ipproto_tcpoptions)</code></pre><h3 id="配置POX启动参数"><a href="#配置POX启动参数" class="headerlink" title="配置POX启动参数"></a>配置POX启动参数</h3><p><img src="/imgs/Packet-In_Based_Set_IP_Protocol/POX%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0.png" srcset="/img/loading.gif" alt="图4 POX启动参数"></p><p><code>注：需要用到POX的arp_responder应用实现ARP的功能</code></p><h3 id="Mininet验证"><a href="#Mininet验证" class="headerlink" title="Mininet验证"></a>Mininet验证</h3><p><strong>1.启动POX、Mininet并打开H1和H2的终端</strong></p><p><img src="/imgs/Packet-In_Based_Set_IP_Protocol/%E5%90%AF%E5%8A%A8Mininet%E5%B9%B6%E6%89%93%E5%BC%80H1%E5%92%8CH2%E7%9A%84%E7%BB%88%E7%AB%AF.png" srcset="/img/loading.gif" alt="图5 启动Mininet并打开H1和H2的终端"></p><p><strong>2.在H1和H2上启动wirehsark，分别配置显示过滤器为icmp和tcp</strong></p><p>启动wireshark命令：<code>sudo wireshark</code></p><p><img src="/imgs/Packet-In_Based_Set_IP_Protocol/%E5%90%AF%E5%8A%A8wireshark%E5%B9%B6%E9%85%8D%E7%BD%AE%E6%98%BE%E7%A4%BA%E8%BF%87%E6%BB%A4%E5%99%A8.png" srcset="/img/loading.gif" alt="图6 启动wireshark并配置显示过滤器"></p><p><strong>3.在Mininet终端上发起Ping，H1向H2发送一个ICMP包</strong></p><p><img src="/imgs/Packet-In_Based_Set_IP_Protocol/H1%E5%90%91H2%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AAICMP%E5%8C%85.png" srcset="/img/loading.gif" alt="图7 H1向H2发送一个ICMP包"></p><p><strong>4.查看wireshark抓包结果</strong></p><p>如图8和图9所示，H1上抓到ICMP包</p><p><img src="/imgs/Packet-In_Based_Set_IP_Protocol/H1%E4%B8%8A%E6%8A%93%E5%88%B0%E7%9A%84ICMP%E5%8C%85IP%E9%A6%96%E9%83%A8.png" srcset="/img/loading.gif" alt="图8 H1上抓到的ICMP包IP首部"></p><p><img src="/imgs/Packet-In_Based_Set_IP_Protocol/H1%E4%B8%8A%E6%8A%93%E5%88%B0%E7%9A%84ICMP%E5%8C%85IP_Payload.png" srcset="/img/loading.gif" alt="图9 H1上抓到的ICMP包IP Payload"></p><p>如图10和图11所示，H2上抓到TCP包</p><p><img src="/imgs/Packet-In_Based_Set_IP_Protocol/H2%E4%B8%8A%E6%8A%93%E5%88%B0%E7%9A%84TCP%E5%8C%85IP%E9%A6%96%E9%83%A8.png" srcset="/img/loading.gif" alt="图10 H2上抓到的TCP包IP首部"></p><p><img src="/imgs/Packet-In_Based_Set_IP_Protocol/H2%E4%B8%8A%E6%8A%93%E5%88%B0%E7%9A%84TCP%E5%8C%85IP_Payload.png" srcset="/img/loading.gif" alt="图11 H2上抓到的TCP包IP Payload"></p><p>根据图9和图11中的IP Payload（数据包原始字节流）相同可知，H2上抓到的TCP包就是修改了IP协议号的ICMP包。</p><p>至此，该实验验证了可以通过Packet-In消息处理机制来实现IP协议号的修改。<strong>该方法除了能够修改IP协议号外，也能修改数据包中首部的其他字段。</strong></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>修改数据包首部字段的方法：</p><ol><li><p>流表Set动作</p><p><code>注：OpenFlow1.3以前版本仅支持修改部分首部字段，OpenFlow1.3以后版本支持修改任意首部字段</code></p></li><li><p>基于Packet-In消息处理机制修改</p></li></ol><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><ul><li><a href="https://www.opennetworking.org/wp-content/uploads/2014/10/openflow-spec-v1.0.0.pdf" target="_blank" rel="noopener">openflow-switch-v1.0.0</a></li><li><a href="https://www.opennetworking.org/wp-content/uploads/2014/10/openflow-spec-v1.3.0.pdf" target="_blank" rel="noopener">openflow-switch-v1.3.0</a></li><li><a href="https://www.opennetworking.org/wp-content/uploads/2014/10/openflow-switch-v1.5.1.pdf" target="_blank" rel="noopener">openflow-switch-v1.5.1</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>SDN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「Floodlight」链路丢包率测量</title>
    <link href="/2020/02/22/%E3%80%8CFloodlight%E3%80%8D%E9%93%BE%E8%B7%AF%E4%B8%A2%E5%8C%85%E7%8E%87%E6%B5%8B%E9%87%8F/"/>
    <url>/2020/02/22/%E3%80%8CFloodlight%E3%80%8D%E9%93%BE%E8%B7%AF%E4%B8%A2%E5%8C%85%E7%8E%87%E6%B5%8B%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-目录"><a href="#0x00-目录" class="headerlink" title="0x00 目录"></a>0x00 目录</h2><ul><li><a href="#0x00-目录">0x00 目录</a></li><li><a href="#0x01-前言">0x01 前言</a></li><li><a href="#0x02-基于openflow的port-stats消息测量链路丢包率原理">0x02 基于OpenFlow的Port-Stats消息测量链路丢包率原理</a></li><li><a href="#0x03-链路丢包率测量模块设计">0x03 链路丢包率测量模块设计</a><ul><li><a href="#statisticscollector模块分析">StatisticsCollector模块分析</a></li><li><a href="#linkdiscovery包分析">linkdiscovery包分析</a></li><li><a href="#链路丢包率测量模块设计思路">链路丢包率测量模块设计思路</a></li></ul></li><li><a href="#0x04-链路丢包率测量模块实现">0x04 链路丢包率测量模块实现</a></li><li><a href="#0x05-mininet搭建拓扑测量链路丢包率">0x05 Mininet搭建拓扑测量链路丢包率</a></li><li><a href="#0x06-参考">0x06 参考</a><a id="more"></a></li></ul><h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>Floodlight控制器中StatisticsCollector模块已经实现了用Port-Stats消息测量OpenFlow交换机端口的吞吐量，本文通过对StatisticsCollector模块进行扩展，并用Mininet搭建拓扑，实现在SDN网络中测量中链路丢包率。</p><h2 id="0x02-基于OpenFlow的Port-Stats消息测量链路丢包率原理"><a href="#0x02-基于OpenFlow的Port-Stats消息测量链路丢包率原理" class="headerlink" title="0x02 基于OpenFlow的Port-Stats消息测量链路丢包率原理"></a>0x02 基于OpenFlow的Port-Stats消息测量链路丢包率原理</h2><p>请参考<a href="https://chentingz.github.io/2020/02/12/%E5%9F%BA%E4%BA%8EOpenFlow%E6%B6%88%E6%81%AF%E7%9A%84%E7%BD%91%E7%BB%9C%E6%B5%8B%E9%87%8F%E6%96%B9%E6%B3%95/#%E6%B5%8B%E9%87%8F%E4%B8%A2%E5%8C%85%E7%8E%87">基于OpenFlow消息的网络测量方法 </a></p><h2 id="0x03-链路丢包率测量模块设计"><a href="#0x03-链路丢包率测量模块设计" class="headerlink" title="0x03 链路丢包率测量模块设计"></a>0x03 链路丢包率测量模块设计</h2><h3 id="StatisticsCollector模块分析"><a href="#StatisticsCollector模块分析" class="headerlink" title="StatisticsCollector模块分析"></a>StatisticsCollector模块分析</h3><p>如图1所示，src/main/java目录下，net.floodlightcontroller.statistics包中StatisticsCollector.java文件定义了StatisticsCollector模块。该模块每隔10s创建多个线程轮询拓扑中所有交换机以获取Port-Stats响应消息，通过Port-Stats响应消息中的rx_bytes、tx_bytes、duration_sec和duration_nsec四个字段来测量端口吞吐量。因此，可以在该模块获取Port-Stats响应消息基础上，添加代码以实现链路丢包率的测量。</p><p><img src="/imgs/Floodlight_Link_Packet_Loss_Rate_Measurement/net.floodlightcontroller.statistics%E5%8C%85.png" srcset="/img/loading.gif" alt="图1 net.floodlightcontroller.statistics包"></p><p>StatisticsCollector模块中的PortStatsCollector内部类实现了端口吞吐量测量，如图2所示，它通过调用getSwitchStatistics方法来获取所有交换机的统计信息，然后根据上一次查询的Port-Stats消息以及本次查询的Port-Stats消息，分别提取rx_bytes、tx_bytes、duration_sec和duration_nsec字段，通过公式（2）和公式（3）即可计算出交换机端口发送吞吐量或接收吞吐量。</p><p><img src="/imgs/Network_Measurement_Based_On_OpenFlow_Message/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%AB%AF%E5%8F%A3%E5%90%9E%E5%90%90%E9%87%8F%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" srcset="/img/loading.gif" alt="交换机端口吞吐量计算公式"></p><p><img src="/imgs/Floodlight_Link_Packet_Loss_Rate_Measurement/StatisticsCollector%E6%A8%A1%E5%9D%97%E4%B8%ADPortStatsCollector%E7%B1%BB.png" srcset="/img/loading.gif" alt="图2 StatisticsCollector模块中PortStatsCollector类"></p><p>StatisticsCollector模块中的getSwitchStatistics方法有两个重载版本，分别是  </p><pre><code class="java">protected List&lt;OFStatsReply&gt; getSwitchStatistics(DatapathId switchId, OFStatsType statsType)Map&lt;DatapathId, List&lt;OFStatsReply&gt;&gt; getSwitchStatistics(Set&lt;DatapathId&gt; dpids, OFStatsType statsType)</code></pre><p>其中前者的作用是获取单台交换机的统计消息（以Stats结尾的消息，如Port-Stats消息）。该方法的实现如图3所示，首先构造一个Stats请求消息根据交换机DPID发送给指定交换机，然后接收交换机返回的Stats响应消息，并保存在List列表中。</p><p><img src="/imgs/Floodlight_Link_Packet_Loss_Rate_Measurement/Statistics%E6%A8%A1%E5%9D%97%E4%B8%ADgetSwitchStatistics%E6%96%B9%E6%B3%95%E8%8E%B7%E5%8F%96%E5%8D%95%E5%8F%B0%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF.png" srcset="/img/loading.gif" alt="图3 Statistics模块中getSwitchStatistics方法获取单台交换机的统计信息"></p><p>后者的作用是创建多个线程，每个线程通过调用getSwitchStatistics(DatapathId switchId, OFStatsType statsType)方法负责获取一台交换机的统计消息，从而实现并行获取网络中所有交换机的统计消息。该方法的实现如图4所示。</p><p><img src="/imgs/Floodlight_Link_Packet_Loss_Rate_Measurement/Statistics%E6%A8%A1%E5%9D%97%E4%B8%ADgetSwitchStatistics%E6%96%B9%E6%B3%95%E5%B9%B6%E8%A1%8C%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF.png" srcset="/img/loading.gif" alt="图4 Statistics模块中getSwitchStatistics方法并行获取所有交换机的统计信息"></p><h3 id="linkdiscovery包分析"><a href="#linkdiscovery包分析" class="headerlink" title="linkdiscovery包分析"></a>linkdiscovery包分析</h3><p>如图5所示，src/main/java目录下，net.floodlightcontroller.linkdiscovery包中包含了链路的定义Link.java，可获取拓扑中所有链路的接口ILinkDiscoveryService.java。<br><img src="/imgs/Floodlight_Link_Packet_Loss_Rate_Measurement/net.floodlightcontroller.linkdiscovery%E5%8C%85.png" srcset="/img/loading.gif" alt="图5  net.floodlightcontroller.linkdiscovery包"></p><p>如图6所示，在Floodlight中，由起始交换机DPID和端口ID以及终点交换机DPID和端口ID定义一条链路，可见链路是指交换机之间的连接关系，不包含主机与交换机之间的连接关系，同时链路是有方向的。</p><p><img src="/imgs/Floodlight_Link_Packet_Loss_Rate_Measurement/Link%E7%B1%BB%E5%AE%9A%E4%B9%89.png" srcset="/img/loading.gif" alt="图6  Link类定义"></p><p>如图7所示，ILinkDiscoveryService接口中定义了许多获取链路、链路类型等方法，其中</p><pre><code class="java"> public Map&lt;Link, LinkInfo&gt; getLinks();</code></pre><p>方法可用于获取拓扑中所有的链路。</p><p><img src="/imgs/Floodlight_Link_Packet_Loss_Rate_Measurement/ILinkDiscoveryService%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89.png" srcset="/img/loading.gif" alt="图7  ILinkDiscoveryService接口定义"></p><h3 id="链路丢包率测量模块设计思路"><a href="#链路丢包率测量模块设计思路" class="headerlink" title="链路丢包率测量模块设计思路"></a>链路丢包率测量模块设计思路</h3><p>链路丢包率测量模块将在StatisticsCollector模块的基础上实现，其设计思路：  </p><pre><code>a.通过getSwitchStatistics方法发起查询，获取所有交换机的Port-Stats消息，并根据交换机DPID和其Port-Stats消息的映射关系存储在replies哈希表中b.通过ILinkDiscoveryService接口获取所有链路，存储在links集合中c.循环遍历links，分别从previousReplies和replies中获取上一次查询以及本次查询的Port-Stats消息，并从中提取tx_packets、rx_packets字段根据公式（1）计算当前遍历的链路的丢包率，将链路和链路丢包率的映射关系存储在linkLossResults哈希表中d.用replies更新previousRepliese.根据linkLossResults打印链路丢包率</code></pre><p><img src="/imgs/Network_Measurement_Based_On_OpenFlow_Message/%E9%93%BE%E8%B7%AF%E4%B8%A2%E5%8C%85%E7%8E%87%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" srcset="/img/loading.gif" alt="链路丢包率计算公式"></p><h2 id="0x04-链路丢包率测量模块实现"><a href="#0x04-链路丢包率测量模块实现" class="headerlink" title="0x04 链路丢包率测量模块实现"></a>0x04 链路丢包率测量模块实现</h2><ol><li><p>在Eclipse中，src/main/java目录下，net.floodlightcontroller.statistics包中新建一个LinkLoss类，用于存储某条链路在查询间隙接收、发送数据包个数，以及丢包率，该类的实现代码如下:  </p><pre><code class="java"> public class LinkLoss {     private    Link link;    // 链路 = 起点（srcDPID + srcPort） + 终点（dstDPID + dstPort）     private U64 txPackets;    // 两次查询间隙，链路起点发送的数据包个数     private U64 rxPackets;    // 两次查询间隙，链路终点接收的数据包个数     private U64 linkLoss;    // 两次查询间隙，链路丢包率     public LinkLoss() {     super();     }     public LinkLoss(Link link, U64 txPackets, U64 rxPackets,U64 linkLoss) {         super();         this.link = link;         this.txPackets = txPackets;         this.rxPackets = rxPackets;         this.linkLoss = linkLoss;     }     public Link getLink() {         return link;     }     public void setLink(Link link) {         this.link = link;     }     public U64 getRxPackets() {         return rxPackets;     }     public void setRxPackets(U64 rxPackets) {         this.rxPackets = rxPackets;     }     public U64 getTxPackets() {         return txPackets;     }     public void setTxPackets(U64 txPackets) {         this.txPackets = txPackets;     }     public U64 getLinkLoss() {         return linkLoss;     }     public void setLinkLoss(U64 linkLoss) {         this.linkLoss = linkLoss;     }     @Override     public String toString() {         return &quot;(&quot; + link.getSrc() + &quot;/&quot; + link.getSrcPort() + &quot;) -&gt; (&quot; + link.getDst() + &quot;/&quot; + link.getDstPort() + &quot;) TxPackets:&quot; + txPackets.getValue() + &quot; RxPackets:&quot; + rxPackets.getValue() + &quot; LinkLoss:&quot; + linkLoss.getValue() + &quot;%&quot;;             } }</code></pre></li></ol><ol start="2"><li><p>打开net.floodlightcontroller.statistics包中StatisticsCollector.java文件，在StatisticsCollector类中添加下列属性: </p><pre><code class="java"> // 获取链路的接口 private static ILinkDiscoveryService linkDiscoveryService; // 保存上一次查询的Port-Stats消息 private static HashMap&lt;Link, List&lt;OFPortStatsEntry&gt;&gt; priorLinkPortStats = new HashMap&lt;Link, List&lt;OFPortStatsEntry&gt;&gt;();  // 保存本次查询的Port-Stats消息 private static HashMap&lt;Link, List&lt;OFPortStatsEntry&gt;&gt; linkPortStats = new HashMap&lt;Link, List&lt;OFPortStatsEntry&gt;&gt;(); // 保存上一次查询与本次查询间隙的链路丢包率 private static HashMap&lt;Link, LinkLoss&gt; linkLossResults = new HashMap&lt;Link, LinkLoss&gt;(); //保存查询次数 private static int lookupCounter = 0;</code></pre></li></ol><ol start="3"><li><p>为了保证ILinkDiscoveryService接口能够正常使用，还需要添加接口的依赖并进行初始化，StatisticsCollector.java的相应方法中添加下列带有ADD注释的代码： </p><pre><code class="java"> @Override public Collection&lt;Class&lt;? extends IFloodlightService&gt;&gt; getModuleDependencies() {     Collection&lt;Class&lt;? extends IFloodlightService&gt;&gt; l =             new ArrayList&lt;Class&lt;? extends IFloodlightService&gt;&gt;();     l.add(IOFSwitchService.class);     l.add(IThreadPoolService.class);     l.add(IRestApiService.class);     // ADD:添加依赖     l.add(ILinkDiscoveryService.class);     return l; } @Override public void init(FloodlightModuleContext context)         throws FloodlightModuleException {     switchService = context.getServiceImpl(IOFSwitchService.class);     threadPoolService = context.getServiceImpl(IThreadPoolService.class);     restApiService = context.getServiceImpl(IRestApiService.class);     // ADD:初始化接口     linkDiscoveryService = context.getServiceImpl(ILinkDiscoveryService.class);     Map&lt;String, String&gt; config = context.getConfigParams(this);     if (config.containsKey(ENABLED_STR)) {         try {             isEnabled = Boolean.parseBoolean(config.get(ENABLED_STR).trim());         } catch (Exception e) {             log.error(&quot;Could not parse &#39;{}&#39;. Using default of {}&quot;, ENABLED_STR, isEnabled);         }     }     log.info(&quot;Statistics collection {}&quot;, isEnabled ? &quot;enabled&quot; : &quot;disabled&quot;);     if (config.containsKey(INTERVAL_PORT_STATS_STR)) {         try {             portStatsInterval = Integer.parseInt(config.get(INTERVAL_PORT_STATS_STR).trim());         } catch (Exception e) {             log.error(&quot;Could not parse &#39;{}&#39;. Using default of {}&quot;, INTERVAL_PORT_STATS_STR, portStatsInterval);         }     }     log.info(&quot;Port statistics collection interval set to {}s&quot;, portStatsInterval); }</code></pre></li></ol><ol start="4"><li><p>StatisticsCollector.java文件中将原来用于测量端口吞吐量的内部类PortStatsCollector的实现逻辑替换成以下代码： </p><pre><code class="java"> Private class PortStatsCollector implements Runnable {     @Override     // 计算丢包率     public void run() {         // 发起查询，获取所有交换机的Port-Stats消息，存储在replies中         Map&lt;DatapathId, List&lt;OFStatsReply&gt;&gt; replies = getSwitchStatistics(switchService.getAllSwitchDpids(), OFStatsType.PORT);         log.info(&quot;Replies Num:&quot; + replies.size());         // 查询次数计数器加一         ++lookupCounter;         log.info(&quot;Lookup Counter:&quot; + lookupCounter);         // 获取所有链路         Set&lt;Link&gt; links = linkDiscoveryService.getLinks().keySet();         log.info(&quot;Total Links:&quot; + links.size());         // 遍历链路         for(Link l : links) {             log.info(l.toString());             // 从replies中获取本次查询中，与当前链路起点有关的Port-Stats消息，存储到HashMap&lt;Link, List&lt;OFPortStatsEntry&gt;&gt; linkPortStats中             List&lt;OFStatsReply&gt; srcPortStatsReplies = replies.get(l.getSrc());             boolean breakFlag = false;             for(OFStatsReply r : srcPortStatsReplies) {                 OFPortStatsReply psr = (OFPortStatsReply) r;                 for (OFPortStatsEntry pse : psr.getEntries()) {                     if(pse.getPortNo().equals(l.getSrcPort())) {                         List&lt;OFPortStatsEntry&gt; tmpList = linkPortStats.get(l);                         if(tmpList == null || tmpList.isEmpty()) {                             tmpList = new ArrayList&lt;OFPortStatsEntry&gt;();                             tmpList.add(pse);                         }                         else {                             tmpList.add(pse);                         }                         linkPortStats.put(l, tmpList);                         breakFlag = true;                         break;                     }                 }                 if(breakFlag)                     break;             }             // 从replies中获取本次查询中，与当前链路终点有关的Port-Stats消息，存储到HashMap&lt;Link, List&lt;OFPortStatsEntry&gt;&gt; linkPortStats中             List&lt;OFStatsReply&gt; dstPortStatsReplies = replies.get(l.getDst());             breakFlag = false;             for(OFStatsReply r : dstPortStatsReplies) {                 OFPortStatsReply psr = (OFPortStatsReply) r;                 for (OFPortStatsEntry pse : psr.getEntries()) {                     if(pse.getPortNo().equals(l.getDstPort())) {                         List&lt;OFPortStatsEntry&gt; tmpList = linkPortStats.get(l);                         if(tmpList == null || tmpList.isEmpty()) {                             tmpList = new ArrayList&lt;OFPortStatsEntry&gt;();                             tmpList.add(pse);                         }                         else {                             tmpList.add(pse);                         }                         linkPortStats.put(l, tmpList);                         breakFlag = true;                         break;                     }                 }                 if(breakFlag)                     break;             }             // 若只有一次查询，则不计算丢包率             if(lookupCounter == 1) {                 continue;             }             // 获取上一次查询和本次查询的该链路的Port-Stats消息，计算该链路丢包率             OFPortStatsEntry srcPriorPSE = priorLinkPortStats.get(l).get(0);             OFPortStatsEntry dstPriorPSE = priorLinkPortStats.get(l).get(1);             OFPortStatsEntry srcCurrentPSE = linkPortStats.get(l).get(0);             OFPortStatsEntry dstCurrentPSE = linkPortStats.get(l).get(1);             U64 linkLoss = U64.ZERO;    // 丢包率范围：[0,1],linkloss中存储百分比             if(srcPriorPSE != null &amp;&amp; dstPriorPSE != null &amp;&amp; srcCurrentPSE != null &amp;&amp; dstCurrentPSE != null) {                 U64 srcTxPackets = U64.ofRaw(srcCurrentPSE.getTxPackets().getValue() - srcPriorPSE.getTxPackets().getValue() );                 U64 dstRxPackets = U64.ofRaw(dstCurrentPSE.getRxPackets().getValue() - dstPriorPSE.getRxPackets().getValue() );                 if(srcTxPackets.equals(U64.ZERO)) // 上一次查询与本次查询的间隙内，该链路上无数据包发送                     linkLoss = U64.ZERO;                 else if(srcTxPackets.compareTo(dstRxPackets) &lt; 0)                     linkLoss = U64.ofRaw(100);                 else if(!srcTxPackets.equals(U64.ZERO))                     linkLoss = U64.ofRaw(100 - (dstRxPackets.getValue() * 100 / srcTxPackets.getValue())) ;                 linkLossResults.put(l, new LinkLoss(l, srcTxPackets, dstRxPackets, linkLoss));             }//if         }//for         // 更新priorLinkPortStats，并清空本次查询结果linkPortStats         priorLinkPortStats =  new HashMap&lt;Link, List&lt;OFPortStatsEntry&gt;&gt;(linkPortStats);         linkPortStats.clear();         // 打印所有链路丢包率         if(!linkLossResults.isEmpty()) {             String result = &quot;&quot;;             for(Link l : linkLossResults.keySet()) {                 result += linkLossResults.get(l).toString() + &quot;\n&quot;;             }             log.info(result);         }     }//function }//class</code></pre></li></ol><ol start="5"><li><p>在Floodlight源码src/main/resources目录下的floodlightdefault.properties文件中，修改代码设置StatisticsCollector模块随着Floodlight控制器一起启动。 </p><pre><code class="java"> net.floodlightcontroller.statistics.StatisticsCollector.enable=TRUE</code></pre></li></ol><h2 id="0x05-Mininet搭建拓扑测量链路丢包率"><a href="#0x05-Mininet搭建拓扑测量链路丢包率" class="headerlink" title="0x05 Mininet搭建拓扑测量链路丢包率"></a>0x05 Mininet搭建拓扑测量链路丢包率</h2><p>假设拓扑如图8所示，使用带有链路丢包率测量模块的Floodlight控制器测量拓扑中所有交换机之间链路的丢包率。<br><img src="/imgs/Floodlight_Link_Packet_Loss_Rate_Measurement/%E9%93%BE%E8%B7%AF%E4%B8%A2%E5%8C%85%E7%8E%87%E6%B5%8B%E8%AF%95%E6%8B%93%E6%89%91.png" srcset="/img/loading.gif" alt="图8 链路丢包率测试拓扑"></p><ol><li><p>新开终端编译并启动Floodlight控制器。  </p><pre><code class="Shell"> cd floodlight ant java –jar target/floodlight.jar</code></pre></li><li><p>新开终端启动Mininet，构造如图8所示的测试拓扑。  </p><pre><code class="Shell"> sudo mn --controller=remote,ip=127.0.0.1 --switch ovsk,protocols=OpenFlow13 --mac --topo=linear,2</code></pre></li><li><p>在Mininet交互模式下打开主机H1的终端。  </p><pre><code class="Shell"> mininet &gt; xterm h1</code></pre></li><li><p>在主机H1终端上使用hping3发包工具以500pps（packet per second）的速率发送数据包给主机H2，Floodlight控制器终端显示测量的S1与S2之间链路丢包率结果如图9所示。  </p><pre><code class="Shell"> hping3 –i u2000 10.0.0.2</code></pre></li></ol><p><img src="/imgs/Floodlight_Link_Packet_Loss_Rate_Measurement/S1%E4%B8%8ES2%E4%B9%8B%E9%97%B4%E9%93%BE%E8%B7%AF%E4%B8%A2%E5%8C%85%E7%8E%87%E6%B5%8B%E9%87%8F%E7%BB%93%E6%9E%9C.png" srcset="/img/loading.gif" alt="图9 S1与S2之间链路丢包率测量结果"></p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><ul><li><a href="https://chentingz.github.io/2020/02/12/基于OpenFlow消息的网络测量方法/">基于OpenFlow消息的网络测量方法 </a></li></ul>]]></content>
    
    
    <categories>
      
      <category>SDN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于OpenFlow消息的网络测量方法</title>
    <link href="/2020/02/12/%E5%9F%BA%E4%BA%8EOpenFlow%E6%B6%88%E6%81%AF%E7%9A%84%E7%BD%91%E7%BB%9C%E6%B5%8B%E9%87%8F%E6%96%B9%E6%B3%95/"/>
    <url>/2020/02/12/%E5%9F%BA%E4%BA%8EOpenFlow%E6%B6%88%E6%81%AF%E7%9A%84%E7%BD%91%E7%BB%9C%E6%B5%8B%E9%87%8F%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-目录"><a href="#0x00-目录" class="headerlink" title="0x00 目录"></a>0x00 目录</h2><ul><li><a href="#0x00-目录">0x00 目录</a></li><li><a href="#0x01-前言">0x01 前言</a></li><li><a href="#0x02-基于openflow的port-stats消息测量丢包率和吞吐量">0x02 基于OpenFlow的Port-Stats消息测量丢包率和吞吐量</a><ul><li><a href="#port-stats消息">Port-Stats消息</a></li><li><a href="#测量丢包率">测量丢包率</a></li><li><a href="#测量吞吐量">测量吞吐量</a></li></ul></li><li><a href="#0x03-基于openflow的packet-out消息和packet-in消息测量拓扑和时延">0x03 基于OpenFlow的Packet-Out消息和Packet-In消息测量拓扑和时延</a><ul><li><a href="#packet-out消息">Packet-Out消息</a></li><li><a href="#packet-in消息">Packet-In消息</a></li><li><a href="#测量拓扑">测量拓扑</a></li><li><a href="#测量时延">测量时延</a></li></ul></li><li><a href="#0x04-参考">0x04 参考</a><a id="more"></a></li></ul><h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>网络运行情况需要通过链路丢包率、时延、吞吐量等网络性能指标来体现。本文总结了SDN中，利用OpenFlow消息去测量网络拓扑、链路丢包率和时延、以及交换机端口吞吐量的方法。</p><h2 id="0x02-基于OpenFlow的Port-Stats消息测量丢包率和吞吐量"><a href="#0x02-基于OpenFlow的Port-Stats消息测量丢包率和吞吐量" class="headerlink" title="0x02 基于OpenFlow的Port-Stats消息测量丢包率和吞吐量"></a>0x02 基于OpenFlow的Port-Stats消息测量丢包率和吞吐量</h2><p>OpenFlow交换机中维护了多种计数器，会对每张流表、每条流表项、每个物理端口、每条队列等进行信息统计。通过OpenFlow统计消息，SDN控制器可以周期性的查询并获取OpenFlow交换机的计数器统计信息，这些信息可用于测量丢包率和吞吐量，这种通过查询的测量方法属于被动测量。</p><p>OpenFlow统计消息包含Port-Stats消息、Flow-Stats消息、Aggregate-Stats消息、Queue-Stats消息、Group-Stats消息、Meter-Stats消息和Table-Stats消息，这些消息可用于获取OpenFlow交换机中指定计数器的统计信息，如Port-Stats消息可以用于获取指定OpenFlow交换机物理端口的统计信息，Flow-Stats消息用于获取指定流表项的统计信息。</p><h3 id="Port-Stats消息"><a href="#Port-Stats消息" class="headerlink" title="Port-Stats消息"></a>Port-Stats消息</h3><p>测量链路丢包率和端口吞吐量需要用到Port-Stats消息。</p><p>Port-Stats消息具体有两种，一种是Port-Stats-Request消息，用于SDN控制器请求交换机端口统计信息，另一种是Port-Stats-Reply消息，交换机用它来应答SDN控制器，具体过程是交换机读取指定端口的计数器，获得端口的统计信息并将其封装在该消息中，然后将消息发送给SDN控制器。在OpenFlow 1.3中，Port-Stats-Request和Port-Stats-Reply消息格式如图1和图2所示，SDN控制器可以从Port-Stats-Reply消息中获取到交换机端口的接收/发送数据包个数（rx_packets/tx_packets），接收/发送字节数（rx_bytes/tx_bytes），丢弃数据包个数(rx_dropped/tx_dropped)，冲突次数（collisions），端口生存时间（duration_sec和duration_nsec）等统计信息，这些信息将用于计算链路丢包率、端口吞吐量。</p><p><img src="/imgs/Network_Measurement_Based_On_OpenFlow_Message/OpenFlow1.3%E4%B8%AD%E7%9A%84Port-Stats-Request%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F.png" srcset="/img/loading.gif" alt="图1 OpenFlow1.3中的Port-Stats-Request消息格式"></p><p><img src="/imgs/Network_Measurement_Based_On_OpenFlow_Message/OpenFlow1.3%E4%B8%AD%E7%9A%84Port-Stats-Reply%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F.png" srcset="/img/loading.gif" alt="图2 OpenFlow1.3中的Port-Stats-Reply消息格式"></p><h3 id="测量丢包率"><a href="#测量丢包率" class="headerlink" title="测量丢包率"></a>测量丢包率</h3><p>丢包率是指一段时间内，数据包丢失数与总发送数的比值。</p><p>如图3所示，测量S1到S2方向的链路丢包率时，SDN控制器需定期向交换机S1和S2发送Port-Stats-Request消息，来获取S1的1端口发送数据包个数tx_packetss1以及S2的2端口接收数据包个数rx_packetss2。通过每隔一段时间进行轮询，利用公式（1）可以计算得到S1到S2方向的链路在第i-1次和第i次查询时间段内的丢包率。</p><p><img src="/imgs/Network_Measurement_Based_On_OpenFlow_Message/%E5%9F%BA%E4%BA%8EOpenFlow%E7%BB%9F%E8%AE%A1%E6%B6%88%E6%81%AF%E6%B5%8B%E9%87%8F%E9%93%BE%E8%B7%AF%E4%B8%A2%E5%8C%85%E7%8E%87%E5%8E%9F%E7%90%86%E5%9B%BE.png" srcset="/img/loading.gif" alt="图3 基于OpenFlow统计消息测量链路丢包率原理图"></p><p><img src="/imgs/Network_Measurement_Based_On_OpenFlow_Message/%E9%93%BE%E8%B7%AF%E4%B8%A2%E5%8C%85%E7%8E%87%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" srcset="/img/loading.gif" alt></p><h3 id="测量吞吐量"><a href="#测量吞吐量" class="headerlink" title="测量吞吐量"></a>测量吞吐量</h3><p>吞吐量是指单位时间内传输无差错数据总量。</p><p>测量交换机端口吞吐量时，依然按图3所示，SDN控制器将周期性发送Port-Stats-Request消息到指定交换机，并从交换机的Port-Stats-Reply消息中获取接收/发送字节数（rx_bytes/tx_bytes）和端口生存时间（duration_sec和duration_nsec），利用公式（2）和（3）可以计算第i-1次和第i次查询时间段内的吞吐量大小。</p><p><img src="/imgs/Network_Measurement_Based_On_OpenFlow_Message/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%AB%AF%E5%8F%A3%E5%90%9E%E5%90%90%E9%87%8F%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" srcset="/img/loading.gif" alt></p><pre><code>注：交换机的一个物理端口实际上是由一个TX端口和一个RX端口组成，分别用于发送和接收数据，因此端口吞吐量实际指的是TX端口的发送吞吐量，以及RX端口的接收吞吐量。例如，计算发送吞吐量，则公式2中的分子为tx_bytes(i) - tx_bytes(i-1)。</code></pre><h2 id="0x03-基于OpenFlow的Packet-Out消息和Packet-In消息测量拓扑和时延"><a href="#0x03-基于OpenFlow的Packet-Out消息和Packet-In消息测量拓扑和时延" class="headerlink" title="0x03 基于OpenFlow的Packet-Out消息和Packet-In消息测量拓扑和时延"></a>0x03 基于OpenFlow的Packet-Out消息和Packet-In消息测量拓扑和时延</h2><p>根据主动测量的思想，可由SDN控制器生成探测数据包并下发至指定的交换机，当测量过程结束时，被测交换机需要触发相应机制将探测包返回控制器，由控制器分析并计算得到测量结果。由于SDN网络中交换机处理数据包的规则，即流表项，需要由控制器指定，因此实现主动测量的关键在于控制器如何生成和回收探测数据包，以及如何制定探测包的转发规则。</p><h3 id="Packet-Out消息"><a href="#Packet-Out消息" class="headerlink" title="Packet-Out消息"></a>Packet-Out消息</h3><p>OpenFlow协议规定了控制器和交换机相互发送数据包的消息类型。由控制器发起的Controller-to-Switch消息类型中，包含一类Packet-Out消息，其格式如图4所示。控制器能够自定义该消息中携带的数据包内容，以及交换机收到Packet-Out消息后的行为。控制器通过在Packet-Out消息中封装探测数据包并下发至指定交换机，就能够发起主动测量任务。</p><p><img src="/imgs/Network_Measurement_Based_On_OpenFlow_Message/OpenFlow1.3%E4%B8%ADPacket-Out%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F.png" srcset="/img/loading.gif" alt="图4 OpenFlow1.3中Packet-Out消息格式"></p><h3 id="Packet-In消息"><a href="#Packet-In消息" class="headerlink" title="Packet-In消息"></a>Packet-In消息</h3><p>在由交换机发起的Asynchronous消息类型中，包含Packet-In消息，其格式如图5所示，该消息与Packet-Out类似，可以封装交换机上的指定数据包并发送至控制器做进一步处理。当交换机中的流表项无法匹配某个数据包时，会默认触发Packet-In消息。由于探测数据包通常与网络中的正常流量有所不同，因此基于OpenFlow的SDN主动测量可以利用Packet-In消息机制实现探测包的回收。</p><p><img src="/imgs/Network_Measurement_Based_On_OpenFlow_Message/OpenFlow1.3%E4%B8%ADPacket-In%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F.png" srcset="/img/loading.gif" alt="图5 OpenFlow1.3中Packet-In消息格式"></p><h3 id="测量拓扑"><a href="#测量拓扑" class="headerlink" title="测量拓扑"></a>测量拓扑</h3><p>拓扑测量负责对网络中各个设备之间的链路关系进行定期的检测，并维护完整的网络拓扑，是控制器和上层应用实现对整个网络资源进行统一调度和管理的基础。在传统IP网络中，拓扑测量采用链路发现协议(LLDP)。LLDP报文格式如图6所示，其中包含了Chassis ID TLV(设备标示符)，Port ID TLV(端口标示符)等字段，每个网络节点将自己和相邻设备的链路信息发送给其他节点，最终实现在各个网络设备上分散地测量链路信息。</p><p><img src="/imgs/Network_Measurement_Based_On_OpenFlow_Message/LLDP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" srcset="/img/loading.gif" alt="图6 LLDP报文格式"></p><p>目前，OpenFlow的拓扑发现协议(OFDP)依然沿用了LLDP协议，基于OpenFlow的Packet-Out和Packet-In消息测量拓扑，其采用了主动测量方式，原理如图7所示，基本思想如下：</p><p>（1）控制器构造包含LLDP数据包的Packet-Out消息下发至交换机S1，并指定从某端口转发至交换机S2，其中LLDP数据包中的Chassis ID TLV字段设置为交换机S1的Datapath ID，Port ID TLV字段设置为交换机目标转发端口。</p><p>（2）S2接收到LLDP数据包，触发Packet-In消息，将LLDP数据包发回控制器。</p><p>（3）控制器通过分析LLDP数据包，可以得到LLDP数据包在交换机S1上的发出端口和在交换机S2上的接收端口存在链接关系，从而获得一条链路信息。通过这种方式，控制器可以实现对整个网络的拓扑测量，发送的Packet-Out信息数量与网络中所有交换机活动端口的数量有关。</p><p><img src="/imgs/Network_Measurement_Based_On_OpenFlow_Message/%E5%9F%BA%E4%BA%8EPacket-Out%E5%92%8CPacket-In%E6%B6%88%E6%81%AF%E6%B5%8B%E9%87%8F%E6%8B%93%E6%89%91%E5%8E%9F%E7%90%86%E5%9B%BE.png" srcset="/img/loading.gif" alt="图7 基于Packet-Out和Packet-In消息测量拓扑原理图"></p><h3 id="测量时延"><a href="#测量时延" class="headerlink" title="测量时延"></a>测量时延</h3><p>交换机之间传输时延是表明链路运行状态的重要参数。由于OpenFlow交换机不具备在正常传输的报文中打时间戳的功能，无法采用传统IP网络中的被动测量方式。因此，需要利用主动测量思想，在交换机之间生成并发送探测包。如图8所示，控制器的测量目标是交换机S1到交换机S2的时延，则控制器将探测包发送至S1，并下发规则指定S1将探测包发送至S2。S2接收到探测包后，由于没有对应的转发规则，会将探测包返回控制器，控制器则会计算出探测包在路径中传输的总时间。由于控制器和交换机之间的通信也存在时延，因此控制器还需要发送通信消息，获得控制器和各个交换机之间的消息往返时间，通过计算差值，获得最终的链路时延结果。</p><p><img src="/imgs/Network_Measurement_Based_On_OpenFlow_Message/%E5%9F%BA%E4%BA%8EPacket-Out%E5%92%8CPacket-In%E6%B6%88%E6%81%AF%E6%B5%8B%E9%87%8F%E6%97%B6%E5%BB%B6%E5%8E%9F%E7%90%86%E5%9B%BE.png" srcset="/img/loading.gif" alt="图8 基于Packet-Out和Packet-In消息测量时延原理图"></p><p>因此，测量时延的详细步骤如下：</p><p>(1)获得探测包传输时间Ttravel：控制器生成探测数据包，其中包含交换机S1的目标转发端口和生成探测数据包时的时间戳，用来记录探测包的转发路径和发送探测包的时间。然后，控制器通过Packet-Out消息封装探测数据包，并下发至交换机S1，并从指定端口将探测包转发至S2。S2接收到数据包后，由于没有匹配的流表项，会触发Packet-In消息，将探测包封装并返回控制器。控制器通过对探测包的字段进行分析，可以得到探测包在“控制器一S1—S2一控制器”路径上的传输时间Ttravel。</p><p>(2)获得控制器和交换机的往返时间RTT：得到Ttravel后，还需要知道数据包控制器和交换机往返传输时间，从而计算得到控制器下发探测包以及交换机返回探测包的时延。根据OpenFlow协议，控制器生成Echo Request消息分别下发交换机S1和S2，并记录收到Echo Reply消息的时间，得到控制器和交换机的往返传输时间RTT</p><p> (3)计算交换机链路时延：根据上述测量结果，通过公式(4)计算得到交换机S1和S2之间的时延Tdelay。</p><p><img src="/imgs/Network_Measurement_Based_On_OpenFlow_Message/%E9%93%BE%E8%B7%AF%E6%97%B6%E5%BB%B6%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" srcset="/img/loading.gif" alt></p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><ul><li><a href="http://d.old.wanfangdata.com.cn/Thesis/Y3141829" target="_blank" rel="noopener">刘一童. SDN网络测量系统的研究与实现[D]. 2016.</a></li><li><a href="http://www.cnki.com.cn/Article/CJFDTotal-PZKX201803005.htm" target="_blank" rel="noopener">张恒, 蔡志平, 李阳. SDN网络测量技术综述[J]. 中国科学:信息科学, 2018, v.48(03):65-86.</a></li><li><a href="https://www.sdnlab.com/15733.html" target="_blank" rel="noopener">基于SDN的网络状态测量 / 北邮李呈</a></li><li><a href="https://book.douban.com/subject/26715562/" target="_blank" rel="noopener">图解OpenFlow</a></li><li><a href="https://www.opennetworking.org/wp-content/uploads/2014/10/openflow-spec-v1.3.0.pdf" target="_blank" rel="noopener">openflow-spec-v1.3.0</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>SDN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「OpenFlow」协议入门</title>
    <link href="/2019/12/30/%E3%80%8COpenFlow%E3%80%8D%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/"/>
    <url>/2019/12/30/%E3%80%8COpenFlow%E3%80%8D%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-目录"><a href="#0x00-目录" class="headerlink" title="0x00 目录"></a>0x00 目录</h2><ul><li><a href="#0x00-目录">0x00 目录</a></li><li><a href="#0x01-前言">0x01 前言</a></li><li><a href="#0x02-openflow简介">0x02 OpenFlow简介</a></li><li><a href="#0x03-sdn与openflow的关系">0x03 SDN与OpenFlow的关系</a></li><li><a href="#0x04-基于openflow的sdn网络工作原理">0x04 基于OpenFlow的SDN网络工作原理</a><ul><li><a href="#传统网络中网络设备的工作过程">传统网络中网络设备的工作过程</a></li><li><a href="#基于openflow的sdn网络中网络设备的工作过程">基于OpenFlow的SDN网络中网络设备的工作过程</a></li><li><a href="#小结">小结</a></li></ul></li><li><a href="#0x05-流表与流水线处理">0x05 流表与流水线处理</a><ul><li><a href="#流">流</a></li><li><a href="#流表">流表</a><ul><li><a href="#匹配域">匹配域</a></li><li><a href="#指令与动作">指令与动作</a></li><li><a href="#流表匹配过程">流表匹配过程</a></li><li><a href="#例子使用单流表转发数据包">例子——使用单流表转发数据包</a></li></ul></li><li><a href="#多级流表与流水线处理">多级流表与流水线处理</a><ul><li><a href="#例子多级流表实现对流的细粒度控制">例子——多级流表实现对流的细粒度控制</a></li></ul></li></ul></li><li><a href="#0x06-openflow的两种下发流表方式">0x06 OpenFlow的两种下发流表方式</a><ul><li><a href="#proactive">Proactive</a></li><li><a href="#reactive">Reactive</a></li></ul></li><li><a href="#0x07-组表">0x07 组表</a><ul><li><a href="#例子使用组表实现多播">例子——使用组表实现多播</a></li></ul></li><li><a href="#0x08-计量表">0x08 计量表</a><ul><li><a href="#例子对流进行限速">例子——对流进行限速</a></li></ul></li><li><a href="#0x09-openflow消息">0x09 OpenFlow消息</a><ul><li><a href="#种类">种类</a></li><li><a href="#flow-mod消息">Flow-Mod消息</a></li><li><a href="#packet-in消息">Packet-In消息</a></li><li><a href="#packet-out消息">Packet-Out消息</a></li><li><a href="#port-stats消息">Port-Stats消息</a></li></ul></li><li><a href="#0x0a-参考">0x0A 参考</a><a id="more"></a></li></ul><h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>本文主要参考OpenFlow v1.5.1协议、v1.3.0协议以及SDN相关书籍，对OpenFlow中主要机制（如流表与流水线处理、组表、计量表等）的原理进行解析</p><h2 id="0x02-OpenFlow简介"><a href="#0x02-OpenFlow简介" class="headerlink" title="0x02 OpenFlow简介"></a>0x02 OpenFlow简介</h2><p>OpenFlow由斯坦福大学Nick Mckeown教授提出，为SDN控制平面与数据平面之间提供通信接口标准，以实现SDN网络的转控分离架构。OpenFlow协议允许SDN控制器直接访问和操作数据平面中的网络设备，控制网络转发行为，数据平面采用基于流的方式进行转发。目前由ONF（Open Networking Foundation）负责推广和制定OpenFlow标准，截至本文发表时，最新版本为1.5.1</p><p><img src="/imgs/Introduction_to_OpenFlow/OpenFlow%E7%89%88%E6%9C%AC%E5%8F%98%E8%BF%81.png" srcset="/img/loading.gif" alt="OpenFlow版本变迁"></p><h2 id="0x03-SDN与OpenFlow的关系"><a href="#0x03-SDN与OpenFlow的关系" class="headerlink" title="0x03 SDN与OpenFlow的关系"></a>0x03 SDN与OpenFlow的关系</h2><p>可以说OpenFlow是SDN中非常重要的技术，以至于许多人（包括笔者在内）在谈及SDN时就自然联想到OpenFlow。但SDN与OpenFlow不是划等号的关系，而是SDN包含OpenFlow的关系。实际上，SDN有多种实现方案，在ONF SDN方案中OpenFlow充当南向接口的作用。<br>南向接口的定义是控制平面与数据平面之间进行交互的协议，南向接口除了可以采用OpenFlow外，还有许多别的协议，如OF-CONFIG、OVSDB、NETCONF、PCEP、XMPP等等</p><h2 id="0x04-基于OpenFlow的SDN网络工作原理"><a href="#0x04-基于OpenFlow的SDN网络工作原理" class="headerlink" title="0x04 基于OpenFlow的SDN网络工作原理"></a>0x04 基于OpenFlow的SDN网络工作原理</h2><h3 id="传统网络中网络设备的工作过程"><a href="#传统网络中网络设备的工作过程" class="headerlink" title="传统网络中网络设备的工作过程"></a>传统网络中网络设备的工作过程</h3><p>假设主机A向主机B发送IP数据包，且所有路由表和MAC地址表中都有该数据包的相应表项</p><ul><li>路由器之间<strong>运行分布式路由协</strong>议构建路由表。查表成功则<strong>基于目的IP地址转发</strong>；查表失败时，丢弃数据包</li><li>交换机根据<strong>自学习算法</strong>构建MAC地址表。查表成功则<strong>基于目的MAC地址转发</strong>；查表失败时，除入端口外其余所有端口转发出去</li></ul><p><img src="/imgs/Introduction_to_OpenFlow/%E4%BC%A0%E7%BB%9F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" alt="传统网络中网络设备的工作过程"></p><h3 id="基于OpenFlow的SDN网络中网络设备的工作过程"><a href="#基于OpenFlow的SDN网络中网络设备的工作过程" class="headerlink" title="基于OpenFlow的SDN网络中网络设备的工作过程"></a>基于OpenFlow的SDN网络中网络设备的工作过程</h3><p>假设主机A向主机B发送IP数据包，且<strong>所有流表有该数据包相应表项</strong></p><ul><li>OpenFlow交换机查询流表来转发数据包，查表成功则<strong>基于匹配域（如目的IP地址+源IP地址）转发</strong>；查表失败时，则询问SDN控制器</li><li>流表由SDN控制器来构建</li></ul><p><img src="/imgs/Introduction_to_OpenFlow/%E6%B5%81%E8%A1%A8%E4%B8%8D%E7%A9%BA%E6%97%B6%EF%BC%8C%E5%9F%BA%E4%BA%8EOpenFlow%E7%9A%84SDN%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" alt="流表不空时，基于OpenFlow的SDN网络中网络设备的工作过程"></p><p>假设主机A向主机B发送IP数据包，且<strong>OpenFlow交换机中流表为空</strong></p><ol><li>OF交换机接收IP数据包</li><li>OF交换机解析数据包首部并查询流表，由于流表为空，不知道如何转发，因此需要询问控制器</li><li>OF交换机向控制器发送Packet-In消息</li><li>控制器为主机A发送给主机B的IP数据包计算路由</li><li>控制器向OF交换机下发流表，使用FlowMod消息承载流表信息，OF交换机接收该消息后安装流表</li><li>控制器向OF交换机发送Packet-Out消息，指示OF交换机按照刚安装好的流表转发IP数据包</li><li>OF交换机收到Packet-Out消息后转发数据包<br><img src="/imgs/Introduction_to_OpenFlow/%E6%B5%81%E8%A1%A8%E4%B8%BA%E7%A9%BA%E6%97%B6%EF%BC%8C%E5%9F%BA%E4%BA%8EOpenFlow%E7%9A%84SDN%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" alt="流表为空时，基于OpenFlow的SDN网络中网络设备的工作过程"></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>路由计算、转发规则（流表）下发由控制器完成</li><li>OF交换机只需要按照流表进行转发，查表失败时，通过Pacekt-In消息询问控制器  </li></ul><p><img src="/imgs/Introduction_to_OpenFlow/%E4%BC%A0%E7%BB%9F%E7%BD%91%E7%BB%9C%E4%B8%8EOpenFlow%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E5%AF%B9%E6%AF%94.png" srcset="/img/loading.gif" alt="传统网络与OpenFlow网络中网络设备对比"></p><h2 id="0x05-流表与流水线处理"><a href="#0x05-流表与流水线处理" class="headerlink" title="0x05 流表与流水线处理"></a>0x05 流表与流水线处理</h2><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>在介绍流表之前，需要先解释流的概念，流（Flow）就是具有相同特征的数据包集合。例如，源MAC地址为MAC_A，目的MAC地址为MAC_B的所有数据包集合就可以视为一条流，可见流具有方向性。有别于传统网络中路由器基于数据包独立转发的模式，使用OpenFlow的SDN网络是基于流进行转发的，即对相同特征的数据包集合采用同样的处理。</p><h3 id="流表"><a href="#流表" class="headerlink" title="流表"></a>流表</h3><p>流表（Flow Table）是OpenFlow中最重要的一张表，它用于指导OpenFlow交换机对收到的数据包进行转发，相当于二层的MAC地址表和三层的路由表。在OpenFlow 1.1以后的版本中，每台交换机支持使用多张流表，构成流水线处理，从而完成对数据包更为复杂的处理。</p><p>流表由若干条流表项（Flow Entry）组成，流表项结构如下图所示。</p><p><img src="/imgs/Introduction_to_OpenFlow/%E6%B5%81%E8%A1%A8%E9%A1%B9%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" alt="流表项结构">  </p><ul><li>匹配域（Match Fields）：用于定义某条流，也是流表匹配的依据</li><li>指令（Instructions）：表示对该条流应该如何处理</li><li>优先级（Priority）：表示该流表项的优先匹配程度</li><li>计数器（Counters）：用于统计该条流的信息</li><li>生存时间（Timeouts）：表示流表项的有效存活时间</li><li>Cookie：控制器设置用来过滤被流统计、流修改和流删除操作请求影响的流表项</li><li>标志（Flags）：用于流表项管理</li></ul><p>流表项最为重要的两项为匹配域和指令，当OpenFlow交换机收到一个数据包，将它包头解析后与流表中流表项匹配域进行匹配，匹配成功则执行指令，因此流表可以简化理解为key-value形式的{匹配域-指令}表。</p><h4 id="匹配域"><a href="#匹配域" class="headerlink" title="匹配域"></a>匹配域</h4><p>OpenFlow提供丰富的匹配域字段来定义不同粒度的流，如可以基于目的IP地址定义一条流，也可以根据源IP地址 + 目的IP地址来定义一条流<br><img src="/imgs/Introduction_to_OpenFlow/%E5%8C%B9%E9%85%8D%E5%9F%9F.png" srcset="/img/loading.gif" alt="匹配域"> </p><h4 id="指令与动作"><a href="#指令与动作" class="headerlink" title="指令与动作"></a>指令与动作</h4><p>指令（Instruction）是流表项匹配成功时的处理动作，分为三类</p><ul><li>更新动作集（Action Set）：添加、修改、清空动作集，前面两个对应Write-Actions指令，清空动作集对应Clear-Actions指令</li><li>修改流水线处理次序：从序号低的表跳转到序号高的表，对应Go-To-Table指令</li><li>其他：更新元数据以及设定触发器，分别对应Write-Metadata指令和Stat-Trigger指令</li></ul><p><img src="/imgs/Introduction_to_OpenFlow/%E6%8C%87%E4%BB%A4.png" srcset="/img/loading.gif" alt="指令"> </p><p>动作（Action）<br>Action是指对数据包的具体处理动作，可分为两类，一类是定义数据包的转发，另一类是修改数据包包头字段</p><p><img src="/imgs/Introduction_to_OpenFlow/%E5%8A%A8%E4%BD%9C.png" srcset="/img/loading.gif" alt="动作"> </p><h4 id="流表匹配过程"><a href="#流表匹配过程" class="headerlink" title="流表匹配过程"></a>流表匹配过程</h4><p>解析数据包得到的首部字段，用于与流表项匹配域进行匹配。若一个数据包与多个流表项匹配成功，最后只与优先级最高的流表项进行匹配。</p><ul><li>匹配成功，更新计数器，执行相应指令</li><li>匹配失败<ul><li>流表中没有设置Table-Miss流表项，匹配失败时，丢弃数据包</li><li>流表中设置有Table-Miss流表项（优先级为0且匹配域为ANY），则最后会匹配该表项，执行相应指令（如丢弃、交由控制器处理、交给下一张流表处理）</li></ul></li></ul><p><img src="/imgs/Introduction_to_OpenFlow/%E6%B5%81%E8%A1%A8%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" alt="流表匹配过程"> </p><h4 id="例子——使用单流表转发数据包"><a href="#例子——使用单流表转发数据包" class="headerlink" title="例子——使用单流表转发数据包"></a>例子——使用单流表转发数据包</h4><p>假设主机A发送数据包给主机B，使用单张流表的OF交换机处理数据包过程，如图所示</p><ol><li>OF交换机从1端口接收数据包</li><li>OF交换机解析数据包首部，并查询流表进行流表匹配，匹配第一条流表项，并执行相应指令</li><li>将数据包转发到OF交换机的2端口</li></ol><p><img src="/imgs/Introduction_to_OpenFlow/%E4%BD%BF%E7%94%A8%E5%8D%95%E6%B5%81%E8%A1%A8%E8%BD%AC%E5%8F%91%E6%95%B0%E6%8D%AE%E5%8C%85.png" srcset="/img/loading.gif" alt="使用单流表转发数据包"></p><h3 id="多级流表与流水线处理"><a href="#多级流表与流水线处理" class="headerlink" title="多级流表与流水线处理"></a>多级流表与流水线处理</h3><p>从OpenFlow1.1开始引入了多级流表和流水线处理机制，多级流表的出现一方面能够实现对数据包的复杂处理，另一方面又能有效降低单张流表的长度，提高查表效率。每张表都有序号，数据包通过跳转指令按照流表序号递增的方向在多个流表之间进行匹配，这样就构成了一条流水线，如下图所示，可见流水线处理是有方向的。流水线处理可以在OpenFlow交换机的入端口或出端口上进行，一般都在入端口出进行流水线处理。当流水线上只有一张流表时，就简化成单流表匹配的情况。</p><p><img src="/imgs/Introduction_to_OpenFlow/%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6.png" srcset="/img/loading.gif" alt="流水线处理机制"></p><ul><li>流水线处理开始：OpenFlow交换机接收数据包后，执行入端口的流水线处理，同时给该流水线分配一个动作集（Action Set）</li><li>流表匹配<ul><li>匹配成功<ul><li>更新相应流表项的计数器，完成对该条流的统计工作</li><li>执行流表项对应的指令</li></ul></li><li>匹配失败：一个数据包可能在流表中与所有的流表项都不匹配或者匹配到Table-Miss流表项（优先级为0且匹配域为ANY），这两种情况都称为Table-Miss，对于前者，OpenFlow交换机将丢弃数据包；对于后者，OpenFlow交换机根据Table-Miss流表项，处理数据包（丢弃数据包、转发给控制器、交给下一个流表处理）</li></ul></li><li>流水线处理结束：若当前不是执行跳转指令，则执行动作集中的所有动作，完成对数据包的处理，然后结束流水线处理</li></ul><h4 id="例子——多级流表实现对流的细粒度控制"><a href="#例子——多级流表实现对流的细粒度控制" class="headerlink" title="例子——多级流表实现对流的细粒度控制"></a>例子——多级流表实现对流的细粒度控制</h4><p>使用多级流表实现主机A发送到给主机B的所有TCP报文正常转发，UDP报文均丢弃，从而实现对不同流的细粒度控制<br>基本思想：</p><ol><li>流表0中匹配主机A到主机B的IP流，然后跳转到其他流表，如流表2</li><li>流表2中在IP流的基础上进一步匹配TCP流或UDP流，根据要求将TCP流正常转发，UDP流丢弃</li></ol><p><img src="/imgs/Introduction_to_OpenFlow/%E5%A4%9A%E7%BA%A7%E6%B5%81%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%AF%B9%E6%B5%81%E7%9A%84%E7%BB%86%E7%B2%92%E5%BA%A6%E6%8E%A7%E5%88%B6.png" srcset="/img/loading.gif" alt="多级流表实现对流的细粒度控制"></p><h2 id="0x06-OpenFlow的两种下发流表方式"><a href="#0x06-OpenFlow的两种下发流表方式" class="headerlink" title="0x06 OpenFlow的两种下发流表方式"></a>0x06 OpenFlow的两种下发流表方式</h2><p>根据流表的安装时机，可分为Proactive方式和Reactive方式</p><h3 id="Proactive"><a href="#Proactive" class="headerlink" title="Proactive"></a>Proactive</h3><p>在数据包还未到达OpenFlow交换机前，SDN控制器就向OpenFlow交换机主动下发流表，这种方式相当于<strong>预置路由</strong></p><p>例如Table-Miss表项，就需要采用Proactive方式在SDN控制器与OpenFlow交换机建立连接后下发，显示的指定数据包查表失败时，OpenFlow交换机的处理方式</p><h3 id="Reactive"><a href="#Reactive" class="headerlink" title="Reactive"></a>Reactive</h3><p>数据包到达OpenFlow交换机因查流表失败时，产生Packet-In消息询问SDN控制器，SDN控制器计算路由后下发流表到OpenFlow交换机，这种方式相当于<strong>按需下发路由</strong>，只有在有路由需求且查流表失败时，才会触发新的流表安装</p><h2 id="0x07-组表"><a href="#0x07-组表" class="headerlink" title="0x07 组表"></a>0x07 组表</h2><p>独立于流水线之外，每台OpenFlow交换机只有一张组表。组表（Group Table）由若干条组表项（Group Entry）组成，具有将多个端口定义为一个组的能力，从而实现广播、多播，负载均衡、链路聚合、故障转移等</p><p>组表项结构如图所示，定义了一到多个动作桶（Action Bucket），用于描述转发到指定端口前，对数据包的处理。</p><p><img src="/imgs/Introduction_to_OpenFlow/%E7%BB%84%E8%A1%A8%E9%A1%B9%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" alt="组表项结构"></p><p><img src="/imgs/Introduction_to_OpenFlow/%E7%BB%84%E7%B1%BB%E5%9E%8B.png" srcset="/img/loading.gif" alt="组类型"></p><h3 id="例子——使用组表实现多播"><a href="#例子——使用组表实现多播" class="headerlink" title="例子——使用组表实现多播"></a>例子——使用组表实现多播</h3><p>假设主机A使用多播方式向主机B和C发送IP数据包<br><img src="/imgs/Introduction_to_OpenFlow/%E4%BD%BF%E7%94%A8%E7%BB%84%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%92%AD.png" srcset="/img/loading.gif" alt="使用组表实现多播"></p><h2 id="0x08-计量表"><a href="#0x08-计量表" class="headerlink" title="0x08 计量表"></a>0x08 计量表</h2><p>对流进行测量，从而为流提供QoS功能，如限速、DiffServ</p><p>每台OpenFlow交换机只有一张计量表（Meter Table），由若干计量表项（Meter Entry）组成，每个计量表项可以定义一至多个计量带（Meter Band），计量带定义了带宽阈值和数据包处理方式（丢弃、DSCP标记）</p><p><img src="/imgs/Introduction_to_OpenFlow/%E8%AE%A1%E9%87%8F%E8%A1%A8.png" srcset="/img/loading.gif" alt="计量表"></p><h3 id="例子——对流进行限速"><a href="#例子——对流进行限速" class="headerlink" title="例子——对流进行限速"></a>例子——对流进行限速</h3><p>假设对某条流X（目的IP地址：10.0.0.2）进行限速，且当前测得流X数据包的速率为1200kBps</p><ul><li>流表匹配后，交由计量1处理</li><li>由于测得数据包速率1200kBps &gt; 带宽阈值1000，根据计量带0定义的处理方式丢弃数据包，从而实现限速<pre><code>注：带宽阈值本身是无单位的数值，其表示含义取决于应用场景</code></pre><img src="/imgs/Introduction_to_OpenFlow/%E5%AF%B9%E6%B5%81%E8%BF%9B%E8%A1%8C%E9%99%90%E9%80%9F.png" srcset="/img/loading.gif" alt="对流进行限速"></li></ul><h2 id="0x09-OpenFlow消息"><a href="#0x09-OpenFlow消息" class="headerlink" title="0x09 OpenFlow消息"></a>0x09 OpenFlow消息</h2><h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><p>消息按照发送的位置可分为三大类，每一大类中有若干子消息</p><ul><li><p>Controller-to-Switch消息：SDN控制器主动发送给OpenFlow交换机的消息</p><ul><li>Features：用于获取交换机特性</li><li>Configuration：用来配置和查询交换机参数</li><li>Modify-State：用来修改交换机状态信息（增删改流表项、组表项等）<ul><li>Table-Mod消息</li><li>Flow-Mod消息（流表操作，添加、删除、修改流表项）</li><li>Group-Mod消息</li><li>Port-Mod消息</li><li>Meter-Mod消息</li></ul></li><li>Read-State：用来读取交换机状态信息（当前配置、统计信息等）<ul><li>Port-Stats消息</li><li>Flow-Stats消息</li><li>…</li></ul></li><li>Packet-Out：用来指定交换机将数据包从指定端口转发出去</li><li>Barrier：在不同消息之间使用，确保操作顺序执行</li><li>Role Request：控制器用于询问或设置自身在交换机中的角色，常用于交换机与多控制器连接的场景</li><li>Asynchronous-Configuration：控制器设置异步消息过滤器，只接收感兴趣的异步消息，一般在多控制器场景下使用</li></ul></li><li><p>Asynchronous（异步）消息：OpenFlow交换机主动发送给SDN控制器的异步消息</p><ul><li>Packet-In：将数据包交给控制器处理，一般流表匹配中出现Table-Miss时或流表项显示指定将数据包交给控制器时，触发该消息</li><li>Flow-Removed：通知控制器，流表项被删除；流表项超时或控制器删除流表项时触发该消息（需要在交换机配置时使能该消息）</li><li>Port-status ：通知控制器，交换机端口状态发生变化</li><li>Role-status：通知控制器，控制器在交换机中的角色发送变化</li><li>Controller-Status：通知控制器，OpenFlow通道状态发生变化</li><li>Flow-monitor：通知控制器，流表发送变化</li></ul></li></ul><ul><li>Symmetric（对称）消息：可由SDN控制器或OpenFlow交换机主动发送的消息<ul><li>Hello：建立控制器与交换机之间的OpenFlow通道</li><li>Echo：检测交换机与控制器之间的连接状态或测量OpenFlow通道的时延和带宽</li><li>Error：用于通告错误</li><li>Experiment：用于实验，测试新特性</li></ul></li></ul><p><img src="/imgs/Introduction_to_OpenFlow/OpenFlow%E6%B6%88%E6%81%AF%E7%A7%8D%E7%B1%BB.png" srcset="/img/loading.gif" alt="OpenFlow消息种类"></p><h3 id="Flow-Mod消息"><a href="#Flow-Mod消息" class="headerlink" title="Flow-Mod消息"></a>Flow-Mod消息</h3><p>Flow-Mod消息用于流表操作，包括添加、删除、修改流表项。该消息由控制器下发给交换机，从而指导交换机对数据包的处理。</p><p>其在OpenFlow1.3中的消息格式如下图所示。<br><img src="/imgs/Introduction_to_OpenFlow/OpenFlow1.3%E4%B8%ADFlow-Mod%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F.png" srcset="/img/loading.gif" alt="OpenFlow1.3中Flow-Mod消息格式"></p><ul><li>command：<ul><li>ADD:添加流表项</li><li>MODIFY：根据匹配域，修改所有匹配的流表项，可能有多条流表项被修改</li><li>MODIFY_STRICT：根据匹配域以及优先级，修改特定的流表项，只有一条流表项被修改</li><li>DELETE：根据匹配域，删除所有匹配的流表项，可能有多条流表项被删除</li><li>DELETE_STRICT：根据匹配域以及优先级，删除特定的流表项，只有一条流表项被删除</li><li>参考<a href="https://chentingz.github.io/2019/12/27/%E3%80%8COpenFlow%E3%80%8D%E6%B5%81%E8%A1%A8%E9%A1%B9%E5%88%A0%E9%99%A4DELETE%E4%B8%8EDELETE_STRICT%E7%9A%84%E5%8C%BA%E5%88%AB/">「OpenFlow」流表项删除DELETE与DELETE_STRICT的区别 </a></li></ul></li></ul><h3 id="Packet-In消息"><a href="#Packet-In消息" class="headerlink" title="Packet-In消息"></a>Packet-In消息</h3><p>Packet-In消息用于将OpenFlow交换机上指定数据包交给控制器处理，一般流表匹配中出现Table-Miss时或流表项显示指定将数据包交给控制器时，触发该消息。此外，它还能用于主动测量时回收探测包，从而结合Packet-Out消息实现对网络拓扑与链路时延的测量，详情参考<a href="https://chentingz.github.io/2020/02/12/%E5%9F%BA%E4%BA%8EOpenFlow%E6%B6%88%E6%81%AF%E7%9A%84%E7%BD%91%E7%BB%9C%E6%B5%8B%E9%87%8F%E6%96%B9%E6%B3%95/#0x03-%E5%9F%BA%E4%BA%8Eopenflow%E7%9A%84packet-out%E6%B6%88%E6%81%AF%E5%92%8Cpacket-in%E6%B6%88%E6%81%AF%E6%B5%8B%E9%87%8F%E6%8B%93%E6%89%91%E5%92%8C%E6%97%B6%E5%BB%B6">基于OpenFlow消息的网络测量方法</a>。</p><p>其在OpenFlow1.3中的消息格式如下图所示。<br><img src="/imgs/Introduction_to_OpenFlow/OpenFlow1.3%E4%B8%ADPacket-In%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F.png" srcset="/img/loading.gif" alt="OpenFlow1.3中Packet-In消息格式"></p><ul><li>buffer_id：若该字段为-1，表明交换机未缓存数据包，Packet-In消息需要携带完整数据包发送至控制器；否则，表明数据包已在交换机上缓存，Packet-In消息只携带部分数据包上传至控制器。</li></ul><h3 id="Packet-Out消息"><a href="#Packet-Out消息" class="headerlink" title="Packet-Out消息"></a>Packet-Out消息</h3><p>Packet-Out消息用于指定交换机将数据包从指定端口转发出去。触发该消息的情况有两种：1.转发Packet-In消息携带的数据包 2.转发控制器主动构造的数据包（如用于链路发现的LLDP报文）。此外，由于该消息能够携带自定义数据包，控制器通过在Packet-Out消息中封装探测包并下发至指定交换机，就能够发起主动测量任务，配合Packet-In消息可实现对网络拓扑与链路时延的测量，详情参考<a href="https://chentingz.github.io/2020/02/12/%E5%9F%BA%E4%BA%8EOpenFlow%E6%B6%88%E6%81%AF%E7%9A%84%E7%BD%91%E7%BB%9C%E6%B5%8B%E9%87%8F%E6%96%B9%E6%B3%95/#0x03-%E5%9F%BA%E4%BA%8Eopenflow%E7%9A%84packet-out%E6%B6%88%E6%81%AF%E5%92%8Cpacket-in%E6%B6%88%E6%81%AF%E6%B5%8B%E9%87%8F%E6%8B%93%E6%89%91%E5%92%8C%E6%97%B6%E5%BB%B6">基于OpenFlow消息的网络测量方法</a>。</p><p>其在OpenFlow1.3中的消息格式如下图所示。<br><img src="/imgs/Introduction_to_OpenFlow/OpenFlow1.3%E4%B8%ADPacket-Out%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F.png" srcset="/img/loading.gif" alt="OpenFlow1.3中Packet-Out消息格式"></p><ul><li>buffer_id：若该字段为-1，表明交换机未缓存数据包，Packet-Out消息携带控制器创建的数据包发送至交换机；否则，Packet-Out消息表示交换机需要将本地缓存的数据包按照Packet-Out中的actions进行处理。</li></ul><h3 id="Port-Stats消息"><a href="#Port-Stats消息" class="headerlink" title="Port-Stats消息"></a>Port-Stats消息</h3><p>Port-Stats消息是统计消息（以Stats结尾的消息）的一种，用于控制器查询交换机的端口计数器，从而获取端口的统计信息（如端口接收/发送字节数、接收/发送数据包个数等）。此外，它还能用来测量丢包率和吞吐量，详情参考<a href="https://chentingz.github.io/2020/02/12/%E5%9F%BA%E4%BA%8EOpenFlow%E6%B6%88%E6%81%AF%E7%9A%84%E7%BD%91%E7%BB%9C%E6%B5%8B%E9%87%8F%E6%96%B9%E6%B3%95/#0x02-%E5%9F%BA%E4%BA%8Eopenflow%E7%9A%84port-stats%E6%B6%88%E6%81%AF%E6%B5%8B%E9%87%8F%E4%B8%A2%E5%8C%85%E7%8E%87%E5%92%8C%E5%90%9E%E5%90%90%E9%87%8F">基于OpenFlow消息的网络测量方法</a>。</p><p>该消息具体有两种，一种是Port-Stats-Request消息，用于SDN控制器请求交换机端口统计信息，另一种是Port-Stats-Reply消息，交换机用它来应答SDN控制器，它们在OpenFlow1.3版本中的消息格式如下图所示。</p><p><img src="/imgs/Introduction_to_OpenFlow/OpenFlow1.3%E4%B8%ADPort-Stats-Request%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F.png" srcset="/img/loading.gif" alt="OpenFlow1.3中Port-Stats-Request消息格式"></p><p><img src="/imgs/Introduction_to_OpenFlow/OpenFlow1.3%E4%B8%ADPort-Stats-Reply%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F.png" srcset="/img/loading.gif" alt="OpenFlow1.3中Port-Stats-Reply消息格式"></p><h2 id="0x0A-参考"><a href="#0x0A-参考" class="headerlink" title="0x0A 参考"></a>0x0A 参考</h2><ul><li><a href="https://www.opennetworking.org/wp-content/uploads/2014/10/openflow-switch-v1.5.1.pdf" target="_blank" rel="noopener">openflow-switch-v1.5.1</a></li><li><a href="https://www.opennetworking.org/wp-content/uploads/2014/10/openflow-spec-v1.3.0.pdf" target="_blank" rel="noopener">openflow-switch-v1.3.0</a></li><li><a href="https://book.douban.com/subject/26715562/" target="_blank" rel="noopener">图解OpenFlow</a></li><li><a href="https://www.sdnlab.com/resource/11950.html" target="_blank" rel="noopener">openflow协议基础入门-北邮-张健男</a></li><li><a href="http://www.h3c.com/cn/d_201811/1131080_30005_0.htm" target="_blank" rel="noopener">Openflow协议详解</a></li><li><a href="https://book.douban.com/subject/27004668/" target="_blank" rel="noopener">重构网络：SDN架构与实现</a></li><li><a href="https://book.douban.com/subject/34462937/" target="_blank" rel="noopener">深度剖析软件定义网络(SDN)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>SDN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「OpenFlow」流表项删除DELETE与DELETE_STRICT的区别</title>
    <link href="/2019/12/27/%E3%80%8COpenFlow%E3%80%8D%E6%B5%81%E8%A1%A8%E9%A1%B9%E5%88%A0%E9%99%A4DELETE%E4%B8%8EDELETE_STRICT%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2019/12/27/%E3%80%8COpenFlow%E3%80%8D%E6%B5%81%E8%A1%A8%E9%A1%B9%E5%88%A0%E9%99%A4DELETE%E4%B8%8EDELETE_STRICT%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-目录"><a href="#0x00-目录" class="headerlink" title="0x00 目录"></a>0x00 目录</h2><ul><li><a href="#0x00-目录">0x00 目录</a></li><li><a href="#0x01-流表项操作与flow_mod消息">0x01 流表项操作与Flow_Mod消息</a></li><li><a href="#0x02-流表项删除delete与delete_strict区别">0x02 流表项删除DELETE与DELETE_STRICT区别</a></li><li><a href="#0x03-pox--mininet实验验证">0x03 POX + Mininet实验验证</a><ul><li><a href="#实验环境">实验环境</a></li><li><a href="#实验步骤">实验步骤</a><ul><li><a href="#1启动pox">1.启动POX</a></li><li><a href="#2运行mininet">2.运行Mininet</a></li><li><a href="#3添加两条流表项">3.添加两条流表项</a></li><li><a href="#4delete删除流表项">4.DELETE删除流表项</a></li><li><a href="#5添加两条流表项">5.添加两条流表项</a></li><li><a href="#6delete_strict删除流表项">6.DELETE_STRICT删除流表项</a></li></ul></li></ul></li><li><a href="#0x04-总结">0x04 总结</a></li><li><a href="#0x05-参考">0x05 参考</a><a id="more"></a></li></ul><h2 id="0x01-流表项操作与Flow-Mod消息"><a href="#0x01-流表项操作与Flow-Mod消息" class="headerlink" title="0x01 流表项操作与Flow_Mod消息"></a>0x01 流表项操作与Flow_Mod消息</h2><p>在OpenFlow中，对流表项的操作，例如增加、修改、删除流表项，都是通过控制器下发Flow_Mod消息完成的。Flow_Mod消息的格式如图所示，其中command字段定义了对流表项的操作（增加、修改、删除），而对于修改和删除操作又分为NON_STRICT和STRICT两个版本。</p><p><img src="/imgs/Difference_Between_Delete_And_Delete_Strict_In_Openflow_Flow_Mod/Flow_Mod%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F.png" srcset="/img/loading.gif" alt="Flow_Mod消息格式"></p><p><img src="/imgs/Difference_Between_Delete_And_Delete_Strict_In_Openflow_Flow_Mod/Flow_Mod%E6%B6%88%E6%81%AFcommand%E5%AD%97%E6%AE%B5.png" srcset="/img/loading.gif" alt="Flow_Mod消息command字段"></p><h2 id="0x02-流表项删除DELETE与DELETE-STRICT区别"><a href="#0x02-流表项删除DELETE与DELETE-STRICT区别" class="headerlink" title="0x02 流表项删除DELETE与DELETE_STRICT区别"></a>0x02 流表项删除DELETE与DELETE_STRICT区别</h2><p>要想删除流表项，只需要构造command = DELETE或command = DELETE_STRICT的Flow_Mod消息即可，两者的区别如下：</p><ul><li>DELETE：根据<strong>匹配域</strong>，删除所有匹配的流表项，意味着<strong>可能有多条流表项被删除</strong></li><li>DELETE_STRICT：根据<strong>匹配域以及优先级</strong>，删除特定的流表项，<strong>只有一条流表项被删除</strong></li></ul><p>例子：假设使用openflow1.0，且openflow交换机流表中只有以下两条流表项</p><pre><code>flow entry1:{   prioirity : 42   match :   {      dl_type : 0x0800      ip_src : 10.0.0.1      ip_dst : 10.0.0.2   }   actions : output : &#39;sw1-eth2&#39;}flow entry2:{   prioirity : 42   match :   {      dl_type : 0x0800      ip_src : 10.0.0.1      ip_dst : 10.0.0.2      ip_protocol : 6      tp_dst : 80   }   actions : output : &#39;sw1-eth2&#39;}</code></pre><ul><li><p>若控制器下发command = DELETE的Flow_Mod消息</p><pre><code>flow_mod msg:{ command : DELETE prioirity : 42 match : {    dl_type : 0x0800    ip_src : 10.0.0.1    ip_dst : 10.0.0.2 } actions : output : &#39;sw1-eth2&#39;}</code></pre><p>那么openflow交换机将会根据Flow_Mod消息中的<strong>匹配域（match）</strong>去流表中查找所有匹配的流表项（若流表项中的匹配域描述比Flow_Mod消息中的匹配域更详细，也算查找成功），这里flow entry1和flow entry2都满足，因为它们都含有</p><pre><code>match :{ dl_type : 0x0800 ip_src : 10.0.0.1 ip_dst : 10.0.0.2}</code></pre><p>因此，两条流表项都会被删除</p></li><li><p>若控制器下发command = DELETE_STRICT的Flow_Mod消息</p></li></ul><pre><code>flow_mod msg:{   command : DELETE_STRICT   prioirity : 42   match :   {      dl_type : 0x0800      ip_src : 10.0.0.1      ip_dst : 10.0.0.2   }   actions : output : &#39;sw1-eth2&#39;}</code></pre><p>openflow交换机会根据Flow_Mod消息中的<strong>匹配域（match）和优先级（prioirity）</strong>去流表中查找特定的流表项，这里只有flow entry1满足条件，因为flow entry2的匹配域多了两个字段</p><pre><code>ip_protocol : 6tp_dst : 80</code></pre><p>因此只有flow entry1被删除</p><h2 id="0x03-POX-Mininet实验验证"><a href="#0x03-POX-Mininet实验验证" class="headerlink" title="0x03 POX + Mininet实验验证"></a>0x03 POX + Mininet实验验证</h2><p>按照0x02中提到的例子，使用POX和Mininet进行验证</p><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><pre><code>- OpenFlow 1.0 : SDN控制器与openflow交换机之间通信的协议- POX-eel : python实现的SDN控制器，用于构造Flow_Mod消息，并下发至openflow交换机- Mininet 2.3.0d1 : 创建&quot; h1 -- sw1 -- h2 &quot;拓扑- POX与Mininet均部署在同一台运行ubuntu 18.04 LTS的机器上</code></pre><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="1-启动POX"><a href="#1-启动POX" class="headerlink" title="1.启动POX"></a>1.启动POX</h4><p>打开终端，输入</p><pre><code>home/ctz/pox-eel/pox.py openflow.of_01 --address=127.0.0.1 --port=6653 py- home/ctz/pox-eel/pox.py : POX程序的入口- openflow.of_01 : POX的组件，使用openflow1.0进行通信- address : openflow.of_01的参数，定义POX控制器的IP地址，这里定义为本地回环- port : openflow.of_01的参数，定义POX控制器的监听端口，用于监听openflow交换机发来的消息- py：使用POX交互模式，可在终端与POX控制器进行交互，例如构造Flow_Mod消息并发送给交换机</code></pre><p><img src="/imgs/Difference_Between_Delete_And_Delete_Strict_In_Openflow_Flow_Mod/%E5%90%AF%E5%8A%A8POX.png" srcset="/img/loading.gif" alt="启动POX"></p><h4 id="2-运行Mininet"><a href="#2-运行Mininet" class="headerlink" title="2.运行Mininet"></a>2.运行Mininet</h4><p>另开一终端，输入</p><pre><code>sudo mn --controller=remote,ip=127.0.0.1,port=6653 --mac- controller=remote : mininet连接远程控制器- ip : controller的参数，定义要连接的远程控制器IP地址- port : controller的参数，定义要连接的远程控制器端口- --mac : 从00:00:00:00:00:01开始，按递增序为主机设置MAC地址</code></pre><p><img src="/imgs/Difference_Between_Delete_And_Delete_Strict_In_Openflow_Flow_Mod/%E8%BF%90%E8%A1%8CMininet.png" srcset="/img/loading.gif" alt="运行Mininet"></p><h4 id="3-添加两条流表项"><a href="#3-添加两条流表项" class="headerlink" title="3.添加两条流表项"></a>3.添加两条流表项</h4><p>在运行POX的终端上，构造两条Flow_Mod消息，用于添加两条流表项到交换机</p><pre><code># 以下三条命令在POX控制器同openflow交换机连接上后只需要输入一次import pox.openflow.libopenflow_01 as offrom pox.lib.addresses import IPAddrcore.openflow.connections.keys()    # 获取连接的交换机dpid，会在终端上显示dpid# 下发一条流表项（h1 -&gt; h2 基于源目IP）msg = of.ofp_flow_mod()msg.priority = 42msg.command = of.OFPFC_ADDmsg.match.dl_type = 0x800msg.match.nw_src = IPAddr(&quot;10.0.0.1&quot;)msg.match.nw_dst = IPAddr(&quot;10.0.0.2&quot;)msg.actions.append(of.ofp_action_output(port = 2))core.openflow.connections[1].send(msg)    # 1为交换机的dpid# 下发一条流表项（h1 -&gt; h2 基于源目IP和TCP目的端口号）msg = of.ofp_flow_mod()msg.priority = 42msg.command = of.OFPFC_ADDmsg.match.dl_type = 0x800msg.match.nw_src = IPAddr(&quot;10.0.0.1&quot;)msg.match.nw_dst = IPAddr(&quot;10.0.0.2&quot;)msg.match.nw_proto = 6msg.match.tp_dst = 80msg.actions.append(of.ofp_action_output(port = 2))core.openflow.connections[1].send(msg)    # 1为交换机的dpid</code></pre><p>在运行Mininet的终端中输入</p><pre><code>dpctl dump-flows</code></pre><p>显示交换机中流表信息</p><p><img src="/imgs/Difference_Between_Delete_And_Delete_Strict_In_Openflow_Flow_Mod/%E6%B7%BB%E5%8A%A0%E4%B8%A4%E6%9D%A1%E6%B5%81%E8%A1%A8%E9%A1%B9.png" srcset="/img/loading.gif" alt="添加两条流表项"></p><h4 id="4-DELETE删除流表项"><a href="#4-DELETE删除流表项" class="headerlink" title="4.DELETE删除流表项"></a>4.DELETE删除流表项</h4><p>在运行POX的终端上，构造一条command = DELETE的Flow_Mod消息，删除所有匹配的流表项</p><pre><code># 删除所有匹配流表项（h1 -&gt; h2 基于源目IP）msg = of.ofp_flow_mod()msg.priority = 42msg.command = of.OFPFC_DELETEmsg.match.dl_type = 0x800msg.match.nw_src = IPAddr(&quot;10.0.0.1&quot;)msg.match.nw_dst = IPAddr(&quot;10.0.0.2&quot;)msg.actions.append(of.ofp_action_output(port = 2))core.openflow.connections[1].send(msg)    # 1为交换机的dpid</code></pre><p>如下图所示，交换机根据Flow_Mod消息的match字段查找流表项，所有流表项均被删除</p><p><img src="/imgs/Difference_Between_Delete_And_Delete_Strict_In_Openflow_Flow_Mod/DELETE%E5%88%A0%E9%99%A4%E6%B5%81%E8%A1%A8%E9%A1%B9.png" srcset="/img/loading.gif" alt="DELETE删除流表项"></p><h4 id="5-添加两条流表项"><a href="#5-添加两条流表项" class="headerlink" title="5.添加两条流表项"></a>5.添加两条流表项</h4><p>按照步骤3，重新添加两条流表项</p><h4 id="6-DELETE-STRICT删除流表项"><a href="#6-DELETE-STRICT删除流表项" class="headerlink" title="6.DELETE_STRICT删除流表项"></a>6.DELETE_STRICT删除流表项</h4><p>在运行POX的终端上，构造一条command = DELETE_STRICT的Flow_Mod消息，删除指定流表项</p><pre><code># 删除所有匹配流表项（h1 -&gt; h2 基于源目IP）msg = of.ofp_flow_mod()msg.priority = 42msg.command = of.OFPFC_DELETE_STRICTmsg.match.dl_type = 0x800msg.match.nw_src = IPAddr(&quot;10.0.0.1&quot;)msg.match.nw_dst = IPAddr(&quot;10.0.0.2&quot;)msg.actions.append(of.ofp_action_output(port = 2))core.openflow.connections[1].send(msg)    # 1为交换机的dpid</code></pre><p>如下图所示，交换机根据Flow_Mod消息的match字段和priority字段查找流表项，匹配域中含有端口号的流表项被保留，匹配域中不含端口号的流表项被删除</p><p><img src="/imgs/Difference_Between_Delete_And_Delete_Strict_In_Openflow_Flow_Mod/DELETE_STRICT%E5%88%A0%E9%99%A4%E6%B5%81%E8%A1%A8%E9%A1%B9.png" srcset="/img/loading.gif" alt="DELETE_STRICT删除流表项"></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>使用Flow_Mod删除流表项时，command = </p><ul><li><p>DELETE：删除所有匹配的流表项，只要流表项中Match字段描述 &gt;= Flow_Mod消息中的Match字段（如流表项中Match:{in_port:1,ip_src:10.0.0.1}，Flow_Mod消息中Match:{in_port:1}），则相关流表项均会被删除，因此被删除的流表项可能有多个</p></li><li><p>DELETE_STRICT：删除特定的流表项，只有同时满足Flow_Mod消息中匹配域以及优先级的流表项会被删除，被删除的流表项只有一个</p></li></ul><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><ul><li><p><a href="https://my.oschina.net/u/2245781/blog/894159" target="_blank" rel="noopener">openflow控制器POX使用指南</a></p></li><li><p><a href="https://blog.csdn.net/qq_15437629/article/details/45919417?locationnum=5&fps=1" target="_blank" rel="noopener">SDN控制器之POX篇</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>SDN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「虚拟化」基于virsh实现虚拟机动态迁移</title>
    <link href="/2019/12/11/%E3%80%8C%E8%99%9A%E6%8B%9F%E5%8C%96%E3%80%8D%E5%9F%BA%E4%BA%8Evirsh%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8A%A8%E6%80%81%E8%BF%81%E7%A7%BB/"/>
    <url>/2019/12/11/%E3%80%8C%E8%99%9A%E6%8B%9F%E5%8C%96%E3%80%8D%E5%9F%BA%E4%BA%8Evirsh%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8A%A8%E6%80%81%E8%BF%81%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-目录"><a href="#0x00-目录" class="headerlink" title="0x00 目录"></a>0x00 目录</h2><ul><li><a href="#0x00-目录">0x00 目录</a></li><li><a href="#0x01-虚拟机迁移方式">0x01 虚拟机迁移方式</a><ul><li><a href="#静态迁移">静态迁移</a></li><li><a href="#动态迁移">动态迁移</a><ul><li><a href="#基于共享存储">基于共享存储</a></li><li><a href="#基于本地存储">基于本地存储</a></li></ul></li></ul></li><li><a href="#0x02-虚拟机管理工具">0x02 虚拟机管理工具</a></li><li><a href="#0x03-搭建kvm虚拟化环境">0x03 搭建KVM虚拟化环境</a></li><li><a href="#0x04-基于virsh实现虚拟机动态迁移">0x04 基于virsh实现虚拟机动态迁移</a><ul><li><a href="#实验环境">实验环境</a></li><li><a href="#scp拷贝磁盘文件">SCP拷贝磁盘文件</a></li><li><a href="#virsh动态迁移内存状态">virsh动态迁移内存状态</a></li><li><a href="#virsh导出配置文件">virsh导出配置文件</a></li><li><a href="#virsh定义并创建虚拟机">virsh定义并创建虚拟机</a></li></ul></li><li><a href="#0x05-参考">0x05 参考</a></li></ul><a id="more"></a><h2 id="0x01-虚拟机迁移方式"><a href="#0x01-虚拟机迁移方式" class="headerlink" title="0x01 虚拟机迁移方式"></a>0x01 虚拟机迁移方式</h2><p>虚拟机迁移一般指虚拟机从一台物理机上迁移到另一台物理机上，迁移的内容包括虚拟机的<strong>磁盘文件、配置文件和内存状态</strong>。<br>从迁移方式上可分为两种：静态迁移和动态迁移。</p><h3 id="静态迁移"><a href="#静态迁移" class="headerlink" title="静态迁移"></a>静态迁移</h3><p>这种方式又称为离线迁移或线下迁移，指的是虚拟机需要在<strong>关机</strong>的前提下，完成迁移操作。<br>迁移的过程分为两个阶段：</p><p>1.从源物理机上拷贝虚拟机的<strong>磁盘文件、配置文件</strong>至目的物理机上，可以使用SCP命令完成拷贝工作</p><p>2.在目的物理机上，根据拷贝的磁盘文件及配置文件，定义并创建虚拟机</p><h3 id="动态迁移"><a href="#动态迁移" class="headerlink" title="动态迁移"></a>动态迁移</h3><p>这种方式也成为热迁移、在线迁移、线上迁移等，总之就是指虚拟机在<strong>运行</strong>的情况下，完成从源物理机迁移至目的物理机，在这过程中虚拟机只经历一个很短暂的暂停（虚拟机从源物理机上切换到目的物理机上），用户几乎感受不到服务的中断</p><p>根据磁盘文件的存储位置，又可分为以下两类：</p><ul><li><p>基于共享存储</p></li><li><p>基于本地存储（块存储）</p></li></ul><h4 id="基于共享存储"><a href="#基于共享存储" class="headerlink" title="基于共享存储"></a>基于共享存储</h4><p>源物理机与目的物理机拥有共享的存储设备，虚拟机的磁盘文件可以被源物理机和目的物理机所访问，因此无需迁移。迁移的过程如下：</p><p>1.从源物理机上迁移<strong>虚拟机的内存状态</strong>到目的物理机</p><pre><code>注：迁移结束后，虚拟机就已经在目的物理机上运行了，但是由于目的物理机上无该虚拟机配置文件，若此时关闭虚拟机，就无法找到该虚拟机了，所以需要完成接下来的操作</code></pre><p>2.在目的物理机上，根据迁移的内存状态导出虚拟机的配置文件</p><p>3.在目的物理机上，根据导出的虚拟机配置文件，定义并创建虚拟机</p><h4 id="基于本地存储"><a href="#基于本地存储" class="headerlink" title="基于本地存储"></a>基于本地存储</h4><p>源物理机与目的物理机都使用独立的存储设备，因此迁移的内容包括<strong>虚拟机的磁盘文件、内存状态以及配置文件</strong>（从内存状态中导出），迁移的过程如下：</p><p>1.从源物理机上拷贝<strong>磁盘文件</strong>到目的物理机</p><pre><code>例如：使用SCP命令，同时要使用相同的目录结构放置虚拟机磁盘文件</code></pre><p>2.从物理机上迁移<strong>内存状态</strong>到目的物理机</p><pre><code>例如：使用virsh migrate --live命令，或直接使用virt-manager图形化界面上的迁移操作</code></pre><pre><code>注：迁移结束后，虚拟机就已经在目的物理机上运行了，但是由于目的物理机上无该虚拟机配置文件，若此时关闭虚拟机，就无法找到该虚拟机了，所以需要完成接下来的操作</code></pre><p>3.在目的物理机上，根据迁移的内存状态导出虚拟机的配置文件</p><p>4.在目的物理机上，根据导出的虚拟机配置文件，定义并创建虚拟机</p><h2 id="0x02-虚拟机管理工具"><a href="#0x02-虚拟机管理工具" class="headerlink" title="0x02 虚拟机管理工具"></a>0x02 虚拟机管理工具</h2><ul><li>libvirt：用于实现虚拟机管理的开源API，可以实现对虚拟机的创建、删除、分配资源等</li><li>virt-manager：基于libvirt实现的虚拟机管理工具，图形化界面，类似VMware Workstation和VirtualBox</li><li>virsh：基于libvirt实现的虚拟机管理工具，命令行</li></ul><h2 id="0x03-搭建KVM虚拟化环境"><a href="#0x03-搭建KVM虚拟化环境" class="headerlink" title="0x03 搭建KVM虚拟化环境"></a>0x03 搭建KVM虚拟化环境</h2><ol><li><p>查看CPU是否支持KVM</p><pre><code>egrep &quot;(svm|vmx)&quot; /proc/cpuinfo</code></pre><p>如果有输出，则说明CPU支持KVM</p></li><li><p>安装KVM及相关依赖包</p><pre><code>sudo apt-get install qemu-kvmsudo apt-get install qemusudo apt-get install virt-managersudo apt-get install virt-viewer sudo apt-get install libvirt-bin sudo apt-get install bridge-utils</code></pre></li><li><p>启动KVM虚拟系统管理器</p><pre><code>sudo virt-manager</code></pre></li></ol><h2 id="0x04-基于virsh实现虚拟机动态迁移"><a href="#0x04-基于virsh实现虚拟机动态迁移" class="headerlink" title="0x04 基于virsh实现虚拟机动态迁移"></a>0x04 基于virsh实现虚拟机动态迁移</h2><p>这里采用基于本地存储的动态迁移方式，实现在物理机1上的虚拟机VM1动态迁移到物理机2上。</p><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><pre><code>名称        主机名      IP地址              操作系统          源物理机    kvm-node1   192.168.111.130     ubuntu-16.04.4-desktop目的物理机  kvm-node2   192.168.111.132     ubuntu-16.04.4-desktop虚拟机      VM1         192.168.122.18      ubuntu-16.04.3-server</code></pre><h3 id="SCP拷贝磁盘文件"><a href="#SCP拷贝磁盘文件" class="headerlink" title="SCP拷贝磁盘文件"></a>SCP拷贝磁盘文件</h3><p>在源物理机上使用SCP命令拷贝磁盘文件至目的物理机上</p><pre><code>sudo scp /var/lib/libvirt/images/node.qcow2 192.168.200.132:/var/lib/libvirt/images</code></pre><ul><li>/var/lib/libvirt/images：存放虚拟机磁盘文件的目录</li><li>node.qcow2：虚拟机VM1的磁盘文件</li><li>192.168.200.132：目的物理机IP地址</li><li>注1：磁盘文件拷贝到目的物理机上后，要存放在相同的目录结构中</li><li>注2：192.168.200.132前若不加用户名，则默认以root身份访问。若<a href="mailto:kvm@192.168.200.132" target="_blank" rel="noopener">kvm@192.168.200.132</a>，则以kvm身份访问</li></ul><p><img src="/imgs/ji_yu_virtsh_de_xu_ni_ji_dong_tai_qian_yi/scp%E6%8B%B7%E8%B4%9D%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6.png" srcset="/img/loading.gif" alt="scp拷贝磁盘文件"></p><p><img src="/imgs/ji_yu_virtsh_de_xu_ni_ji_dong_tai_qian_yi/%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E6%88%90%E5%8A%9F%E6%8B%B7%E8%B4%9D%E8%87%B3%E7%9B%AE%E7%9A%84%E7%89%A9%E7%90%86%E6%9C%BA.png" srcset="/img/loading.gif" alt="磁盘文件成功拷贝至目的物理机"></p><h3 id="virsh动态迁移内存状态"><a href="#virsh动态迁移内存状态" class="headerlink" title="virsh动态迁移内存状态"></a>virsh动态迁移内存状态</h3><p>在源物理机上使用virsh命令迁移虚拟机内存状态至目的物理机上</p><pre><code>sudo virsh migrate --live --verbose VM1 qemu+ssh://192.168.200.131/system tcp://192.168.200.131 --unsafe</code></pre><ul><li>virsh migrate –live：动态迁移</li><li>–verbose：显示迁移详情</li><li>VM1：需要迁移的虚拟机</li><li>qemu+ssh：通过ssh连接到目的物理机上的system实例，具有最大权限来管理远程节点上的虚拟机资源</li><li>/system： 以root身份进行状态迁移</li><li>tcp：使用tcp连接</li><li>192.168.200.131：目的物理机IP地址</li><li>–unsafe：跳过安全检测</li><li>注：可以指定身份访问远程主机，如远程主机用户名为kvm，则可以使用 <code>qemu+ssh://kvm@192.168.200.131/system</code>，若不添加kvm，默认使用root访问</li></ul><p><img src="/imgs/ji_yu_virtsh_de_xu_ni_ji_dong_tai_qian_yi/VM1%E8%BF%81%E7%A7%BB%E5%89%8D%E6%BA%90%E7%89%A9%E7%90%86%E6%9C%BA%E7%8A%B6%E6%80%81.png" srcset="/img/loading.gif" alt="VM1迁移前源物理机状态"></p><p><img src="/imgs/ji_yu_virtsh_de_xu_ni_ji_dong_tai_qian_yi/VM1%E8%BF%81%E7%A7%BB%E5%90%8E%E6%BA%90%E7%89%A9%E7%90%86%E6%9C%BA%E7%8A%B6%E6%80%81.png" srcset="/img/loading.gif" alt="VM1迁移后源物理机状态"></p><p>在目的物理机上，查看虚拟机状态</p><pre><code>sudo virsh list --all</code></pre><p>可见，虚拟机VM1已经迁移成功并且在目的物理机上运行</p><p><img src="/imgs/ji_yu_virtsh_de_xu_ni_ji_dong_tai_qian_yi/%E7%9B%AE%E7%9A%84%E7%89%A9%E7%90%86%E6%9C%BA%E4%B8%8A%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%8A%B6%E6%80%81.png" srcset="/img/loading.gif" alt="迁移到目的物理机上的VM1已处于运行状态"></p><h3 id="virsh导出配置文件"><a href="#virsh导出配置文件" class="headerlink" title="virsh导出配置文件"></a>virsh导出配置文件</h3><p>在目的物理机上，根据内存状态导出虚拟机VM1配置文件，否则迁移后远程主机没有虚拟机VM1的配置文件，关闭VM1后，VM1就没有了</p><pre><code>sudo virsh dumpxml VM1 &gt; /etc/libvirt/qemu/VM1.xml</code></pre><h3 id="virsh定义并创建虚拟机"><a href="#virsh定义并创建虚拟机" class="headerlink" title="virsh定义并创建虚拟机"></a>virsh定义并创建虚拟机</h3><p>根据VM1的配置文件定义并创建虚拟机</p><pre><code>sudo virsh define /etc/libvirt/qemu/VM1.xml</code></pre><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><ul><li><p><a href="https://blog.csdn.net/leoe_/article/details/78740088" target="_blank" rel="noopener">Virsh 虚拟机迁移</a></p></li><li><p><a href="https://www.cnblogs.com/zhy128/p/8042801.html" target="_blank" rel="noopener">虚拟机迁移（QEMU动态迁移，Libvirt动（静）态迁移）</a></p></li><li><p><a href="https://www.cnblogs.com/ccskun/p/5527014.html" target="_blank" rel="noopener">Ubuntu 16.04 搭建KVM环境</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>虚拟化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于LSB算法实现信息隐藏</title>
    <link href="/2019/11/23/%E5%9F%BA%E4%BA%8ELSB%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F/"/>
    <url>/2019/11/23/%E5%9F%BA%E4%BA%8ELSB%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-目录"><a href="#0x00-目录" class="headerlink" title="0x00 目录"></a>0x00 目录</h2><ul><li><a href="#0x00-目录">0x00 目录</a></li><li><a href="#0x01-问题描述">0x01 问题描述</a></li><li><a href="#0x02-lsb算法原理">0x02 LSB算法原理</a></li><li><a href="#0x03-lsb算法实现">0x03 LSB算法实现</a></li><li><a href="#0x04-实验结果分析">0x04 实验结果分析</a><ul><li><a href="#实验数据">实验数据</a></li><li><a href="#实验结果">实验结果</a></li></ul></li><li><a href="#0x05-健壮性分析">0x05 健壮性分析</a></li><li><a href="#0x06-关键代码">0x06 关键代码</a><ul><li><a href="#秘密信息嵌入">秘密信息嵌入</a></li><li><a href="#秘密信息提取">秘密信息提取</a></li><li><a href="#加噪处理">加噪处理</a><a id="more"></a></li></ul></li></ul><h2 id="0x01-问题描述"><a href="#0x01-问题描述" class="headerlink" title="0x01 问题描述"></a>0x01 问题描述</h2><p>基于LSB算法实现在320x240的灰度图像上隐藏秘密信息，并分析LSB算法的健壮性（抗攻击）。</p><h2 id="0x02-LSB算法原理"><a href="#0x02-LSB算法原理" class="headerlink" title="0x02 LSB算法原理"></a>0x02 LSB算法原理</h2><p>该算法包含秘密信息嵌入和提取两部分。嵌入：将二进制表示的秘密信息中的每一位，按照某种顺序（例如先按列再按行，如图1所示）依次存储在载体图像像素值的最低位上。提取：按照嵌入时的顺序依次从嵌有秘密信息的载体图像上提取像素值的最低位，将其组合后即可得到秘密信息。</p><p><img src="/imgs/Info_Hiding_Using_LSB_Algorithm/LSB%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86.png" srcset="/img/loading.gif" alt="图1 LSB算法原理"></p><h2 id="0x03-LSB算法实现"><a href="#0x03-LSB算法实现" class="headerlink" title="0x03 LSB算法实现"></a>0x03 LSB算法实现</h2><p>使用Python编码实现基于LSB算法的秘密信息嵌入与提取。秘密信息嵌入算法如图2所示，秘密信息提取算法如图3所示。LSB算法完整代码：<a href="https://github.com/Chentingz/LSB-Steganography" target="_blank" rel="noopener">https://github.com/Chentingz/LSB-Steganography</a></p><p><img src="/imgs/Info_Hiding_Using_LSB_Algorithm/%E7%A7%98%E5%AF%86%E4%BF%A1%E6%81%AF%E5%B5%8C%E5%85%A5%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png" srcset="/img/loading.gif" alt="图2 秘密信息嵌入算法流程图"><br><img src="/imgs/Info_Hiding_Using_LSB_Algorithm/%E7%A7%98%E5%AF%86%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png" srcset="/img/loading.gif" alt="图3 秘密信息提取算法流程图"></p><h2 id="0x04-实验结果分析"><a href="#0x04-实验结果分析" class="headerlink" title="0x04 实验结果分析"></a>0x04 实验结果分析</h2><h3 id="实验数据"><a href="#实验数据" class="headerlink" title="实验数据"></a>实验数据</h3><ul><li>秘密信息：”secret text is hidden in image using LSB algorithm\n2019.11.21”</li><li>原始载体图像名：raw_img.bmp</li><li>原始载体图像大小：320 x 240</li><li>原始载体图像通道数：单通道（灰度图像）</li><li>原始载体图像：见图4</li></ul><p><img src="/imgs/Info_Hiding_Using_LSB_Algorithm/raw_img.bmp" srcset="/img/loading.gif" alt="图4 原始载体图像"></p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><ul><li>嵌入算法：按照图2的算法从文件中读取秘密信息后嵌入到原始载体图像中，从图5可见，嵌入前后的载体图像无明显变化。</li></ul><p><img src="/imgs/Info_Hiding_Using_LSB_Algorithm/%E5%B5%8C%E5%85%A5%E7%A7%98%E5%AF%86%E4%BF%A1%E6%81%AF%E5%89%8D%E5%90%8E%E7%9A%84%E8%BD%BD%E4%BD%93%E5%9B%BE%E5%83%8F%E5%AF%B9%E6%AF%94.png" srcset="/img/loading.gif" alt="图5 嵌入秘密信息前后的载体图像对比"></p><ul><li>提取算法：按照图3算法对嵌入秘密信息的载体图像提取出秘密信息，由图6可见，提取结果与嵌入前的秘密信息一致。</li></ul><p><img src="/imgs/Info_Hiding_Using_LSB_Algorithm/%E7%A7%98%E5%AF%86%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96%E7%BB%93%E6%9E%9C.png" srcset="/img/loading.gif" alt="图6 秘密信息提取结果"></p><h2 id="0x05-健壮性分析"><a href="#0x05-健壮性分析" class="headerlink" title="0x05 健壮性分析"></a>0x05 健壮性分析</h2><p>对嵌有秘密信息的载体图像分别采用高斯噪声和椒盐噪声处理，然后提取秘密信息，观察秘密信息是否遭到破坏，噪声处理前后的图像对比如图7所示。</p><p><img src="/imgs/Info_Hiding_Using_LSB_Algorithm/%E5%99%AA%E5%A3%B0%E5%A4%84%E7%90%86%E5%89%8D%E5%90%8E%E7%9A%84%E8%BD%BD%E4%BD%93%E5%9B%BE%E5%83%8F%E5%AF%B9%E6%AF%94.png" srcset="/img/loading.gif" alt="图7 噪声处理前后的载体图像对比"></p><p>采用图3中的提取算法，分别对高斯噪声和椒盐噪声处理过的图像提取信息，提取结果如图8所示，可见对基于LSB嵌入秘密信息的图像进行噪声处理后，秘密信息将遭到不同程度的破坏，LSB算法抗攻击性差。</p><p><img src="/imgs/Info_Hiding_Using_LSB_Algorithm/%E5%99%AA%E5%A3%B0%E5%A4%84%E7%90%86%E5%90%8E%E7%9A%84%E5%9B%BE%E5%83%8F%E7%A7%98%E5%AF%86%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96%E7%BB%93%E6%9E%9C.png" srcset="/img/loading.gif" alt="图8 噪声处理后的图像秘密信息提取结果"></p><h2 id="0x06-关键代码"><a href="#0x06-关键代码" class="headerlink" title="0x06 关键代码"></a>0x06 关键代码</h2><h3 id="秘密信息嵌入"><a href="#秘密信息嵌入" class="headerlink" title="秘密信息嵌入"></a>秘密信息嵌入</h3><pre><code class="python">from PIL import Imageeof_str = &quot;00000000&quot;&quot;&quot;&quot;将秘密信息嵌入到载体图像中首先将秘密信息转换成二进制字符串，如&quot;a&quot; -&gt; &quot;0110 0001&quot;在二进制字符串的末尾添加两个0x0000的ASCII码作为结束标志，如&quot;0110 0001&quot; -&gt; &quot;0110 0001 0000 0000 0000 0000&quot;按照图像从上到下，从左到右的顺序，将串的每一位依次插入到像素的最低位中，每一个像素用一个字节表示@param text: string类型的秘密信息@param raw_img: image类型原始载体图像@return: image类型嵌入秘密信息后的图像&quot;&quot;&quot;def insert_text_to_image(text, raw_img):    mod_img = raw_img.copy()    width = mod_img.size[0]    height = mod_img.size[1]    binstr = text2binarystring(text)    binstr += eof_str + eof_str    i = 0    for w in range(width):        for h in range(height):            if i == len(binstr):                break            value = mod_img.getpixel((w,h))            value = mod_lsb(value, binstr[i])            mod_img.putpixel((w,h), value)            i=i+1    return mod_img&quot;&quot;&quot;将秘密信息转换成二进制串先将字符转换成对应的ASCII码，然后转二进制，最后8位对齐，不足的前面用0填充@param text: string类型表示的秘密信息@return: string类型表示的二进制串&quot;&quot;&quot;def text2binarystring(text):    binstr = &quot;&quot;    for ch in text :        # ord(ch): 将ch转换成十进制数 bin():转换成0b开头的二进制字符串 zfill:返回指定长度字符串，不足的前面填充0        binstr += bin(ord(ch)).replace(&#39;0b&#39;, &#39;&#39;).zfill(8)    return binstr&quot;&quot;&quot;将value的最低位替换成bit,返回修改后的value@param value: int类型表示的像素值@param bit: string类型表示的嵌入位@return: int类型表示的修改后的像素值&quot;&quot;&quot;def mod_lsb(value, bit):    str = bin(value).replace(&#39;0b&#39;, &#39;&#39;).zfill(8)    lsb = str[len(str)-1]    if lsb != bit :        str = str[0:len(str)-1] + bit    return int(str, 2)</code></pre><h3 id="秘密信息提取"><a href="#秘密信息提取" class="headerlink" title="秘密信息提取"></a>秘密信息提取</h3><pre><code class="python">from PIL import Imageeof = chr(int(eof_str, 2))&quot;&quot;&quot;从图像中提取秘密信息，返回string类型的秘密信息@param mod_img: 嵌入秘密信息后的图像@return: string类型表示的秘密信息&quot;&quot;&quot;def get_text_from_image(mod_img):    width = mod_img.size[0]    height = mod_img.size[1]    bytestr = &quot;&quot;    text = &quot;&quot;    countEOF = 0    for w in range(width):        for h in range(height):            value = mod_img.getpixel((w,h))            bytestr += get_lsb(value)            if len(bytestr) == 8 :                # 转换成ASCII码                # 例：&quot;0110 0001&quot; -&gt; 97 -&gt; &#39;a&#39;                ch = chr(int(bytestr, 2))                if ch == eof :                    countEOF = countEOF + 1                if countEOF == 2 :                    break                text += ch                bytestr = &quot;&quot;    return text&quot;&quot;&quot;返回像素值的lsb@param value: int类型表示的像素值@return: string类型表示的像素值最低位&quot;&quot;&quot;def get_lsb(value):    str = bin(value).replace(&#39;0b&#39;, &#39;&#39;).zfill(8)    lsb = str[len(str)-1]    return lsb</code></pre><h3 id="加噪处理"><a href="#加噪处理" class="headerlink" title="加噪处理"></a>加噪处理</h3><pre><code class="python">import cv2import matplotlib.pyplot as pltimport skimage.util as skiimport LSBfrom PIL import Imagemod_img_path = &quot;./test/mod_img.bmp&quot;img_gaussian_path = &quot;./test/img_gaussian.bmp&quot;img_sp_path = &quot;./test/img_sp.bmp&quot;img_mod_and_noises_compare_path = &quot;./test/img_mod_and_noises_compare.png&quot;&quot;&quot;&quot;对嵌有秘密信息的载体图像加噪处理，并保存&quot;&quot;&quot;def noise():    mod_img = cv2.imread(mod_img_path, cv2.IMREAD_GRAYSCALE)    img_copy = mod_img.copy()    # 高斯噪声处理后的嵌有秘密信息的载体图像    img_gaussian = ski.random_noise(img_copy, mode=&quot;gaussian&quot;, seed=None, clip=True, mean=0,var=0.05)    img_gaussian *= 255    # 椒盐噪声处理后的嵌有秘密信息的载体图像    img_sp = ski.random_noise(img_copy, mode=&quot;s&amp;p&quot;, seed=None, clip=True, amount=0.1)    img_sp *= 255    # 保存加噪后的图像    cv2.imwrite(img_gaussian_path, img_gaussian)    cv2.imwrite(img_sp_path, img_sp)    # 构造对比图    plt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;]  # 中文字体设置    plt.rcParams[&#39;axes.unicode_minus&#39;] = False    plt.subplot(131)    plt.title(&quot;嵌有秘密信息的载体图像&quot;)    plt.imshow(mod_img,cmap=&#39;gray&#39;)    plt.subplot(132)    plt.title(&quot;高斯噪声处理后图像&quot;)    plt.imshow(img_gaussian, cmap=&#39;gray&#39;)    plt.subplot(133)    plt.title(&quot;椒盐噪声处理后的图像&quot;)    plt.imshow(img_sp,cmap=&#39;gray&#39;)    # 保存对比图    plt.savefig(img_compare_path)    # 显示对比图    plt.show()</code></pre>]]></content>
    
    
    <categories>
      
      <category>Security</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「Floodlight x Mininet」从0开始搭建环境</title>
    <link href="/2019/11/01/%E3%80%8CFloodlight%20x%20Mininet%E3%80%8D%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/"/>
    <url>/2019/11/01/%E3%80%8CFloodlight%20x%20Mininet%E3%80%8D%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>Floodlight是我在学习SDN过程中最早接触的控制器，相比较于ODL和ONOS，它从安装到导入IDE再到使用都十分容易，官方文档也写的很清楚，对新手极其友好。<br>趁着最近给别人搭建SDN实验环境的机会，总结一下在Ubuntu上如何搭建一个Floodlight x Mininet的SDN环境。</p><a id="more"></a><h2 id="0x01-目录"><a href="#0x01-目录" class="headerlink" title="0x01 目录"></a>0x01 目录</h2><ul><li><a href="#0x00-前言">0x00 前言</a></li><li><a href="#0x01-目录">0x01 目录</a></li><li><a href="#0x02-前期准备">0x02 前期准备</a><ul><li><a href="#git安装">Git安装</a></li><li><a href="#jdk安装">JDK安装</a></li><li><a href="#apache-ant安装">Apache Ant安装</a></li></ul></li><li><a href="#0x03-floodlight安装">0x03 Floodlight安装</a><ul><li><a href="#源码下载">源码下载</a></li><li><a href="#源码编译">源码编译</a></li><li><a href="#参考">参考</a></li></ul></li><li><a href="#0x04-mininet安装">0x04 Mininet安装</a><ul><li><a href="#源码下载-1">源码下载</a></li><li><a href="#安装">安装</a></li><li><a href="#测试">测试</a></li><li><a href="#参考-1">参考</a></li></ul></li><li><a href="#0x05-测试环境">0x05 测试环境</a><ul><li><a href="#运行floodlight">运行Floodlight</a></li><li><a href="#运行mininet">运行Mininet</a></li><li><a href="#测试floodlight和mininet的连通性">测试Floodlight和Mininet的连通性</a></li><li><a href="#参考-2">参考</a></li></ul></li><li><a href="#0x06-在eclipse中运行floodlight">0x06 在Eclipse中运行Floodlight</a><ul><li><a href="#下载eclipse">下载Eclipse</a></li><li><a href="#安装eclipse">安装Eclipse</a></li><li><a href="#运行eclipse">运行Eclipse</a></li><li><a href="#导入floodlight源码">导入Floodlight源码</a></li><li><a href="#配置启动项">配置启动项</a></li><li><a href="#运行floodlight-1">运行Floodlight</a></li><li><a href="#参考-3">参考</a></li></ul></li></ul><h2 id="0x02-前期准备"><a href="#0x02-前期准备" class="headerlink" title="0x02 前期准备"></a>0x02 前期准备</h2><ul><li>Git</li><li>JDK</li><li>Apache Ant</li></ul><h3 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h3><pre><code>sudo apt-get install git</code></pre><h3 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h3><p>Floodlight v1.2以后使用JDK8，这里选择Oracle的JDK8进行下载，在网上找到Oracle JDK8的linux压缩包进行下载并解压到home目录下，然后配置环境变量</p><pre><code># 配置环境变量sudo gedit ~/.bashrc# 在.bashrc文件末尾添加下面的内容，JAVA_HOME填JDK目录所在路径export JAVA_HOME=/home/ubuntu/jdk1.8.0_141export PATH=${JAVA_HOME}/bin:$PATH# 查看配置是否成功，若显示java的版本，则配置成功java -version</code></pre><p><img src="/imgs/Floodlight_x_Mininet_Environment_Setup_Tutorial/%E6%A3%80%E6%9F%A5JDK%E6%98%AF%E5%90%A6%E6%88%90%E5%8A%9F%E5%AE%89%E8%A3%85.png" srcset="/img/loading.gif" alt="检查JDK是否成功安装"><br>参考：<a href="https://blog.csdn.net/EahanZhang/article/details/88085561" target="_blank" rel="noopener">https://blog.csdn.net/EahanZhang/article/details/88085561</a>  </p><h3 id="Apache-Ant安装"><a href="#Apache-Ant安装" class="headerlink" title="Apache Ant安装"></a>Apache Ant安装</h3><pre><code>sudo apt-get install ant</code></pre><h2 id="0x03-Floodlight安装"><a href="#0x03-Floodlight安装" class="headerlink" title="0x03 Floodlight安装"></a>0x03 Floodlight安装</h2><h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><pre><code>git clone git://github.com/floodlight/floodlight.git</code></pre><h3 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h3><pre><code>cd floodlightant</code></pre><p>显示Build Successful，则说明编译成功</p><p><img src="/imgs/Floodlight_x_Mininet_Environment_Setup_Tutorial/Floodlight%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91.png" srcset="/img/loading.gif" alt="Floodlight源码编译"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://floodlight.atlassian.net/wiki/spaces/floodlightcontroller/pages/1343544/Installation+Guide#InstallationGuide-Linux" target="_blank" rel="noopener">https://floodlight.atlassian.net/wiki/spaces/floodlightcontroller/pages/1343544/Installation+Guide#InstallationGuide-Linux</a></p><h2 id="0x04-Mininet安装"><a href="#0x04-Mininet安装" class="headerlink" title="0x04 Mininet安装"></a>0x04 Mininet安装</h2><h3 id="源码下载-1"><a href="#源码下载-1" class="headerlink" title="源码下载"></a>源码下载</h3><pre><code>git clone git://github.com/mininet/mininet</code></pre><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>cd mininet/util/sudo ./install.sh</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code>sudo mn --test pingall</code></pre><p><img src="/imgs/Floodlight_x_Mininet_Environment_Setup_Tutorial/%E6%B5%8B%E8%AF%95Minine%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png" srcset="/img/loading.gif" alt="测试Minine是否安装成功">  </p><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><p><a href="http://mininet.org/download/" target="_blank" rel="noopener">http://mininet.org/download/</a>  </p><h2 id="0x05-测试环境"><a href="#0x05-测试环境" class="headerlink" title="0x05 测试环境"></a>0x05 测试环境</h2><h3 id="运行Floodlight"><a href="#运行Floodlight" class="headerlink" title="运行Floodlight"></a>运行Floodlight</h3><pre><code>java -jar target/floodlight.jar# 该命令要在floodlight目录下运行</code></pre><p><img src="/imgs/Floodlight_x_Mininet_Environment_Setup_Tutorial/%E8%BF%90%E8%A1%8CFloodlight.png" srcset="/img/loading.gif" alt="运行Floodlight"></p><h3 id="运行Mininet"><a href="#运行Mininet" class="headerlink" title="运行Mininet"></a>运行Mininet</h3><p>新开终端，运行命令创建如下拓扑:</p><p><strong>h1 - sw1 - h2</strong></p><pre><code>sudo mn --controller=remote,ip=127.0.0.1 --mac --switch=ovsk,protocols=OpenFlow13# 如果Floodlight和Mininet分别部署在不同主机上，则上面的IP地址改为Floodlight所在主机的IP地址</code></pre><h3 id="测试Floodlight和Mininet的连通性"><a href="#测试Floodlight和Mininet的连通性" class="headerlink" title="测试Floodlight和Mininet的连通性"></a>测试Floodlight和Mininet的连通性</h3><p>在运行Mininet的终端上，输入</p><pre><code>pingall</code></pre><p>如果主机之间能够ping通，说明Floodlight与Mininet之间连通<br><img src="/imgs/Floodlight_x_Mininet_Environment_Setup_Tutorial/pingall%E6%B5%8B%E8%AF%95%E4%B8%BB%E6%9C%BA%E8%BF%9E%E9%80%9A%E6%80%A7.png" srcset="/img/loading.gif" alt="pingall测试主机连通性"></p><p>此时还可以在浏览器中打开Floodlight Web GUI进行验证，若显示交换机、主机个数、拓扑，也能说明Floodlight与Mininet之间成功连通<br><a href="http://localhost:8080/ui/pages/index.html" target="_blank" rel="noopener">http://localhost:8080/ui/pages/index.html</a><br><img src="/imgs/Floodlight_x_Mininet_Environment_Setup_Tutorial/Floodlight_Web_GUI_%E9%AA%8C%E8%AF%81FL%E5%92%8CMininet%E4%B9%8B%E9%97%B4%E8%BF%9E%E9%80%9A%E6%80%A7.png" srcset="/img/loading.gif" alt="Floodlight_Web_GUI_验证FL和Mininet之间连通性"></p><p><img src="/imgs/Floodlight_x_Mininet_Environment_Setup_Tutorial/Floodlight_Web_GUI_%E9%AA%8C%E8%AF%81FL%E4%B8%8EMininet%E4%B9%8B%E9%97%B4%E8%BF%9E%E9%80%9A%E6%80%A7-2.png" srcset="/img/loading.gif" alt="Floodlight_Web_GUI_验证FL与Mininet之间连通性-2"></p><h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><p><a href="https://floodlight.atlassian.net/wiki/spaces/floodlightcontroller/pages/1343544/Installation+Guide#InstallationGuide-SimulatingANetwork" target="_blank" rel="noopener">https://floodlight.atlassian.net/wiki/spaces/floodlightcontroller/pages/1343544/Installation+Guide#InstallationGuide-SimulatingANetwork</a></p><h2 id="0x06-在Eclipse中运行Floodlight"><a href="#0x06-在Eclipse中运行Floodlight" class="headerlink" title="0x06 在Eclipse中运行Floodlight"></a>0x06 在Eclipse中运行Floodlight</h2><h3 id="下载Eclipse"><a href="#下载Eclipse" class="headerlink" title="下载Eclipse"></a>下载Eclipse</h3><p><img src="/imgs/Floodlight_x_Mininet_Environment_Setup_Tutorial/%E4%B8%8B%E8%BD%BDEclipse.png" srcset="/img/loading.gif" alt="下载Eclipse"></p><h3 id="安装Eclipse"><a href="#安装Eclipse" class="headerlink" title="安装Eclipse"></a>安装Eclipse</h3><p><img src="/imgs/Floodlight_x_Mininet_Environment_Setup_Tutorial/%E8%A7%A3%E5%8E%8BEclipse.png" srcset="/img/loading.gif" alt="解压Eclipse"></p><p><img src="/imgs/Floodlight_x_Mininet_Environment_Setup_Tutorial/%E5%AE%89%E8%A3%85Eclipse-1.png" srcset="/img/loading.gif" alt="安装Eclipse-1"></p><p><img src="/imgs/Floodlight_x_Mininet_Environment_Setup_Tutorial/%E5%AE%89%E8%A3%85Eclipse-2.png" srcset="/img/loading.gif" alt="安装Eclipse-2"></p><p><img src="/imgs/Floodlight_x_Mininet_Environment_Setup_Tutorial/%E5%AE%89%E8%A3%85Eclipse-3.png" srcset="/img/loading.gif" alt="安装Eclipse-3"></p><h3 id="运行Eclipse"><a href="#运行Eclipse" class="headerlink" title="运行Eclipse"></a>运行Eclipse</h3><p><img src="/imgs/Floodlight_x_Mininet_Environment_Setup_Tutorial/%E8%BF%90%E8%A1%8CEclipse.png" srcset="/img/loading.gif" alt="运行Eclipse"></p><h3 id="导入Floodlight源码"><a href="#导入Floodlight源码" class="headerlink" title="导入Floodlight源码"></a>导入Floodlight源码</h3><p><img src="/imgs/Floodlight_x_Mininet_Environment_Setup_Tutorial/%E5%AF%BC%E5%85%A5Floodlight%E6%BA%90%E7%A0%81-1.png" srcset="/img/loading.gif" alt="导入Floodlight源码-1"></p><p><img src="/imgs/Floodlight_x_Mininet_Environment_Setup_Tutorial/%E5%AF%BC%E5%85%A5Floodlight%E6%BA%90%E7%A0%81-2.png" srcset="/img/loading.gif" alt="导入Floodlight源码-2"></p><h3 id="配置启动项"><a href="#配置启动项" class="headerlink" title="配置启动项"></a>配置启动项</h3><p><img src="/imgs/Floodlight_x_Mininet_Environment_Setup_Tutorial/%E9%85%8D%E7%BD%AE%E5%90%AF%E5%8A%A8%E9%A1%B9-1.png" srcset="/img/loading.gif" alt="配置启动项-1"></p><p><img src="/imgs/Floodlight_x_Mininet_Environment_Setup_Tutorial/%E9%85%8D%E7%BD%AE%E5%90%AF%E5%8A%A8%E9%A1%B9-2.png" srcset="/img/loading.gif" alt="配置启动项-2"></p><h3 id="运行Floodlight-1"><a href="#运行Floodlight-1" class="headerlink" title="运行Floodlight"></a>运行Floodlight</h3><p><img src="/imgs/Floodlight_x_Mininet_Environment_Setup_Tutorial/%E5%9C%A8Eclipse%E4%B8%8A%E8%BF%90%E8%A1%8CFloodlight.png" srcset="/img/loading.gif" alt="在Eclipse上运行Floodlight"></p><h3 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h3><p><a href="https://floodlight.atlassian.net/wiki/spaces/floodlightcontroller/pages/1343544/Installation+Guide#InstallationGuide-EclipseIDE" target="_blank" rel="noopener">https://floodlight.atlassian.net/wiki/spaces/floodlightcontroller/pages/1343544/Installation+Guide#InstallationGuide-EclipseIDE</a></p>]]></content>
    
    
    <categories>
      
      <category>SDN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「ONOS x Mininet」从0开始搭建环境</title>
    <link href="/2019/10/28/%E3%80%8CONOS%20x%20Mininet%E3%80%8D%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/"/>
    <url>/2019/10/28/%E3%80%8CONOS%20x%20Mininet%E3%80%8D%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>这篇教程是基于ONOS Wiki上教程写的，Wiki上写的还是比较清楚的，但在实践过程中还是踩了一些坑，为了总结写下了这篇教程。<br>本教程的环境搭建是在分配有<strong>4核CPU、8G内存、运行ubuntu 18.04 desktop虚拟机</strong>上完成的。<br>建议搭建环境的主机至少分配4G内存，如果你使用其他版本的ubuntu，本教程也是适用的。</p><a id="more"></a><h2 id="0x01-目录"><a href="#0x01-目录" class="headerlink" title="0x01 目录"></a>0x01 目录</h2><ul><li><a href="#0x00-前言">0x00 前言</a></li><li><a href="#0x01-目录">0x01 目录</a></li><li><a href="#0x02-前期准备">0x02 前期准备</a><ul><li><a href="#git安装">Git安装</a></li><li><a href="#jdk安装">JDK安装</a></li><li><a href="#bazel安装">Bazel安装</a></li></ul></li><li><a href="#0x03-onos安装">0x03 ONOS安装</a><ul><li><a href="#下载onos源码">下载ONOS源码</a></li><li><a href="#onos源码目录改名">ONOS源码目录改名</a></li><li><a href="#onos源码编译">ONOS源码编译</a></li><li><a href="#运行onos控制器">运行ONOS控制器</a></li><li><a href="#参考">参考</a></li></ul></li><li><a href="#0x04-mininet安装">0x04 Mininet安装</a><ul><li><a href="#源码下载">源码下载</a></li><li><a href="#安装">安装</a></li><li><a href="#测试">测试</a></li><li><a href="#参考-1">参考</a></li></ul></li><li><a href="#0x05-测试环境">0x05 测试环境</a><ul><li><a href="#运行onos">运行ONOS</a></li><li><a href="#运行onos-apps">运行ONOS Apps</a></li><li><a href="#运行mininet">运行Mininet</a></li><li><a href="#检查onos与mininet连通性">检查ONOS与Mininet连通性</a></li><li><a href="#测试主机之间的连通性">测试主机之间的连通性</a></li><li><a href="#参考-2">参考</a></li></ul></li><li><a href="#0x06-在intellij-idea中运行onos">0x06 在IntelliJ IDEA中运行ONOS</a><ul><li><a href="#下载intellij-idea">下载IntelliJ IDEA</a></li><li><a href="#运行intellij-idea">运行IntelliJ IDEA</a></li><li><a href="#安装bazel插件">安装Bazel插件</a></li><li><a href="#导入onos源码并编译">导入ONOS源码并编译</a></li><li><a href="#运行onos-1">运行ONOS</a></li><li><a href="#参考-3">参考</a></li></ul></li></ul><h2 id="0x02-前期准备"><a href="#0x02-前期准备" class="headerlink" title="0x02 前期准备"></a>0x02 前期准备</h2><ul><li>Git </li><li>JDK</li><li>Bazel  </li></ul><h3 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h3><pre><code>sudo apt-get install git</code></pre><h3 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h3><p>ONOS-2.2以后的版本都使用JDK11，这里选择OpenJDK-11进行安装</p><pre><code># 安装OpenJDK-11sudo apt-get install openjdk-11-jdk# 配置环境变量sudo gedit /etc/profile# 在profile文件末尾添加下面的内容export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH# 查看配置是否成功，若显示openjdk version，则配置成功java -version</code></pre><p>参考：<a href="https://blog.csdn.net/EahanZhang/article/details/88085561" target="_blank" rel="noopener">https://blog.csdn.net/EahanZhang/article/details/88085561</a>  </p><h3 id="Bazel安装"><a href="#Bazel安装" class="headerlink" title="Bazel安装"></a>Bazel安装</h3><p>Bazel是Google开发的用于编译的工具，在Github上选择<strong>bazel-0.27.1-installer-linux-x86_64.sh</strong> 进行下载<br><a href="https://github.com/bazelbuild/bazel/releases/tag/0.27.1" target="_blank" rel="noopener">https://github.com/bazelbuild/bazel/releases/tag/0.27.1</a></p><p><code>注：</code><br><code>在我搭建环境的时候，参考的是ONOS Wiki于2019/6/19发布的教程，里面使用的是Bazel 0.27.0。</code><br><a href="https://wiki.onosproject.org/pages/viewpage.action?pageId=28836246" target="_blank" rel="noopener">https://wiki.onosproject.org/pages/viewpage.action?pageId=28836246</a><br><code>我开始时使用了1.0.0但发现编译失败，于是换成0.27.1，经过测试该版本有效。</code><br><code>1.0.0编译失败的问题已于2019/10/16被ONOS官方解决，因此你也可以选择安装最新版本的Bazel。</code><br><a href="https://github.com/opennetworkinglab/onos/commit/2bf24538098ce3d963d7cbe7da4dfbcfc69285e5" target="_blank" rel="noopener">https://github.com/opennetworkinglab/onos/commit/2bf24538098ce3d963d7cbe7da4dfbcfc69285e5</a></p><p>根据Bazel官网安装教程进行安装<br><a href="https://docs.bazel.build/versions/master/install-ubuntu.html#install-with-installer-ubuntu" target="_blank" rel="noopener">https://docs.bazel.build/versions/master/install-ubuntu.html#install-with-installer-ubuntu</a></p><h2 id="0x03-ONOS安装"><a href="#0x03-ONOS安装" class="headerlink" title="0x03 ONOS安装"></a>0x03 ONOS安装</h2><h3 id="下载ONOS源码"><a href="#下载ONOS源码" class="headerlink" title="下载ONOS源码"></a>下载ONOS源码</h3><p>有以下两种方式，选择一种即可</p><ul><li>Git命令下载<pre><code>git clone https://gerrit.onosproject.org/onos</code></pre></li><li>Github上下载<br><a href="https://github.com/opennetworkinglab/onos" target="_blank" rel="noopener">https://github.com/opennetworkinglab/onos</a></li></ul><p><img src="/imgs/ONOS_x_Mininet_Environment_Setup_Tutorial/Github%E4%B8%8A%E4%B8%8B%E8%BD%BDONOS%E6%BA%90%E7%A0%81.png" srcset="/img/loading.gif" alt="Github上下载ONOS源码">  </p><h3 id="ONOS源码目录改名"><a href="#ONOS源码目录改名" class="headerlink" title="ONOS源码目录改名"></a>ONOS源码目录改名</h3><p>若选择从Github上下载ZIP压缩包，解压缩后得到onos-master目录，将其改名为onos，方便后续操作</p><pre><code>mv onos-master onos</code></pre><h3 id="ONOS源码编译"><a href="#ONOS源码编译" class="headerlink" title="ONOS源码编译"></a>ONOS源码编译</h3><pre><code>cd onosbazel build onos</code></pre><p>当显示build success，说明编译成功  </p><p><img src="/imgs/ONOS_x_Mininet_Environment_Setup_Tutorial/ONOS%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E6%88%90%E5%8A%9F.png" srcset="/img/loading.gif" alt="ONOS源码编译成功"></p><p><code>注：由于网络原因，可能某些依赖下载不下来，导致编译失败，此时可以选择重新运行</code><br><code>bazel build onos，直到依赖下载成功</code></p><h3 id="运行ONOS控制器"><a href="#运行ONOS控制器" class="headerlink" title="运行ONOS控制器"></a>运行ONOS控制器</h3><pre><code>cd onosbazel run onos-local</code></pre><p><img src="/imgs/ONOS_x_Mininet_Environment_Setup_Tutorial/%E8%BF%90%E8%A1%8CONOS%E6%8E%A7%E5%88%B6%E5%99%A8.png" srcset="/img/loading.gif" alt="运行ONOS控制器"> </p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://wiki.onosproject.org/display/ONOS/Development+Environment+Setup" target="_blank" rel="noopener">https://wiki.onosproject.org/display/ONOS/Development+Environment+Setup</a>  </p><h2 id="0x04-Mininet安装"><a href="#0x04-Mininet安装" class="headerlink" title="0x04 Mininet安装"></a>0x04 Mininet安装</h2><h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><pre><code>git clone git://github.com/mininet/mininet</code></pre><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>cd mininet/util/sudo ./install.sh</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code>sudo mn --test pingall</code></pre><p><img src="/imgs/ONOS_x_Mininet_Environment_Setup_Tutorial/mininet%E6%B5%8B%E8%AF%95%E8%BF%9E%E9%80%9A%E6%80%A7.png" srcset="/img/loading.gif" alt="mininet测试连通性">  </p><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><p><a href="http://mininet.org/download/" target="_blank" rel="noopener">http://mininet.org/download/</a>  </p><h2 id="0x05-测试环境"><a href="#0x05-测试环境" class="headerlink" title="0x05 测试环境"></a>0x05 测试环境</h2><p>这里ONOS和Mininet都部署在同一台主机中进行测试，当然你也可以选择分别部署在不同主机上。</p><h3 id="运行ONOS"><a href="#运行ONOS" class="headerlink" title="运行ONOS"></a>运行ONOS</h3><pre><code>cd onosbazel run onos-local# 若想要删除ONOS上一次运行时产生的状态信息，则输入：# bazel run onos-local -- clean</code></pre><p><code>注：</code><br><code>1.运行ONOS之前，ONOS需要监听的端口号6653和6633有可能被其他进程占用，因此可以先检查一下端口使用情况：</code><br><code>sudo netstat -atnp | grep 6653</code><br><code>sudo netstat -atnp | grep 6633</code><br><code>若除java进程外，有其他进程占用端口号6653或6633，例如：ovs-testcontrol，则杀死进程：</code><br><code>sudo kill -9 &lt;进程号&gt;</code><br><code>2.ONOS启动后，最好等待窗口中不再弹出INFO信息后，再运行Mininet</code></p><p><img src="/imgs/ONOS_x_Mininet_Environment_Setup_Tutorial/ONOS%E5%90%AF%E5%8A%A8%E5%90%8E%E7%AD%89%E5%BE%85INFO%E6%B6%88%E6%81%AF%E4%B8%8D%E5%86%8D%E5%BC%B9%E5%87%BA.png" srcset="/img/loading.gif" alt="ONOS启动后等待INFO消息不再弹出">  </p><h3 id="运行ONOS-Apps"><a href="#运行ONOS-Apps" class="headerlink" title="运行ONOS Apps"></a>运行ONOS Apps</h3><p>ONOS开启后，默认不运行<strong>Reactive Forwarding</strong>和<strong>Basic Pipelines</strong>应用程序，这样的话ONOS就无法处理2层和3层的转发，Mininet中主机之间无法ping通。因此在运行Mininet前，先运行这两个应用程序。下面介绍两种方法，选择其中一种即可</p><ul><li><p>ONOS Web GUI</p><p>浏览器中打开ONOS Web GUI <a href="http://localhost:8181/onos/ui/" target="_blank" rel="noopener">http://localhost:8181/onos/ui/</a><br>输入用户名：onos 密码：rocks<br>打开应用程序选项卡  </p></li></ul><p><img src="/imgs/ONOS_x_Mininet_Environment_Setup_Tutorial/ONOS_WEB_GUI_%E6%89%93%E5%BC%80%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%80%89%E9%A1%B9%E5%8D%A1.png" srcset="/img/loading.gif" alt="ONOS_WEB_GUI_打开应用程序选项卡">  </p><p>运行Basic Pipelines和Reactive Forwarding应用程序</p><p><img src="/imgs/ONOS_x_Mininet_Environment_Setup_Tutorial/ONOS_WEB_GUI_%E5%BC%80%E5%90%AFAPP.png" srcset="/img/loading.gif" alt="ONOS_WEB_GUI_开启APP">  </p><ul><li><p>ONOS CLI</p><p>新开终端，输入</p><pre><code>onos/tools/test/bin/onos localhost</code></pre><p>打开ONOS命令行界面</p><p><img src="/imgs/ONOS_x_Mininet_Environment_Setup_Tutorial/%E8%BF%90%E8%A1%8CONOS_CLI.png" srcset="/img/loading.gif" alt="运行ONOS_CLI"></p><p>输入命令运行Basic Pipelines和Reactive Forwarding应用程序</p><pre><code>app activate org.onosproject.pipelines.basicapp activate org.onosproject.fwd</code></pre><p><code>注：</code><br><code>Basic Pipelines对应的应用程序ID为org.onosproject.pipelines.basic</code><br><code>Reactive Forwarding对应的ID为org.onosproject.fwd</code></p><p> <img src="/imgs/ONOS_x_Mininet_Environment_Setup_Tutorial/ONOS_CLI%E8%BF%90%E8%A1%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F.png" srcset="/img/loading.gif" alt="ONOS_CLI运行应用程序"></p></li></ul><h3 id="运行Mininet"><a href="#运行Mininet" class="headerlink" title="运行Mininet"></a>运行Mininet</h3><p>新开终端，运行命令创建如下拓扑:</p><p><strong>h1 - sw1 - h2</strong></p><pre><code>sudo mn --controller=remote,ip=127.0.0.1 --mac --switch=ovsk,protocols=OpenFlow13# 如果ONOS和Mininet分别部署在不同主机上，则上面的IP地址改为ONOS所在主机的IP地址</code></pre><h3 id="检查ONOS与Mininet连通性"><a href="#检查ONOS与Mininet连通性" class="headerlink" title="检查ONOS与Mininet连通性"></a>检查ONOS与Mininet连通性</h3><p>下面介绍两种判断ONOS与Mininet是否连通的方法</p><ul><li><p>若拓扑中显示设备，说明ONOS和Mininet中的交换机成功连接<br><img src="/imgs/ONOS_x_Mininet_Environment_Setup_Tutorial/ONOS_WEB_GUI%E6%89%93%E5%BC%80%E6%8B%93%E6%89%91%E9%80%89%E9%A1%B9%E5%8D%A1.png" srcset="/img/loading.gif" alt="ONOS_WEB_GUI打开拓扑选项卡"></p></li><li><p>若ONOS与Mininet连通，运行ONOS的终端会显示下面的INFO信息<br><img src="/imgs/ONOS_x_Mininet_Environment_Setup_Tutorial/ONOS%E4%B8%8EMininet%E6%88%90%E5%8A%9F%E8%BF%9E%E6%8E%A5%E6%97%B6%E5%BA%94%E6%9C%89%E7%9A%84INFO%E6%B6%88%E6%81%AF.png" srcset="/img/loading.gif" alt="ONOS与Mininet成功连接时应有的INFO消息"><br><img src="/imgs/ONOS_x_Mininet_Environment_Setup_Tutorial/ONOS%E4%B8%8EMininet%E6%88%90%E5%8A%9F%E8%BF%9E%E6%8E%A5%E6%97%B6%E5%BA%94%E6%9C%89%E7%9A%84INFO%E6%B6%88%E6%81%AF-2.png" srcset="/img/loading.gif" alt="ONOS与Mininet成功连接时应有的INFO消息-2"></p></li></ul><h3 id="测试主机之间的连通性"><a href="#测试主机之间的连通性" class="headerlink" title="测试主机之间的连通性"></a>测试主机之间的连通性</h3><p>在运行Mininet的终端上，输入</p><pre><code>pingall</code></pre><p><img src="/imgs/ONOS_x_Mininet_Environment_Setup_Tutorial/pingall%E6%B5%8B%E8%AF%95%E8%BF%9E%E9%80%9A%E6%80%A7.png" srcset="/img/loading.gif" alt="pingall测试连通性"></p><h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><p><a href="https://wiki.onosproject.org/display/ONOS/Basic+ONOS+Tutorial#BasicONOSTutorial-Setupyourenvironment" target="_blank" rel="noopener">https://wiki.onosproject.org/display/ONOS/Basic+ONOS+Tutorial#BasicONOSTutorial-Setupyourenvironment</a></p><h2 id="0x06-在IntelliJ-IDEA中运行ONOS"><a href="#0x06-在IntelliJ-IDEA中运行ONOS" class="headerlink" title="0x06 在IntelliJ IDEA中运行ONOS"></a>0x06 在IntelliJ IDEA中运行ONOS</h2><h3 id="下载IntelliJ-IDEA"><a href="#下载IntelliJ-IDEA" class="headerlink" title="下载IntelliJ IDEA"></a>下载IntelliJ IDEA</h3><p><a href="https://www.jetbrains.com/idea/download/#section=linux" target="_blank" rel="noopener">https://www.jetbrains.com/idea/download/#section=linux</a>  </p><p><img src="/imgs/ONOS_x_Mininet_Environment_Setup_Tutorial/%E4%B8%8B%E8%BD%BDIDEA.png" srcset="/img/loading.gif" alt="下载IDEA">  </p><h3 id="运行IntelliJ-IDEA"><a href="#运行IntelliJ-IDEA" class="headerlink" title="运行IntelliJ IDEA"></a>运行IntelliJ IDEA</h3><p>解压缩IDEA后，cd到IDEA的bin目录，运行IDEA</p><pre><code>./idea.sh</code></pre><p><img src="/imgs/ONOS_x_Mininet_Environment_Setup_Tutorial/%E8%BF%90%E8%A1%8CIDEA.png" srcset="/img/loading.gif" alt="运行IDEA">   </p><h3 id="安装Bazel插件"><a href="#安装Bazel插件" class="headerlink" title="安装Bazel插件"></a>安装Bazel插件</h3><p><img src="/imgs/ONOS_x_Mininet_Environment_Setup_Tutorial/%E6%89%93%E5%BC%80IDEA%E6%8F%92%E4%BB%B6%E9%A1%B9.png" srcset="/img/loading.gif" alt="打开IDEA插件项"><br>然后搜索Bazel并安装  </p><h3 id="导入ONOS源码并编译"><a href="#导入ONOS源码并编译" class="headerlink" title="导入ONOS源码并编译"></a>导入ONOS源码并编译</h3><p>生成最小的.bazelproject文件</p><pre><code>cd onos/tools/dev/bin/./onos-gen-bazel-project &gt; /tmp/onos_bazelproject</code></pre><p><img src="/imgs/ONOS_x_Mininet_Environment_Setup_Tutorial/IDEA%E5%AF%BC%E5%85%A5ONOS%E6%BA%90%E7%A0%81-1.png" srcset="/img/loading.gif" alt="IDEA导入ONOS源码-1">  </p><p><img src="/imgs/ONOS_x_Mininet_Environment_Setup_Tutorial/IDEA%E5%AF%BC%E5%85%A5ONOS%E6%BA%90%E7%A0%81-2.png" srcset="/img/loading.gif" alt="IDEA导入ONOS源码-2">  </p><p><img src="/imgs/ONOS_x_Mininet_Environment_Setup_Tutorial/IDEA%E5%AF%BC%E5%85%A5ONOS%E6%BA%90%E7%A0%81-3.png" srcset="/img/loading.gif" alt="IDEA导入ONOS源码-3">  </p><p><img src="/imgs/ONOS_x_Mininet_Environment_Setup_Tutorial/IDEA%E5%AF%BC%E5%85%A5ONOS%E6%BA%90%E7%A0%81-4.png" srcset="/img/loading.gif" alt="IDEA导入ONOS源码-4">  </p><p>等待IDEA完成ONOS源码的编译  </p><h3 id="运行ONOS-1"><a href="#运行ONOS-1" class="headerlink" title="运行ONOS"></a>运行ONOS</h3><p><img src="/imgs/ONOS_x_Mininet_Environment_Setup_Tutorial/%E9%85%8D%E7%BD%AE%E8%BF%90%E8%A1%8CONOS%E5%91%BD%E4%BB%A4-1.png" srcset="/img/loading.gif" alt="配置运行ONOS命令-1">  </p><p><img src="/imgs/ONOS_x_Mininet_Environment_Setup_Tutorial/%E9%85%8D%E7%BD%AE%E8%BF%90%E8%A1%8CONOS%E5%91%BD%E4%BB%A4-2.png" srcset="/img/loading.gif" alt="配置运行ONOS命令-2">  </p><p><img src="/imgs/ONOS_x_Mininet_Environment_Setup_Tutorial/%E9%85%8D%E7%BD%AE%E8%BF%90%E8%A1%8CONOS%E5%91%BD%E4%BB%A4-3.png" srcset="/img/loading.gif" alt="配置运行ONOS命令-3">  </p><p><img src="/imgs/ONOS_x_Mininet_Environment_Setup_Tutorial/%E9%85%8D%E7%BD%AE%E8%BF%90%E8%A1%8CONOS%E5%91%BD%E4%BB%A4-4.png" srcset="/img/loading.gif" alt="配置运行ONOS命令-4">  </p><p><img src="/imgs/ONOS_x_Mininet_Environment_Setup_Tutorial/IDEA%E4%B8%AD%E8%BF%90%E8%A1%8CONOS-1.png" srcset="/img/loading.gif" alt="IDEA中运行ONOS-1">  </p><p><img src="/imgs/ONOS_x_Mininet_Environment_Setup_Tutorial/IDEA%E4%B8%AD%E8%BF%90%E8%A1%8CONOS-2.png" srcset="/img/loading.gif" alt="IDEA中运行ONOS-2">  </p><h3 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h3><p><a href="https://wiki.onosproject.org/pages/viewpage.action?pageId=28836246" target="_blank" rel="noopener">https://wiki.onosproject.org/pages/viewpage.action?pageId=28836246</a></p>]]></content>
    
    
    <categories>
      
      <category>SDN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/05/10/hello-world/"/>
    <url>/2019/05/10/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><a id="more"></a> <h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
