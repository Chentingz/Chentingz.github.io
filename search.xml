<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SDN网络测量方法]]></title>
    <url>%2F2021%2F03%2F06%2FSDN%E7%BD%91%E7%BB%9C%E6%B5%8B%E9%87%8F%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[[TOC] 0x00 前言SDN网络测量按照测量对象可分为网络状态测量、网络性能测量、网络流量参数测量三类[1]。网络状态包含网络链路的状态信息以及网络的拓扑结构，是网络的基本参数，对其进行测量的主要目的是监测网络运行时的相关指标和行为，及时地发现网络异常和故障，确保网络运行在正确状态；网络性能参数包括链路吞吐量、链路丢包率、链路时延等，该参数对测量的实时性要求较高，反应网络的瞬时运行状态；网络流量参数一般通过对一定周期内的网络流量进行采集分析获得，是一个统计参数，例如报文数量统计、流长统计等，对流量参数进行深入挖掘和分析可以发现网络中潜在的问题，是指导网络管理和安全工作的重要依据。 本文主要对现有的SDN网络状态以及网络性能测量的方法进行总结。 0x01 基于OpenFlow的被动测量方法OpenFlow交换机中定义了多种计数器，内容如表1所示，记录了每个端口、每个流表和每个流表项等不同结构的数据包数、字节数和持续时间等统计量。根据OpenFlow协议中定义的统计消息，控制器能够定期查询并获取交换机的计数器统计信息，用于测量丢包率、吞吐量等网络性能指标。 OpenFlow统计消息包含Port-Stats消息、Flow-Stats消息、Aggregate-Stats消息、Queue-Stats消息、Group-Stats消息、Meter-Stats消息和Table-Stats消息，这些消息可用于获取OpenFlow交换机中指定计数器的统计信息，如Port-Stats消息可以用于获取指定OpenFlow交换机物理端口的统计信息，Flow-Stats消息用于获取指定流表项的统计信息。 表1 OpenFlow 1.3中的计数器 类型 内容 比特数 每张流表 Per Flow Table 活跃表项 Active Entries 32 数据包查表次数 Packet Lookups 64 数据包匹配次数 Packet Matches 64 每条流表项 Per Flow Entry 接收数据包个数 Received Packets 64 接收数据包字节数 Received Bytes 64 生存时间（秒） Duration(seconds) 32 生存时间（纳秒） Duration(nanoseconds) 32 每个物理端口 Per Port 接收数据包个数 Received Packets 64 发送数据包个数 Transmitted Packets 64 接收字节数 Received Bytes 64 发送字节数 Transmitted Bytes 64 接收后丢弃的数据包个数 Receive Drops 64 发送时丢弃的数据包个数 Transmit Drops 64 接收出现的错误 Receive Errors 64 发送出现的错误 Transmit Errors 64 接收的帧排列错误 Receive Frame Alignment Errors 64 溢出错误 Receive Overrun Errors 64 CRC校验错误 Receive CRC Errors 64 帧冲突 Collisions 64 生存时间（秒） Duration (seconds) 32 生存时间（毫秒） Duration (nanoseconds) 32 每条队列 Per Queue 发送数据包个数 Transmit Packets 64 发送字节数 Transmit Bytes 64 溢出错误 Transmit Overrun Errors 64 生存时间（秒） Duration (seconds) 32 生存时间（毫秒） Duration (nanoseconds) 32 每张组表 Per Group 绑定的流表项个数 Flow Entries 32 匹配的数据包个数 Packet Count 64 匹配的字节数 Byte Count 64 生存时间（秒） Duration (seconds) 32 生存时间（毫秒） Duration (nanoseconds) 32 每个组表桶 Per Group Bucket 匹配的数据包个数 Packet Count 64 匹配的字节数 Byte Count 64 每张计量表 Per Meter 流个数 Flow Count 32 输入数据包个数 Input Packet Count 64 输入字节数 Input Byte Count 64 生存时间（秒） Duration (seconds) 32 每个计量表带 Per Meter Band 在计量表带中的数据包个数 In Band Packet Count 64 在计量表带中的字节数 In Band Byte Count 64 基于Port-Stats消息测量链路丢包率和吞吐量Hamad[2]等人提出利用Port-Stats消息来实现链路丢包率和链路吞吐量测量，Port-Stats消息具体有两种，一种是Port-Stats-Request消息，用于SDN控制器请求交换机端口统计信息，另一种是Port-Stats-Reply消息，交换机用它来应答SDN控制器，具体过程是交换机读取指定端口的计数器，获得端口的统计信息并将其封装在该消息中，然后将消息发送给SDN控制器。在OpenFlow 1.3中，Port-Stats-Request和Port-Stats-Reply消息格式分别如图1和图2所示，SDN控制器可以从Port-Stats-Reply消息中获取到交换机端口的接收/发送数据包个数（rx_packets/tx_packets），接收/发送字节数（rx_bytes/tx_bytes），丢弃数据包个数(rx_dropped/tx_dropped)，冲突次数（collisions），端口生存时间（duration_sec和duration_nsec）等统计信息，这些信息将用于计算链路丢包率、链路吞吐量。 图1 OpenFlow1.3中的Port-Stats-Request消息格式 图2 OpenFlow1.3中的Port-Stats-Reply消息格式 丢包率是指一段时间内，数据包丢失数与总发送数的比值。假设测量如图3所示网络拓扑中交换机S1到交换机S2方向的链路丢包率，SDN控制器需定期向交换机S1和S2发送Port-Stats-Request消息，来获取S1的1端口发送数据包个数tx\_packets_{s1}以及S2的2端口接收数据包个数rx\_packets_{s2}。通过每隔一段时间进行轮询，利用公式（1）可以计算得到S1到S2方向的链路在第(i-1)次和第i次查询时间段内的丢包率。 图3 基于OpenFlow的Port-Stats消息测量链路丢包率原理图 Loss(i-1,i)=1-\frac{ {rx\_packets_{s2(i)} }- {rx\_packets_{s2(i-1)} } }{ {tx\_packets_{s1(i)} }- {tx\_packets_{s1(i-1)} } } \tag {1}吞吐量是指单位时间内传输无差错数据总量。测量交换机链路吞吐量时，SDN控制器将周期性发送Port-Stats-Request消息到指定交换机，并从交换机的Port-Stats-Reply消息中获取接收/发送字节数（rx_bytes/tx_bytes）和端口生存时间（duration_sec和duration_nsec），利用公式（2）和（3）可以计算第(i-1)次和第i次查询时间段内的吞吐量大小。 Throughtput(i-1,i)= \frac{bytes_{i}-bytes_{(i-1)} }{duration_{i}-duration_{(i-1)} } \tag {2} duration = durtation\_sec+duration\_nsec*10^{-9} \tag {3}OpenNetMon：基于Flow-Stats消息测量流丢包率和吞吐量基于Port-Stats消息测量的丢包率和吞吐量是链路级别的，当需要测量更为细粒度的丢包率和吞吐量，如流级别时，基于Port-Stats消息的测量方法就无法适用。针对测量流级别的丢包率和吞吐量，Adrichem[3] 等人基于Flow-Stats消息在POX控制器上开发了OpenNetMon应用，该应用可以在SDN网络内对指定流的丢包率和吞吐量进行监控。 与Port-Stats测量链路丢包率和吞吐量方法类似，首先在固定的时间间隔内轮询交换机，通过发送如图4的Flow-Stats-Request消息采集流量统计信息，然后从如图5所示的Flow-Stats-Reply消息中提取流量统计信息中的字节数byte_count和包数packet_count来计算丢包率和吞吐量。高频率的轮询将产生高准确性的统计信息进而会提高测量精度。然而，这将在网络中引入显著的监控开销。为了在测量准确性和网络开销之间取得平衡，OpenNetMon提出了一种可变频率流量统计信息采集算法。 图4 OpenFlow1.3中的Flow-Stats-Request消息格式 图5 OpenFlow1.3中的Flow-Stats-Reply消息格式 当控制器收到一个Packet-In消息时，它将添加一个新的流表项到当前流表中，同时对轮询时间τ初始化。如果流在τ毫秒内过期，控制器将通过Flow-Removed消息中接收这条流的统计信息。否则，控制器将主动向相应的交换机发送一个Flow-Stats-Request消息来采集关于该流的统计信息。如果采集到这条流的统计信息在此时间段内没有显著变化，即该流的前一个字节计数和当前字节计数之间的差异没有超过阈值∆1，那么将该流的超时τ乘以一个小常数α的结果，与轮询时间最大值Tmax比较，较小者用于更新τ。如果新旧数据的差异大于另一个阈值∆2，则该流的轮询时间τ除以另一个常数β的结果，与轮询时间最小值Tmin比较，较大者用于更新τ。这种对轮询时间τ调整背后的逻辑是，对于有助于显著提高链路利用率的流量，保持较高的轮询频率，而对于当时对链路利用率没有显著贡献的流量，则保持较低的轮询频率。当它们的贡献增加时，轮询时间τ将根据算法进行自适应调整。 OpenTM：基于Flow-Stats消息测量流量矩阵流量矩阵(Traffic Matrix, TM)表示网络中每一对源宿节点之间的流量大小。许多网络管理和安全任务都建立在流量矩阵基础之上，如路由协议配置、负载均衡、异常检测等。 在SDN网络中，Tootoonchian[4]等人基于OpenFlow提供的Flow-Stats消息设计了流量矩阵测量系统OpenTM。OpenTM持续追踪SDN网络中所有的活跃流，然后从控制器的路由应用中获取这些流的传输路径，对传输路径上的交换机周期性发送Flow-Stats消息轮询交换机获取流字节数和包数。根据路由信息，OpenTM将具有相同源宿的流的统计信息进行累加从而构造流量矩阵。 此外，OpenTM还测试了多种查询策略以应对不同的使用场景，包括（1）查询路径上最后一台交换机，（2）均匀分布下随机选取路径上的交换机进行查询，（3）轮询，（4）非均匀分布下随机选取高概率且离目的地最近的交换机进行查询，（5）查询负载最小的交换机。实验结果表明，在不追求非常准确的测量结果时，以上5种策略都可以使用，其中最小负载查询策略在降低交换机负载上有着更为突出的优势。针对测量结果有高准确性要求的场景，策略4选择路径上离目的地最近的几个交换机则更为适用。 FlowSense：基于Packet-In和FlowRemoved消息测量链路吞吐量Yu[5] 等人针对SDN网络提出了一种基于推送的链路吞吐量测量方法，该方法利用了Packet-In消息和Flow-Removed消息，分别用于告知控制器一条新流的抵达以及一条流的结束，可用来计算交换机之间的链路吞吐量。相比于通过OpenFlow协议主动查询来测量吞吐量，该方法能够减少测量产生的开销。 当一条流表项过期时，交换机会生成如图6的Flow-Removed消息用于告知控制器。Flow-Removed消息会携带三个重要的信息，（1）流表项在流表中从创建到删除的生存时间（duration_sec和duration_nsec字段），（2）匹配该流表项的流的总量大小（byte_count和packet_count字段），（3）匹配该流表项的流进入交换机的端口号（match字段中的in_port）。这些信息将有助于推断对交换机输入端口所在链路吞吐量有贡献的流量大小。 图6 OpenFlow1.3中的Flow-Removed消息格式 FlowSense的基本思想是每当一条流表项过期触发Flow-Removed消息时，就对该流表项对应的链路创建一个检查点checkpoint，它表示流最后一次匹配流表项的时间，即流的实际活跃时间。如果一条流表项是因为在idle_timeout内没有流匹配而过期，那么checkpoint将设置为FlowRemoved消息生成的时间减去idle_timeout。如果一条流表项是因为表项生存时间hard_timeout过期，那么难以推测出流的实际活跃时间，FlowSense假设流在整个流表项生存期间都是活跃状态，于是将checkpoint设置为FlowRemoved消息生成的时间。 ​ 在每一个checkpoint，FlowSense都会测量流在该链路上的吞吐量，计算公式参考（4）。由于在同一时刻相同链路上可能存在多条活跃流，它们都会对链路吞吐量有贡献。为了准确测量出链路总吞吐量，借助Packet-In消息推测出这些活跃流的起始时间，结合Flow-Removed消息即可推断出流的实际活跃时间。由于需要等待所有的活跃流结束并触发Flow-Removed消息才能计算出总的链路吞吐量，因此在每个checkpoint的链路吞吐量需要经过一段时间才能完成最终的测量。 Throughtput_{f}=\frac{byte\_count}{duration\_sec+duration\_nsec*10^{-9} } \tag {4} 图7 FlowSense测量链路吞吐量示意图 图7展示了FlowSense测量链路吞吐量的过程。在这个例子中，流f1，f2，和f3的开始时间分别为t1，t2和 t3。t4，t5和 t6是这些流的结束时间。FlowSense根据Packet-In消息和Flow-Removed消息分别确定流的开始和结束时间。如果f1，f2，和f3的吞吐量分别为10、20和40MBps，那么当第一个Flow-Removed消息在t4生成时，FlowSense将通过Flow-Removed消息的字节数byte_count除以流的持续时间duration来计算f1的吞吐量，并且在t4创建一个检查点checkpoint。当t5的Flow-Removed消息到达时，流f3结束并且计算出它的吞吐量40MBps，然后将其添加到t4的检查点中，此时t4检查点中链路吞吐量为50MBps （f1和f3的吞吐量总和，计算公式参考（5））。最后，在t6，流f2结束，并且它的吞吐量计算后被添加到t4和t5的检查点，最终每个检查点中链路利用率为: t4为70 MBps, t5为60 MBps, t6为40 MBps。 Throughtput_{link} = \sum_{i=1}^{n}{Thourghtput_{f_{i} }} \tag {5}0x02 基于OpenFlow的主动测量方法SDN网络中主动测量方法的基本思想是SDN控制器生成探测数据包并下发至指定的交换机，当测量过程结束时，被测交换机需要触发相应机制将探测包返回控制器，由控制器分析并计算得到测量结果。由于SDN网络中交换机处理数据包的规则，即流表项，需要由控制器指定，因此实现主动测量的关键在于控制器如何生成和回收探测数据包，以及如何制定探测包的转发规则。 OpenFlow协议规定了控制器和交换机相互发送数据包的消息类型。由控制器发起的Controller-to-Switch消息类型中，包含一类Packet-Out消息，其格式如图8所示。控制器能够自定义该消息中携带的数据包内容，以及交换机收到Packet-Out消息后的行为。控制器通过在Packet-Out消息中封装探测数据包并下发至指定交换机，就能够发起主动测量任务。 图8 OpenFlow1.3中Packet-Out消息格式 在由交换机发起的Asynchronous消息类型中，包含Packet-In消息，其格式如图9所示，该消息与Packet-Out类似，可以封装交换机上的指定数据包并发送至控制器做进一步处理。当交换机中的流表项无法匹配某个数据包时，会默认触发Packet-In消息。由于探测数据包通常与网络中的正常流量有所不同，因此基于OpenFlow的SDN主动测量可以利用Packet-In消息机制实现探测包的回收。 图9 OpenFlow1.3中Packet-In消息格式 SLAM：基于Packet-Out和Packet-In消息测量时延交换机之间传输时延是表明链路运行状态的重要参数。由于OpenFlow交换机不具备在正常传输的报文中打时间戳的功能，无法采用传统IP网络中的被动测量方式。因此，需要利用主动测量思想，在交换机之间生成并发送探测包。 Yu [6]等人提出了基于Packet-Out和Packet-In消息实现在基于软件定义的数据中心网络测量时延，其具体原理如图10所示，假设控制器的测量目标是交换机S1到交换机S2的链路时延，则控制器将探测包发送至S1，并下发规则指定S1将探测包发送至S2。S2接收到探测包后，由于没有对应的转发规则，会将探测包返回控制器，控制器则会计算出探测包在路径中传输的总时间。由于控制器和交换机之间的通信也存在时延，因此控制器还需要发送通信消息，获得控制器和各个交换机之间的消息往返时间，通过计算差值，获得最终的链路时延结果。 图10 基于Packet-Out和Packet-In消息测量时延原理图 因此，测量S1到S2的链路时延的详细步骤如下： (1)获得探测包传输时间Ttravel：控制器生成探测数据包，其中包含交换机S1的目标转发端口（S1的1端口）和生成探测数据包时的时间戳，用来记录探测包的转发路径和发送探测包的时间。然后，控制器通过Packet-Out消息封装探测数据包，并下发至交换机S1，并从指定端口将探测包转发至S2。S2接收到数据包后，由于没有匹配的流表项，会触发Packet-In消息，将探测包封装并返回控制器。控制器根据探测包中时间戳以及收到探测包的时间计算出探测包在“控制器一S1—S2一控制器”路径上传输的总时间T_{travel}。 (2)获得控制器和交换机的往返时间RTT：得到Ttravel后，还需要知道数据包控制器和交换机往返传输时间，从而计算得到控制器下发探测包以及交换机返回探测包的时延。根据OpenFlow协议，控制器生成Echo Request消息分别下发交换机S1和S2，并记录收到Echo Reply消息的时间，得到控制器和交换机的往返传输时间RTT。 (3)计算交换机链路时延：根据上述测量结果，通过公式（6）计算得到交换机S1和S2之间的时延T_{delay}。 T_{delay}=T_{travel} - \frac{RTT_{s1}+RTT_{s2} }{2} \tag {6}SDN traceroute：基于Packet-Out和Packet-In消息测量报文路径traceroute可提供报文路径可视化功能，确定到达某个主机的网络路径，帮助网管人员进行网络故障排除。然而，traceroute只适用于基于目的IP转发的网络且只能提供三层（IP）路径信息，因此在支持细粒度匹配转发的SDN网络难以发挥作用。 为了实现SDN网络路径可视化，Agarwal等人[7]基于OpenFlow 的Packet-Out和Packet-In开发了SDN traceroute用于测量报文路径。与traceroute类似，SDN traceroute使用低开销的探测包在不影响原有转发规则下测量报文路径。它的工作过程分为两个阶段，第一阶段如图11所示，使用图着色算法为网络中的每个交换机着色，使得任意两个相邻交换机的颜色不同。SDN traceroute使用VLAN优先级字段（3位）来携带颜色，如果拓扑用三种颜色着色，我们可以将VLAN优先级标签（001）、（010）和（011）分别分配给用第一种颜色、第二种颜色和第三种颜色着色的交换机。默认标签(000)是为生产流量保留的，在标签分配过程中不会使用。然后，它基于着色结果在网络中的每台交换机上安装能匹配所有相邻交换机颜色的高优先级流表项，使它们能够捕获来自相邻交换机的探测包并转发至控制器进行记录。以颜色为（001）的交换机为例，需要安装两条相邻交换机的流表项，其匹配域分别设置为相邻交换机的颜色（010）和（011），优先级设置为32767，匹配数据包将被转发至控制器。值得注意的是，安装的流表项不包含任何与交换机自己颜色匹配的规则。 图11 SDN traceroute交换机着色和高优先级流表项安装示意图 第二阶段如图12所示，SDN traceroute根据输入的路由起始点（交换机ID和端口），首先使用Packet-Out消息携带探测包注入到该起始交换机，开始跟踪路由。探测包的颜色设置为该交换机的颜色（001），动作设置为按照流表转发。起始交换机接收到Packet-Out消息后，通过查询流表处理探测包。由于探测包中携带的颜色与交换机颜色相同，在流表中没有匹配到第一阶段所安装的流表项，因此按照实际的转发规则将该探测包路由到下一跳。下一跳交换机接收到探测包后，查询流表处理探测包，由于探测包的颜色为（001）在流表中匹配到高优先级转发规则，探测包将用Packet-In消息转发至控制器进行记录。控制器记录下这一跳交换机的ID和端口号后，修改探测包颜色为该跳交换机颜色，并用Packet-Out消息重新将探测包注入到该跳交换机，以继续进行下一跳记录，重复这个过程，最终就能测出报文完整的传输路径，路径以（交换机ID，端口号）构成的列表进行展示。 图12 SDN traceroute路由追踪示意图 OFDP：基于Packet-Out和Packet-In消息测量拓扑拓扑测量负责对网络中各个设备之间的链路关系进行定期的检测，并维护完整的网络拓扑，是控制器和上层应用实现对整个网络资源进行统一调度和管理的基础。在传统IP网络中，拓扑测量可采用链路发现协议（Link Layer Discovery Protocol，LLDP），其原理是每个网络节点将自己和相邻设备的链路信息发送给其他节点，最终实现在各个网络设备上分散地测量链路信息。LLDP报文格式如图13所示，其中包含了Chassis ID TLV（设备标示符），Port ID TLV（端口标示符)等字段。 图13 LLDP报文格式 SDN网络中也可使用LLDP进行拓扑测量，在测量过程中需要借助Packet-Out和Packet-In消息，基于该方法制定的OFDP协议（OpenFlow Discovery Protocol）[8]则被广泛用于SDN控制器实现拓扑测量，其测量原理如图14所示，基本思想如下： （1）控制器构造包含LLDP数据包的Packet-Out消息下发至交换机S1，并指定从某端口转发至交换机S2，其中LLDP数据包中的Chassis ID TLV字段设置为交换机S1的Datapath ID，Port ID TLV字段设置为交换机目标转发端口，即S1的1端口。 （2）S2接收到LLDP数据包，触发Packet-In消息，将LLDP数据包发回控制器。 （3）控制器分析LLDP报文中Chassis ID和Port ID，结合触发Packet-In消息的交换机及端口号，可知S1的1端口和S2的2端口存在连接关系，从而获得一条链路信息。通过这种方式，控制器可以实现对整个网络的拓扑测量，发送的Packet-Out信息数量与网络中所有交换机活动端口的数量有关。 图14 基于Packet-Out和Packet-In消息测量拓扑原理图 0x03 基于sFlow的测量方法sFlow是一种在交换机上进行流量采样的技术，提供对数据包采样和端口计数器采样，实现采集流和端口的统计信息[9]。 sFlow系统如图15所示，交换机上部署sFlow Agent，在端口上对数据包进行采样，同时采集端口计数器。sFlow Agent将采集到的数据封装在sFlow报文中发送给sFlow Collector，由它分析生成流量视图。 图15 sFlow系统 sFlow提供数据包采样和端口计数器采样两种方式。 （1）数据包采样[10] 交换机在每个端口上按照1/N的采样率抽取数据包，并将它们的首部和元数据（如采样频率、交换机ID、时间戳、输入输出端口等）发送给sFlow Collector，它能够根据采样数据推算出流的统计信息 例如：某条流中采样数据包个数为100，采样比为1/200，可推算出该流的数据包总数 = 100 * 200 = 20000。 （2）端口计数器采样 sFlow Agent按照采样间隔读取交换机端口计数器，采集端口统计信息（端口接收/发送字节数、接收/发送数据包个数等）发送给sFlow Collector。 OpenSample：基于sFlow测量流速和链路利用率OpenSample[11]是一种针对SDN网络，利用sFlow技术实现的网络测量系统，它可以实现在SDN中测量流速和链路利用率。其架构如图16所示。 图16 OpenSample架构 （1）在OpenFlow交换机端口上使用sFlow Agent直接对数据包以及端口计数器进行采样，采样数据发送给sFlow Collector。 （2）sFlow Collector对数据包样本和计数器样本进行分析获得网络状态信息。 （3）控制器通过API获取sFlow Collector分析结果，可用于流量工程、资源规划、入侵监测等。 OpenSample可用于测量流速和链路利用率。流速是指单位时间内某条流的传输长度，OpenSample基于TCP序列号Seq来测量TCP流速，其原理如图17所示，将同一条TCP流中提取的两个采样数据包TCP Seq值相减，除以两采样数据包的时间戳间隔，如公式（7）所示，即可得到该条流的近似流速。 图17 提取TCP流中两个采样数据包的TCP Seq用于计算流速 FlowRate(i,i+1)=\frac{Seq_{i+1}-Seq_{i} }{T_{i+1}-T_{i} } \tag {7} 链路利用率是指链路吞吐量与链路带宽的比值，OpenSample基于数据包采样测量链路利用率。假设在给定时间段T_{interval}内，被测链路端口上采集的数据包数量为N_{SampledPackets}，端口采样频率为Ratio_{sampling} =1/ N，数据包平均长度为Len_{packet}，则 （1）通过公式（8）计算可得链路上传输的数据包总数 N_{TotalPackets}=\frac{N_{SampledPackets} }{Ratio_{sampling} },Ratio_{sampling}=\frac{1}{N} \tag {8}（2）通过公式（9）计算可得链路吞吐量 Throughtput_{link}=\frac{N_{TotalPackets}*Len_{packet} }{T_{interval} } \tag {9}（3）通过公式（10）计算可得链路利用率 Utilization_{link}=\frac{Throughtput_{link} }{Bandwidth_{link} } \tag {10}0x04 参考 [1] 戴冕, 程光, 周余阳. 软件定义网络的测量方法研究[J]. 软件学报, 2019(6):1853-1874. [2] Hamad D J , Yalda K G , Okumus I T . Getting traffic statistics from network devices in an SDN environment using OpenFlow[C]// Information Technology and Systems 2015 of An IITP a RAS Interdisciplinary Conference &amp; School. 2015.（基于Port-Stats测量链路吞吐量） [3] Adrichem N L M V , Doerr C , Kuipers O A . OpenNetMon: Network Monitoring in OpenFlow Software-Defined Networks[J]. 2014.（OpenNetMon，基于Flow-Stats消息测量流吞吐量、流丢包率，基于Packet-Out和Packet-In测量链路时延） [4] Tootoonchian A , Ghobadi M , Ganjali Y . OpenTM: Traffic Matrix Estimator for OpenFlow Networks[C]// Passive and Active Measurement, 11th International Conference, PAM 2010, Zurich, Switzerland, April 7-9, 2010. Proceedings. Springer-Verlag, 2010.（OpenTM，基于Flow-Stats和Port-Stats消息测量流量矩阵） [5] Yu C , Lumezanu C , Zhang Y , et al. FlowSense: Monitoring Network Utilization with Zero Measurement Cost[J]. 2013.（FlowSense，基于Packet-In和Flow-Removed消息被动测量链路吞吐量） [6] Yu C , Lumezanu C , Sharma A , et al. Software-Defined Latency Monitoring in Data Center Networks[C]// International Conference on Passive &amp; Active Network Measurement. 2015.（SLAM，基于Packet-Out和Packet-In测量链路时延） [7] Agarwal K , Carter J , Dixon C . SDN traceroute: tracing SDN forwarding without changing network behavior[C]// Workshop on Hot Topics in Software Defined Networking. ACM, 2014.（SDN traceroute，报文路径检测） [8] Azzouni A , Trang N T M , Boutaba R , et al. Limitations of OpenFlow Topology Discovery Protocol[J]. 2017.（OFDP ，Openflow Discovery Protocol原理的介绍） [9] 朱华鑫, 陈宏聪. sFlow网络流量监测技术探析[J]. 计算机与数字工程, 2010, 38(02): 110~113 [10] P.Phaal and S. Panchen. Packet Sampling Basics[EB/OL]. https://sflow.org/packetSamplingBasics/index.htm [11] Suh J , Kwon T T , Dixon C , et al. OpenSample: A Low-Latency, Sampling-Based Measurement Platform for Commodity SDN[C]// 2014 IEEE 34th International Conference on Distributed Computing Systems (ICDCS). IEEE, 2014.（OpenSample，测量链路利用率）]]></content>
      <categories>
        <category>SDN</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「OpenFlow」基于Packet-In消息处理机制修改IP协议号]]></title>
    <url>%2F2020%2F04%2F06%2F%E3%80%8COpenFlow%E3%80%8D%E5%9F%BA%E4%BA%8EPacket-In%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%BF%AE%E6%94%B9IP%E5%8D%8F%E8%AE%AE%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[0x00 目录[TOC] 0x01 前言如图1所示，OpenFlow 1.0中定义了Set动作，用于修改数据包的首部字段，这包括源宿MAC地址、源宿IP地址、源宿端口号等字段。通过将指定IP地址段与Set动作绑定作为流表项，即可在OpenFlow交换机上实现NAT的功能。 假设现在需要通过修改IP协议号，来实现一个数据包的伪装。例如：原本是ICMP的包，通过修改IP协议号（1-&gt;6）后，对外表现为TCP包。 此时OpenFlow 1.0显然不能满足需求，原因就是OpenFlow 1.0只能提供有限的数据包首部字段修改。 注：OpenFlow 1.3以后的版本，增加SET_FIELD动作，支持按照OXM TLV格式来修改任意数据包首部字段 为了在OpenFlow 1.0中实现修改IP协议号，可以利用Packet-In的消息处理机制。 0x02 基于Packet-In消息处理机制修改IP协议号基于Packet-In消息处理机制实现IP协议号修改的基本思路： 显示下发流表，对指定要修改IP协议号的数据包通过Packet-In消息上传到控制器 修改控制器上的Packet-In消息处理函数，解析数据包首部，修改IP首部中IP协议号字段 例子：如图2所示，假设有主机H1向H2发送ICMP包，现在希望将这个ICMP包的IP协议号字段进行修改，使其对外表现为TCP包，按照上面提到的思路即可实现。 注：上图中H1通过ping发送给H2的ICMP包经过控制器修改IP协议号后变为TCP包，H2在收到这个包之后，实际上不会进行ICMP响应，因此最终H1上会显示ping失败 0x03 POX + Mininet实验验证按照0x02中的例子，使用POX和Mininet进行验证。 实验环境 实验步骤 H1向H2发送ICMP包（h1 ping h2 -c 1） SW1将ICMP包Packet-In上传到控制器 控制器修改IP协议号（ICMP -&gt; TCP），变换后的TCP包（原ICMP包）Packet-Out至SW2并指示SW2转发给H2 在SW2与H1的链路、SW2与H2的链路上抓包，预期实验结果：前者抓到ICMP包，后者抓到TCP包，并且H1上显示ping失败 编写POX应用为了实现IP协议号的修改，需要在POX上编写一个应用transfer_ipproto（存放在POX源码的ext文件夹下），从而实现下面两个功能： 下发流表给SW1，指定ICMP包通过Packet-In上传到控制器处理 添加Packet-In消息处理函数，解析数据包首部，修改IP协议号后通过Packet-Out消息转发至SW2，并指导SW2将修改IP协议号后的数据包转发至H2 transfer_ipproto源码如下所示： # -*- coding: utf-8 -*- # 功能： # 通过Packet-In机制修改IP协议号及TCP选项 # 模块Packet-In处理函数中下发默认流表，构建路径 # # 网络拓扑： # h1 - sw1 - sw2 - h2 # # @Update History: # @Author Date Content # @CTZ 2020-03-24 添加必要的注释 # @CTZ 2020-03-31 完成代码编写及调试 from pox.core import core import pox.openflow.libopenflow_01 as of from pox.lib.packet.ethernet import ethernet from pox.lib.packet.icmp import icmp from pox.lib.packet.ipv4 import ipv4 from pox.lib.addresses import IPAddr from pox.lib.util import dpid_to_str, str_to_dpid log = core.getLogger() class transfer_ipproto(object): def __init__(self): log.info(&quot;初始化模块&quot;) # h1信息 self.h1_info = {} self.h1_info[&#39;ip&#39;] = &quot;10.0.0.1&quot; self.h1_info[&#39;mac&#39;] = &quot;00:00:00:00:00:01&quot; # h2信息 self.h2_info = {} self.h2_info[&#39;ip&#39;] = &quot;10.0.0.2&quot; self.h2_info[&#39;mac&#39;] = &quot;00:00:00:00:00:02&quot; # sw1信息 self.sw1_info = {} self.sw1_info[&#39;dpid&#39;] = str_to_dpid(&quot;0x0000000000000001&quot;) self.sw1_info[&#39;h1&#39;] = {} self.sw1_info[&#39;h1&#39;][&#39;port&#39;] = 1 self.sw1_info[&#39;sw2&#39;] = {} self.sw1_info[&#39;sw2&#39;][&#39;port&#39;] = 2 # sw2信息 self.sw2_info = {} self.sw2_info[&#39;dpid&#39;] = str_to_dpid(&quot;0x0000000000000002&quot;) self.sw2_info[&#39;sw1&#39;] = {} self.sw2_info[&#39;sw1&#39;][&#39;port&#39;] = 1 self.sw2_info[&#39;h2&#39;] = {} self.sw2_info[&#39;h2&#39;][&#39;port&#39;] = 2 # 虚拟IP协议号 #self.ipproto = ipv4.ICMP_PROTOCOL self.ipproto = ipv4.TCP_PROTOCOL # 统计packetin处理次数 self.packetin_count = 0 core.openflow.addListeners(self) def _handle_PacketIn (self, event): self.packetin_count = self.packetin_count+1 log.info(str(self.packetin_count) + &quot; ： PacketIn处理开始&quot;) #下发初始流表 if self.packetin_count == 1: #sw1 -&gt; sw2 msg = of.ofp_flow_mod() msg.match.dl_type = 0x800 msg.match.nw_src = IPAddr(self.h1_info[&quot;ip&quot;]) msg.match.nw_dst = IPAddr(self.h2_info[&quot;ip&quot;]) msg.actions.append(of.ofp_action_output(port=self.sw1_info[&#39;sw2&#39;][&#39;port&#39;])) core.openflow.sendToDPID(self.sw1_info[&#39;dpid&#39;], msg) msg = of.ofp_flow_mod() msg.match.dl_type = 0x800 msg.match.nw_src = IPAddr(self.h2_info[&quot;ip&quot;]) msg.match.nw_dst = IPAddr(self.h1_info[&quot;ip&quot;]) msg.actions.append(of.ofp_action_output(port=self.sw1_info[&#39;h1&#39;][&#39;port&#39;])) core.openflow.sendToDPID(self.sw1_info[&#39;dpid&#39;], msg) # sw1 -&gt; controller msg = of.ofp_flow_mod() msg.match.dl_type = 0x800 msg.match.nw_src = IPAddr(self.h1_info[&quot;ip&quot;]) msg.match.nw_dst = IPAddr(self.h2_info[&quot;ip&quot;]) msg.match.nw_proto = ipv4.TCP_PROTOCOL msg.priority = 0x8001 # 大于默认优先级0x8000 msg.actions.append(of.ofp_action_output(port=of.ofp_port_rev_map[&#39;OFPP_CONTROLLER&#39;])) core.openflow.sendToDPID(self.sw1_info[&#39;dpid&#39;], msg) msg = of.ofp_flow_mod() msg.match.dl_type = 0x800 msg.match.nw_src = IPAddr(self.h1_info[&quot;ip&quot;]) msg.match.nw_dst = IPAddr(self.h2_info[&quot;ip&quot;]) msg.match.nw_proto = ipv4.ICMP_PROTOCOL msg.priority = 0x8001 # 大于默认优先级0x8000 msg.actions.append(of.ofp_action_output(port=of.ofp_port_rev_map[&#39;OFPP_CONTROLLER&#39;])) core.openflow.sendToDPID(self.sw1_info[&#39;dpid&#39;], msg) # sw2 -&gt; sw1 msg = of.ofp_flow_mod() msg.match.dl_type = 0x800 msg.match.nw_src = IPAddr(self.h2_info[&quot;ip&quot;]) msg.match.nw_dst = IPAddr(self.h1_info[&quot;ip&quot;]) msg.actions.append(of.ofp_action_output(port=self.sw2_info[&#39;sw1&#39;][&#39;port&#39;])) core.openflow.sendToDPID(self.sw2_info[&#39;dpid&#39;], msg) msg = of.ofp_flow_mod() msg.match.dl_type = 0x800 msg.match.nw_src = IPAddr(self.h1_info[&quot;ip&quot;]) msg.match.nw_dst = IPAddr(self.h2_info[&quot;ip&quot;]) msg.actions.append(of.ofp_action_output(port=self.sw2_info[&#39;h2&#39;][&#39;port&#39;])) core.openflow.sendToDPID(self.sw2_info[&#39;dpid&#39;], msg) # sw2 -&gt; controller msg = of.ofp_flow_mod() msg.match.dl_type = 0x800 msg.match.nw_src = IPAddr(self.h2_info[&quot;ip&quot;]) msg.match.nw_dst = IPAddr(self.h1_info[&quot;ip&quot;]) msg.match.nw_proto = ipv4.TCP_PROTOCOL msg.priority = 0x8001 # 大于默认优先级0x8000 msg.actions.append(of.ofp_action_output(port=of.ofp_port_rev_map[&#39;OFPP_CONTROLLER&#39;])) core.openflow.sendToDPID(self.sw2_info[&#39;dpid&#39;], msg) msg = of.ofp_flow_mod() msg.match.dl_type = 0x800 msg.match.nw_src = IPAddr(self.h2_info[&quot;ip&quot;]) msg.match.nw_dst = IPAddr(self.h1_info[&quot;ip&quot;]) msg.match.nw_proto = ipv4.ICMP_PROTOCOL msg.priority = 0x8001 # 大于默认优先级0x8000 msg.actions.append(of.ofp_action_output(port=of.ofp_port_rev_map[&#39;OFPP_CONTROLLER&#39;])) core.openflow.sendToDPID(self.sw2_info[&#39;dpid&#39;], msg) log.info(&quot;已经下发初始流表&quot;) dpid = event.connection.dpid in_port = event.port packet = event.parsed if not packet.parsed: log.warning(&quot;%i %i ignoring unparsed packet&quot;, dpid, in_port) return if isinstance(packet, ethernet): log.info(&quot;解析包：eth&quot;) eth_packet = packet #if eth_packet.type == packet.IP_TYPE: if isinstance(eth_packet.payload, ipv4): log.info(&quot;解析包：ipv4&quot;) ip_packet = eth_packet.payload if isinstance(ip_packet.payload, icmp): log.info(&quot;解析包：icmp&quot;) icmp_packet = ip_packet.payload i = ipv4(v=ip_packet.v, hl=ip_packet.hl, tos=ip_packet.tos, iplen=ip_packet.iplen, id=ip_packet.id, flags=ip_packet.flags, frag=ip_packet.frag, ttl=ip_packet.ttl, srcip=ip_packet.srcip, dstip=ip_packet.dstip, protocol=self.ipproto) # 修改IP协议号 #csum i.set_payload(icmp_packet) e = ethernet(type=ethernet.IP_TYPE, src=eth_packet.src, dst=eth_packet.dst ) e.set_payload(i) # h1 -&gt; h2的ICMP包执行协议号变换 if ip_packet.srcip == IPAddr(self.h1_info[&quot;ip&quot;]) and ip_packet.dstip == IPAddr(self.h2_info[&quot;ip&quot;]): msg = of.ofp_packet_out() msg.data = e.pack() msg.actions.append(of.ofp_action_output(port=self.sw2_info[&#39;h2&#39;][&#39;port&#39;])) core.openflow.sendToDPID(self.sw2_info[&#39;dpid&#39;], msg) log.info(&quot;h1 -&gt; h2的ICMP包处理结束：IP协议号变换&quot;) # h2 -&gt; h1的ICMP包执行协议号变换 elif ip_packet.srcip == self.h2_info[&quot;ip&quot;] and ip_packet.dstip == self.h1_info[&quot;ip&quot;]: msg = of.ofp_packet_out() msg.data = e.pack() msg.actions.append(of.ofp_action_output(port=self.sw1_info[&#39;h1&#39;][&#39;port&#39;])) core.openflow.sendToDPID(self.sw1_info[&#39;dpid&#39;], msg) log.info(&quot;h2 -&gt; h1的ICMP包处理结束：IP协议号变换&quot;) log.info(&quot;PacketIn处理结束&quot;) return def launch(): core.registerNew(transfer_ipproto_tcpoptions) 配置POX启动参数 注：需要用到POX的arp_responder应用实现ARP的功能 Mininet验证1.启动POX、Mininet并打开H1和H2的终端 2.在H1和H2上启动wirehsark，分别配置显示过滤器为icmp和tcp 启动wireshark命令：sudo wireshark 3.在Mininet终端上发起Ping，H1向H2发送一个ICMP包 4.查看wireshark抓包结果 如图8和图9所示，H1上抓到ICMP包 如图10和图11所示，H2上抓到TCP包 根据图9和图11中的IP Payload（数据包原始字节流）相同可知，H2上抓到的TCP包就是修改了IP协议号的ICMP包。 至此，该实验验证了可以通过Packet-In消息处理机制来实现IP协议号的修改。该方法除了能够修改IP协议号外，也能修改数据包中首部的其他字段。 0x04 总结修改数据包首部字段的方法： 流表Set动作 注：OpenFlow1.3以前版本仅支持修改部分首部字段，OpenFlow1.3以后版本支持修改任意首部字段 基于Packet-In消息处理机制修改 0x05 参考 openflow-switch-v1.0.0 openflow-switch-v1.3.0 openflow-switch-v1.5.1]]></content>
      <categories>
        <category>SDN</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「Floodlight」链路丢包率测量]]></title>
    <url>%2F2020%2F02%2F22%2F%E3%80%8CFloodlight%E3%80%8D%E9%93%BE%E8%B7%AF%E4%B8%A2%E5%8C%85%E7%8E%87%E6%B5%8B%E9%87%8F%2F</url>
    <content type="text"><![CDATA[0x00 目录 0x00 目录 0x01 前言 0x02 基于OpenFlow的Port-Stats消息测量链路丢包率原理 0x03 链路丢包率测量模块设计 StatisticsCollector模块分析 linkdiscovery包分析 链路丢包率测量模块设计思路 0x04 链路丢包率测量模块实现 0x05 Mininet搭建拓扑测量链路丢包率 0x06 参考 0x01 前言Floodlight控制器中StatisticsCollector模块已经实现了用Port-Stats消息测量OpenFlow交换机端口的吞吐量，本文通过对StatisticsCollector模块进行扩展，并用Mininet搭建拓扑，实现在SDN网络中测量中链路丢包率。 0x02 基于OpenFlow的Port-Stats消息测量链路丢包率原理请参考基于OpenFlow消息的网络测量方法 0x03 链路丢包率测量模块设计StatisticsCollector模块分析如图1所示，src/main/java目录下，net.floodlightcontroller.statistics包中StatisticsCollector.java文件定义了StatisticsCollector模块。该模块每隔10s创建多个线程轮询拓扑中所有交换机以获取Port-Stats响应消息，通过Port-Stats响应消息中的rx_bytes、tx_bytes、duration_sec和duration_nsec四个字段来测量端口吞吐量。因此，可以在该模块获取Port-Stats响应消息基础上，添加代码以实现链路丢包率的测量。 StatisticsCollector模块中的PortStatsCollector内部类实现了端口吞吐量测量，如图2所示，它通过调用getSwitchStatistics方法来获取所有交换机的统计信息，然后根据上一次查询的Port-Stats消息以及本次查询的Port-Stats消息，分别提取rx_bytes、tx_bytes、duration_sec和duration_nsec字段，通过公式（2）和公式（3）即可计算出交换机端口发送吞吐量或接收吞吐量。 StatisticsCollector模块中的getSwitchStatistics方法有两个重载版本，分别是 protected List&lt;OFStatsReply&gt; getSwitchStatistics(DatapathId switchId, OFStatsType statsType) Map&lt;DatapathId, List&lt;OFStatsReply&gt;&gt; getSwitchStatistics(Set&lt;DatapathId&gt; dpids, OFStatsType statsType) 其中前者的作用是获取单台交换机的统计消息（以Stats结尾的消息，如Port-Stats消息）。该方法的实现如图3所示，首先构造一个Stats请求消息根据交换机DPID发送给指定交换机，然后接收交换机返回的Stats响应消息，并保存在List列表中。 后者的作用是创建多个线程，每个线程通过调用getSwitchStatistics(DatapathId switchId, OFStatsType statsType)方法负责获取一台交换机的统计消息，从而实现并行获取网络中所有交换机的统计消息。该方法的实现如图4所示。 linkdiscovery包分析如图5所示，src/main/java目录下，net.floodlightcontroller.linkdiscovery包中包含了链路的定义Link.java，可获取拓扑中所有链路的接口ILinkDiscoveryService.java。 如图6所示，在Floodlight中，由起始交换机DPID和端口ID以及终点交换机DPID和端口ID定义一条链路，可见链路是指交换机之间的连接关系，不包含主机与交换机之间的连接关系，同时链路是有方向的。 如图7所示，ILinkDiscoveryService接口中定义了许多获取链路、链路类型等方法，其中 public Map&lt;Link, LinkInfo&gt; getLinks(); 方法可用于获取拓扑中所有的链路。 链路丢包率测量模块设计思路链路丢包率测量模块将在StatisticsCollector模块的基础上实现，其设计思路： a.通过getSwitchStatistics方法发起查询，获取所有交换机的Port-Stats消息，并根据交换机DPID和其Port-Stats消息的映射关系存储在replies哈希表中 b.通过ILinkDiscoveryService接口获取所有链路，存储在links集合中 c.循环遍历links，分别从previousReplies和replies中获取上一次查询以及本次查询的Port-Stats消息，并从中提取tx_packets、rx_packets字段根据公式（1）计算当前遍历的链路的丢包率，将链路和链路丢包率的映射关系存储在linkLossResults哈希表中 d.用replies更新previousReplies e.根据linkLossResults打印链路丢包率 0x04 链路丢包率测量模块实现 在Eclipse中，src/main/java目录下，net.floodlightcontroller.statistics包中新建一个LinkLoss类，用于存储某条链路在查询间隙接收、发送数据包个数，以及丢包率，该类的实现代码如下: public class LinkLoss { private Link link; // 链路 = 起点（srcDPID + srcPort） + 终点（dstDPID + dstPort） private U64 txPackets; // 两次查询间隙，链路起点发送的数据包个数 private U64 rxPackets; // 两次查询间隙，链路终点接收的数据包个数 private U64 linkLoss; // 两次查询间隙，链路丢包率 public LinkLoss() { super(); } public LinkLoss(Link link, U64 txPackets, U64 rxPackets,U64 linkLoss) { super(); this.link = link; this.txPackets = txPackets; this.rxPackets = rxPackets; this.linkLoss = linkLoss; } public Link getLink() { return link; } public void setLink(Link link) { this.link = link; } public U64 getRxPackets() { return rxPackets; } public void setRxPackets(U64 rxPackets) { this.rxPackets = rxPackets; } public U64 getTxPackets() { return txPackets; } public void setTxPackets(U64 txPackets) { this.txPackets = txPackets; } public U64 getLinkLoss() { return linkLoss; } public void setLinkLoss(U64 linkLoss) { this.linkLoss = linkLoss; } @Override public String toString() { return &quot;(&quot; + link.getSrc() + &quot;/&quot; + link.getSrcPort() + &quot;) -&gt; (&quot; + link.getDst() + &quot;/&quot; + link.getDstPort() + &quot;) TxPackets:&quot; + txPackets.getValue() + &quot; RxPackets:&quot; + rxPackets.getValue() + &quot; LinkLoss:&quot; + linkLoss.getValue() + &quot;%&quot;; } } 打开net.floodlightcontroller.statistics包中StatisticsCollector.java文件，在StatisticsCollector类中添加下列属性: // 获取链路的接口 private static ILinkDiscoveryService linkDiscoveryService; // 保存上一次查询的Port-Stats消息 private static HashMap&lt;Link, List&lt;OFPortStatsEntry&gt;&gt; priorLinkPortStats = new HashMap&lt;Link, List&lt;OFPortStatsEntry&gt;&gt;(); // 保存本次查询的Port-Stats消息 private static HashMap&lt;Link, List&lt;OFPortStatsEntry&gt;&gt; linkPortStats = new HashMap&lt;Link, List&lt;OFPortStatsEntry&gt;&gt;(); // 保存上一次查询与本次查询间隙的链路丢包率 private static HashMap&lt;Link, LinkLoss&gt; linkLossResults = new HashMap&lt;Link, LinkLoss&gt;(); //保存查询次数 private static int lookupCounter = 0; 为了保证ILinkDiscoveryService接口能够正常使用，还需要添加接口的依赖并进行初始化，StatisticsCollector.java的相应方法中添加下列带有ADD注释的代码： @Override public Collection&lt;Class&lt;? extends IFloodlightService&gt;&gt; getModuleDependencies() { Collection&lt;Class&lt;? extends IFloodlightService&gt;&gt; l = new ArrayList&lt;Class&lt;? extends IFloodlightService&gt;&gt;(); l.add(IOFSwitchService.class); l.add(IThreadPoolService.class); l.add(IRestApiService.class); // ADD:添加依赖 l.add(ILinkDiscoveryService.class); return l; } @Override public void init(FloodlightModuleContext context) throws FloodlightModuleException { switchService = context.getServiceImpl(IOFSwitchService.class); threadPoolService = context.getServiceImpl(IThreadPoolService.class); restApiService = context.getServiceImpl(IRestApiService.class); // ADD:初始化接口 linkDiscoveryService = context.getServiceImpl(ILinkDiscoveryService.class); Map&lt;String, String&gt; config = context.getConfigParams(this); if (config.containsKey(ENABLED_STR)) { try { isEnabled = Boolean.parseBoolean(config.get(ENABLED_STR).trim()); } catch (Exception e) { log.error(&quot;Could not parse &#39;{}&#39;. Using default of {}&quot;, ENABLED_STR, isEnabled); } } log.info(&quot;Statistics collection {}&quot;, isEnabled ? &quot;enabled&quot; : &quot;disabled&quot;); if (config.containsKey(INTERVAL_PORT_STATS_STR)) { try { portStatsInterval = Integer.parseInt(config.get(INTERVAL_PORT_STATS_STR).trim()); } catch (Exception e) { log.error(&quot;Could not parse &#39;{}&#39;. Using default of {}&quot;, INTERVAL_PORT_STATS_STR, portStatsInterval); } } log.info(&quot;Port statistics collection interval set to {}s&quot;, portStatsInterval); } StatisticsCollector.java文件中将原来用于测量端口吞吐量的内部类PortStatsCollector的实现逻辑替换成以下代码： Private class PortStatsCollector implements Runnable { @Override // 计算丢包率 public void run() { // 发起查询，获取所有交换机的Port-Stats消息，存储在replies中 Map&lt;DatapathId, List&lt;OFStatsReply&gt;&gt; replies = getSwitchStatistics(switchService.getAllSwitchDpids(), OFStatsType.PORT); log.info(&quot;Replies Num:&quot; + replies.size()); // 查询次数计数器加一 ++lookupCounter; log.info(&quot;Lookup Counter:&quot; + lookupCounter); // 获取所有链路 Set&lt;Link&gt; links = linkDiscoveryService.getLinks().keySet(); log.info(&quot;Total Links:&quot; + links.size()); // 遍历链路 for(Link l : links) { log.info(l.toString()); // 从replies中获取本次查询中，与当前链路起点有关的Port-Stats消息，存储到HashMap&lt;Link, List&lt;OFPortStatsEntry&gt;&gt; linkPortStats中 List&lt;OFStatsReply&gt; srcPortStatsReplies = replies.get(l.getSrc()); boolean breakFlag = false; for(OFStatsReply r : srcPortStatsReplies) { OFPortStatsReply psr = (OFPortStatsReply) r; for (OFPortStatsEntry pse : psr.getEntries()) { if(pse.getPortNo().equals(l.getSrcPort())) { List&lt;OFPortStatsEntry&gt; tmpList = linkPortStats.get(l); if(tmpList == null || tmpList.isEmpty()) { tmpList = new ArrayList&lt;OFPortStatsEntry&gt;(); tmpList.add(pse); } else { tmpList.add(pse); } linkPortStats.put(l, tmpList); breakFlag = true; break; } } if(breakFlag) break; } // 从replies中获取本次查询中，与当前链路终点有关的Port-Stats消息，存储到HashMap&lt;Link, List&lt;OFPortStatsEntry&gt;&gt; linkPortStats中 List&lt;OFStatsReply&gt; dstPortStatsReplies = replies.get(l.getDst()); breakFlag = false; for(OFStatsReply r : dstPortStatsReplies) { OFPortStatsReply psr = (OFPortStatsReply) r; for (OFPortStatsEntry pse : psr.getEntries()) { if(pse.getPortNo().equals(l.getDstPort())) { List&lt;OFPortStatsEntry&gt; tmpList = linkPortStats.get(l); if(tmpList == null || tmpList.isEmpty()) { tmpList = new ArrayList&lt;OFPortStatsEntry&gt;(); tmpList.add(pse); } else { tmpList.add(pse); } linkPortStats.put(l, tmpList); breakFlag = true; break; } } if(breakFlag) break; } // 若只有一次查询，则不计算丢包率 if(lookupCounter == 1) { continue; } // 获取上一次查询和本次查询的该链路的Port-Stats消息，计算该链路丢包率 OFPortStatsEntry srcPriorPSE = priorLinkPortStats.get(l).get(0); OFPortStatsEntry dstPriorPSE = priorLinkPortStats.get(l).get(1); OFPortStatsEntry srcCurrentPSE = linkPortStats.get(l).get(0); OFPortStatsEntry dstCurrentPSE = linkPortStats.get(l).get(1); U64 linkLoss = U64.ZERO; // 丢包率范围：[0,1],linkloss中存储百分比 if(srcPriorPSE != null &amp;&amp; dstPriorPSE != null &amp;&amp; srcCurrentPSE != null &amp;&amp; dstCurrentPSE != null) { U64 srcTxPackets = U64.ofRaw(srcCurrentPSE.getTxPackets().getValue() - srcPriorPSE.getTxPackets().getValue() ); U64 dstRxPackets = U64.ofRaw(dstCurrentPSE.getRxPackets().getValue() - dstPriorPSE.getRxPackets().getValue() ); if(srcTxPackets.equals(U64.ZERO)) // 上一次查询与本次查询的间隙内，该链路上无数据包发送 linkLoss = U64.ZERO; else if(srcTxPackets.compareTo(dstRxPackets) &lt; 0) linkLoss = U64.ofRaw(100); else if(!srcTxPackets.equals(U64.ZERO)) linkLoss = U64.ofRaw(100 - (dstRxPackets.getValue() * 100 / srcTxPackets.getValue())) ; linkLossResults.put(l, new LinkLoss(l, srcTxPackets, dstRxPackets, linkLoss)); }//if }//for // 更新priorLinkPortStats，并清空本次查询结果linkPortStats priorLinkPortStats = new HashMap&lt;Link, List&lt;OFPortStatsEntry&gt;&gt;(linkPortStats); linkPortStats.clear(); // 打印所有链路丢包率 if(!linkLossResults.isEmpty()) { String result = &quot;&quot;; for(Link l : linkLossResults.keySet()) { result += linkLossResults.get(l).toString() + &quot;\n&quot;; } log.info(result); } }//function }//class 在Floodlight源码src/main/resources目录下的floodlightdefault.properties文件中，修改代码设置StatisticsCollector模块随着Floodlight控制器一起启动。 net.floodlightcontroller.statistics.StatisticsCollector.enable=TRUE 0x05 Mininet搭建拓扑测量链路丢包率假设拓扑如图8所示，使用带有链路丢包率测量模块的Floodlight控制器测量拓扑中所有交换机之间链路的丢包率。 新开终端编译并启动Floodlight控制器。 cd floodlight ant java –jar target/floodlight.jar 新开终端启动Mininet，构造如图8所示的测试拓扑。 sudo mn --controller=remote,ip=127.0.0.1 --switch ovsk,protocols=OpenFlow13 --mac --topo=linear,2 在Mininet交互模式下打开主机H1的终端。 mininet &gt; xterm h1 在主机H1终端上使用hping3发包工具以500pps（packet per second）的速率发送数据包给主机H2，Floodlight控制器终端显示测量的S1与S2之间链路丢包率结果如图9所示。 hping3 –i u2000 10.0.0.2 0x06 参考 基于OpenFlow消息的网络测量方法]]></content>
      <categories>
        <category>SDN</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基于OpenFlow消息的网络测量方法]]></title>
    <url>%2F2020%2F02%2F12%2F%E5%9F%BA%E4%BA%8EOpenFlow%E6%B6%88%E6%81%AF%E7%9A%84%E7%BD%91%E7%BB%9C%E6%B5%8B%E9%87%8F%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[0x00 目录 0x00 目录 0x01 前言 0x02 基于OpenFlow的Port-Stats消息测量丢包率和吞吐量 Port-Stats消息 测量丢包率 测量吞吐量 0x03 基于OpenFlow的Packet-Out消息和Packet-In消息测量拓扑和时延 Packet-Out消息 Packet-In消息 测量拓扑 测量时延 0x04 参考 0x01 前言网络运行情况需要通过链路丢包率、时延、吞吐量等网络性能指标来体现。本文总结了SDN中，利用OpenFlow消息去测量网络拓扑、链路丢包率和时延、以及交换机端口吞吐量的方法。 0x02 基于OpenFlow的Port-Stats消息测量丢包率和吞吐量OpenFlow交换机中维护了多种计数器，会对每张流表、每条流表项、每个物理端口、每条队列等进行信息统计。通过OpenFlow统计消息，SDN控制器可以周期性的查询并获取OpenFlow交换机的计数器统计信息，这些信息可用于测量丢包率和吞吐量，这种通过查询的测量方法属于被动测量。 OpenFlow统计消息包含Port-Stats消息、Flow-Stats消息、Aggregate-Stats消息、Queue-Stats消息、Group-Stats消息、Meter-Stats消息和Table-Stats消息，这些消息可用于获取OpenFlow交换机中指定计数器的统计信息，如Port-Stats消息可以用于获取指定OpenFlow交换机物理端口的统计信息，Flow-Stats消息用于获取指定流表项的统计信息。 Port-Stats消息测量链路丢包率和端口吞吐量需要用到Port-Stats消息。 Port-Stats消息具体有两种，一种是Port-Stats-Request消息，用于SDN控制器请求交换机端口统计信息，另一种是Port-Stats-Reply消息，交换机用它来应答SDN控制器，具体过程是交换机读取指定端口的计数器，获得端口的统计信息并将其封装在该消息中，然后将消息发送给SDN控制器。在OpenFlow 1.3中，Port-Stats-Request和Port-Stats-Reply消息格式如图1和图2所示，SDN控制器可以从Port-Stats-Reply消息中获取到交换机端口的接收/发送数据包个数（rx_packets/tx_packets），接收/发送字节数（rx_bytes/tx_bytes），丢弃数据包个数(rx_dropped/tx_dropped)，冲突次数（collisions），端口生存时间（duration_sec和duration_nsec）等统计信息，这些信息将用于计算链路丢包率、端口吞吐量。 测量丢包率丢包率是指一段时间内，数据包丢失数与总发送数的比值。 如图3所示，测量S1到S2方向的链路丢包率时，SDN控制器需定期向交换机S1和S2发送Port-Stats-Request消息，来获取S1的1端口发送数据包个数tx_packetss1以及S2的2端口接收数据包个数rx_packetss2。通过每隔一段时间进行轮询，利用公式（1）可以计算得到S1到S2方向的链路在第i-1次和第i次查询时间段内的丢包率。 测量吞吐量吞吐量是指单位时间内传输无差错数据总量。 测量交换机端口吞吐量时，依然按图3所示，SDN控制器将周期性发送Port-Stats-Request消息到指定交换机，并从交换机的Port-Stats-Reply消息中获取接收/发送字节数（rx_bytes/tx_bytes）和端口生存时间（duration_sec和duration_nsec），利用公式（2）和（3）可以计算第i-1次和第i次查询时间段内的吞吐量大小。 注：交换机的一个物理端口实际上是由一个TX端口和一个RX端口组成，分别用于发送和接收数据，因此端口吞吐量实际指的是TX端口的发送吞吐量，以及RX端口的接收吞吐量。例如，计算发送吞吐量，则公式2中的分子为tx_bytes(i) - tx_bytes(i-1)。 0x03 基于OpenFlow的Packet-Out消息和Packet-In消息测量拓扑和时延根据主动测量的思想，可由SDN控制器生成探测数据包并下发至指定的交换机，当测量过程结束时，被测交换机需要触发相应机制将探测包返回控制器，由控制器分析并计算得到测量结果。由于SDN网络中交换机处理数据包的规则，即流表项，需要由控制器指定，因此实现主动测量的关键在于控制器如何生成和回收探测数据包，以及如何制定探测包的转发规则。 Packet-Out消息OpenFlow协议规定了控制器和交换机相互发送数据包的消息类型。由控制器发起的Controller-to-Switch消息类型中，包含一类Packet-Out消息，其格式如图4所示。控制器能够自定义该消息中携带的数据包内容，以及交换机收到Packet-Out消息后的行为。控制器通过在Packet-Out消息中封装探测数据包并下发至指定交换机，就能够发起主动测量任务。 Packet-In消息在由交换机发起的Asynchronous消息类型中，包含Packet-In消息，其格式如图5所示，该消息与Packet-Out类似，可以封装交换机上的指定数据包并发送至控制器做进一步处理。当交换机中的流表项无法匹配某个数据包时，会默认触发Packet-In消息。由于探测数据包通常与网络中的正常流量有所不同，因此基于OpenFlow的SDN主动测量可以利用Packet-In消息机制实现探测包的回收。 测量拓扑拓扑测量负责对网络中各个设备之间的链路关系进行定期的检测，并维护完整的网络拓扑，是控制器和上层应用实现对整个网络资源进行统一调度和管理的基础。在传统IP网络中，拓扑测量采用链路发现协议(LLDP)。LLDP报文格式如图6所示，其中包含了Chassis ID TLV(设备标示符)，Port ID TLV(端口标示符)等字段，每个网络节点将自己和相邻设备的链路信息发送给其他节点，最终实现在各个网络设备上分散地测量链路信息。 目前，OpenFlow的拓扑发现协议(OFDP)依然沿用了LLDP协议，基于OpenFlow的Packet-Out和Packet-In消息测量拓扑，其采用了主动测量方式，原理如图7所示，基本思想如下： （1）控制器构造包含LLDP数据包的Packet-Out消息下发至交换机S1，并指定从某端口转发至交换机S2，其中LLDP数据包中的Chassis ID TLV字段设置为交换机S1的Datapath ID，Port ID TLV字段设置为交换机目标转发端口。 （2）S2接收到LLDP数据包，触发Packet-In消息，将LLDP数据包发回控制器。 （3）控制器通过分析LLDP数据包，可以得到LLDP数据包在交换机S1上的发出端口和在交换机S2上的接收端口存在链接关系，从而获得一条链路信息。通过这种方式，控制器可以实现对整个网络的拓扑测量，发送的Packet-Out信息数量与网络中所有交换机活动端口的数量有关。 测量时延交换机之间传输时延是表明链路运行状态的重要参数。由于OpenFlow交换机不具备在正常传输的报文中打时间戳的功能，无法采用传统IP网络中的被动测量方式。因此，需要利用主动测量思想，在交换机之间生成并发送探测包。如图8所示，控制器的测量目标是交换机S1到交换机S2的时延，则控制器将探测包发送至S1，并下发规则指定S1将探测包发送至S2。S2接收到探测包后，由于没有对应的转发规则，会将探测包返回控制器，控制器则会计算出探测包在路径中传输的总时间。由于控制器和交换机之间的通信也存在时延，因此控制器还需要发送通信消息，获得控制器和各个交换机之间的消息往返时间，通过计算差值，获得最终的链路时延结果。 因此，测量时延的详细步骤如下： (1)获得探测包传输时间Ttravel：控制器生成探测数据包，其中包含交换机S1的目标转发端口和生成探测数据包时的时间戳，用来记录探测包的转发路径和发送探测包的时间。然后，控制器通过Packet-Out消息封装探测数据包，并下发至交换机S1，并从指定端口将探测包转发至S2。S2接收到数据包后，由于没有匹配的流表项，会触发Packet-In消息，将探测包封装并返回控制器。控制器通过对探测包的字段进行分析，可以得到探测包在“控制器一S1—S2一控制器”路径上的传输时间Ttravel。 (2)获得控制器和交换机的往返时间RTT：得到Ttravel后，还需要知道数据包控制器和交换机往返传输时间，从而计算得到控制器下发探测包以及交换机返回探测包的时延。根据OpenFlow协议，控制器生成Echo Request消息分别下发交换机S1和S2，并记录收到Echo Reply消息的时间，得到控制器和交换机的往返传输时间RTT (3)计算交换机链路时延：根据上述测量结果，通过公式(4)计算得到交换机S1和S2之间的时延Tdelay。 0x04 参考 刘一童. SDN网络测量系统的研究与实现[D]. 2016. 张恒, 蔡志平, 李阳. SDN网络测量技术综述[J]. 中国科学:信息科学, 2018, v.48(03):65-86. 基于SDN的网络状态测量 / 北邮李呈 图解OpenFlow openflow-spec-v1.3.0]]></content>
      <categories>
        <category>SDN</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「OpenFlow」协议入门]]></title>
    <url>%2F2019%2F12%2F30%2F%E3%80%8COpenFlow%E3%80%8D%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[0x00 目录 0x00 目录 0x01 前言 0x02 OpenFlow简介 0x03 SDN与OpenFlow的关系 0x04 基于OpenFlow的SDN网络工作原理 传统网络中网络设备的工作过程 基于OpenFlow的SDN网络中网络设备的工作过程 小结 0x05 流表与流水线处理 流 流表 匹配域 指令与动作 流表匹配过程 例子——使用单流表转发数据包 多级流表与流水线处理 例子——多级流表实现对流的细粒度控制 0x06 OpenFlow的两种下发流表方式 Proactive Reactive 0x07 组表 例子——使用组表实现多播 0x08 计量表 例子——对流进行限速 0x09 OpenFlow消息 种类 Flow-Mod消息 Packet-In消息 Packet-Out消息 Port-Stats消息 0x0A 参考 0x01 前言本文主要参考OpenFlow v1.5.1协议、v1.3.0协议以及SDN相关书籍，对OpenFlow中主要机制（如流表与流水线处理、组表、计量表等）的原理进行解析 0x02 OpenFlow简介OpenFlow由斯坦福大学Nick Mckeown教授提出，为SDN控制平面与数据平面之间提供通信接口标准，以实现SDN网络的转控分离架构。OpenFlow协议允许SDN控制器直接访问和操作数据平面中的网络设备，控制网络转发行为，数据平面采用基于流的方式进行转发。目前由ONF（Open Networking Foundation）负责推广和制定OpenFlow标准，截至本文发表时，最新版本为1.5.1 0x03 SDN与OpenFlow的关系可以说OpenFlow是SDN中非常重要的技术，以至于许多人（包括笔者在内）在谈及SDN时就自然联想到OpenFlow。但SDN与OpenFlow不是划等号的关系，而是SDN包含OpenFlow的关系。实际上，SDN有多种实现方案，在ONF SDN方案中OpenFlow充当南向接口的作用。南向接口的定义是控制平面与数据平面之间进行交互的协议，南向接口除了可以采用OpenFlow外，还有许多别的协议，如OF-CONFIG、OVSDB、NETCONF、PCEP、XMPP等等 0x04 基于OpenFlow的SDN网络工作原理传统网络中网络设备的工作过程假设主机A向主机B发送IP数据包，且所有路由表和MAC地址表中都有该数据包的相应表项 路由器之间运行分布式路由协议构建路由表。查表成功则基于目的IP地址转发；查表失败时，丢弃数据包 交换机根据自学习算法构建MAC地址表。查表成功则基于目的MAC地址转发；查表失败时，除入端口外其余所有端口转发出去 基于OpenFlow的SDN网络中网络设备的工作过程假设主机A向主机B发送IP数据包，且所有流表有该数据包相应表项 OpenFlow交换机查询流表来转发数据包，查表成功则基于匹配域（如目的IP地址+源IP地址）转发；查表失败时，则询问SDN控制器 流表由SDN控制器来构建 假设主机A向主机B发送IP数据包，且OpenFlow交换机中流表为空 OF交换机接收IP数据包 OF交换机解析数据包首部并查询流表，由于流表为空，不知道如何转发，因此需要询问控制器 OF交换机向控制器发送Packet-In消息 控制器为主机A发送给主机B的IP数据包计算路由 控制器向OF交换机下发流表，使用FlowMod消息承载流表信息，OF交换机接收该消息后安装流表 控制器向OF交换机发送Packet-Out消息，指示OF交换机按照刚安装好的流表转发IP数据包 OF交换机收到Packet-Out消息后转发数据包 小结 路由计算、转发规则（流表）下发由控制器完成 OF交换机只需要按照流表进行转发，查表失败时，通过Pacekt-In消息询问控制器 0x05 流表与流水线处理流在介绍流表之前，需要先解释流的概念，流（Flow）就是具有相同特征的数据包集合。例如，源MAC地址为MAC_A，目的MAC地址为MAC_B的所有数据包集合就可以视为一条流，可见流具有方向性。有别于传统网络中路由器基于数据包独立转发的模式，使用OpenFlow的SDN网络是基于流进行转发的，即对相同特征的数据包集合采用同样的处理。 流表流表（Flow Table）是OpenFlow中最重要的一张表，它用于指导OpenFlow交换机对收到的数据包进行转发，相当于二层的MAC地址表和三层的路由表。在OpenFlow 1.1以后的版本中，每台交换机支持使用多张流表，构成流水线处理，从而完成对数据包更为复杂的处理。 流表由若干条流表项（Flow Entry）组成，流表项结构如下图所示。 匹配域（Match Fields）：用于定义某条流，也是流表匹配的依据 指令（Instructions）：表示对该条流应该如何处理 优先级（Priority）：表示该流表项的优先匹配程度 计数器（Counters）：用于统计该条流的信息 生存时间（Timeouts）：表示流表项的有效存活时间 Cookie：控制器设置用来过滤被流统计、流修改和流删除操作请求影响的流表项 标志（Flags）：用于流表项管理 流表项最为重要的两项为匹配域和指令，当OpenFlow交换机收到一个数据包，将它包头解析后与流表中流表项匹配域进行匹配，匹配成功则执行指令，因此流表可以简化理解为key-value形式的{匹配域-指令}表。 匹配域OpenFlow提供丰富的匹配域字段来定义不同粒度的流，如可以基于目的IP地址定义一条流，也可以根据源IP地址 + 目的IP地址来定义一条流 指令与动作指令（Instruction）是流表项匹配成功时的处理动作，分为三类 更新动作集（Action Set）：添加、修改、清空动作集，前面两个对应Write-Actions指令，清空动作集对应Clear-Actions指令 修改流水线处理次序：从序号低的表跳转到序号高的表，对应Go-To-Table指令 其他：更新元数据以及设定触发器，分别对应Write-Metadata指令和Stat-Trigger指令 动作（Action）Action是指对数据包的具体处理动作，可分为两类，一类是定义数据包的转发，另一类是修改数据包包头字段 流表匹配过程解析数据包得到的首部字段，用于与流表项匹配域进行匹配。若一个数据包与多个流表项匹配成功，最后只与优先级最高的流表项进行匹配。 匹配成功，更新计数器，执行相应指令 匹配失败 流表中没有设置Table-Miss流表项，匹配失败时，丢弃数据包 流表中设置有Table-Miss流表项（优先级为0且匹配域为ANY），则最后会匹配该表项，执行相应指令（如丢弃、交由控制器处理、交给下一张流表处理） 例子——使用单流表转发数据包假设主机A发送数据包给主机B，使用单张流表的OF交换机处理数据包过程，如图所示 OF交换机从1端口接收数据包 OF交换机解析数据包首部，并查询流表进行流表匹配，匹配第一条流表项，并执行相应指令 将数据包转发到OF交换机的2端口 多级流表与流水线处理从OpenFlow1.1开始引入了多级流表和流水线处理机制，多级流表的出现一方面能够实现对数据包的复杂处理，另一方面又能有效降低单张流表的长度，提高查表效率。每张表都有序号，数据包通过跳转指令按照流表序号递增的方向在多个流表之间进行匹配，这样就构成了一条流水线，如下图所示，可见流水线处理是有方向的。流水线处理可以在OpenFlow交换机的入端口或出端口上进行，一般都在入端口出进行流水线处理。当流水线上只有一张流表时，就简化成单流表匹配的情况。 流水线处理开始：OpenFlow交换机接收数据包后，执行入端口的流水线处理，同时给该流水线分配一个动作集（Action Set） 流表匹配 匹配成功 更新相应流表项的计数器，完成对该条流的统计工作 执行流表项对应的指令 匹配失败：一个数据包可能在流表中与所有的流表项都不匹配或者匹配到Table-Miss流表项（优先级为0且匹配域为ANY），这两种情况都称为Table-Miss，对于前者，OpenFlow交换机将丢弃数据包；对于后者，OpenFlow交换机根据Table-Miss流表项，处理数据包（丢弃数据包、转发给控制器、交给下一个流表处理） 流水线处理结束：若当前不是执行跳转指令，则执行动作集中的所有动作，完成对数据包的处理，然后结束流水线处理 例子——多级流表实现对流的细粒度控制使用多级流表实现主机A发送到给主机B的所有TCP报文正常转发，UDP报文均丢弃，从而实现对不同流的细粒度控制基本思想： 流表0中匹配主机A到主机B的IP流，然后跳转到其他流表，如流表2 流表2中在IP流的基础上进一步匹配TCP流或UDP流，根据要求将TCP流正常转发，UDP流丢弃 0x06 OpenFlow的两种下发流表方式根据流表的安装时机，可分为Proactive方式和Reactive方式 Proactive在数据包还未到达OpenFlow交换机前，SDN控制器就向OpenFlow交换机主动下发流表，这种方式相当于预置路由 例如Table-Miss表项，就需要采用Proactive方式在SDN控制器与OpenFlow交换机建立连接后下发，显示的指定数据包查表失败时，OpenFlow交换机的处理方式 Reactive数据包到达OpenFlow交换机因查流表失败时，产生Packet-In消息询问SDN控制器，SDN控制器计算路由后下发流表到OpenFlow交换机，这种方式相当于按需下发路由，只有在有路由需求且查流表失败时，才会触发新的流表安装 0x07 组表独立于流水线之外，每台OpenFlow交换机只有一张组表。组表（Group Table）由若干条组表项（Group Entry）组成，具有将多个端口定义为一个组的能力，从而实现广播、多播，负载均衡、链路聚合、故障转移等 组表项结构如图所示，定义了一到多个动作桶（Action Bucket），用于描述转发到指定端口前，对数据包的处理。 例子——使用组表实现多播假设主机A使用多播方式向主机B和C发送IP数据包 0x08 计量表对流进行测量，从而为流提供QoS功能，如限速、DiffServ 每台OpenFlow交换机只有一张计量表（Meter Table），由若干计量表项（Meter Entry）组成，每个计量表项可以定义一至多个计量带（Meter Band），计量带定义了带宽阈值和数据包处理方式（丢弃、DSCP标记） 例子——对流进行限速假设对某条流X（目的IP地址：10.0.0.2）进行限速，且当前测得流X数据包的速率为1200kBps 流表匹配后，交由计量1处理 由于测得数据包速率1200kBps &gt; 带宽阈值1000，根据计量带0定义的处理方式丢弃数据包，从而实现限速注：带宽阈值本身是无单位的数值，其表示含义取决于应用场景 0x09 OpenFlow消息种类消息按照发送的位置可分为三大类，每一大类中有若干子消息 Controller-to-Switch消息：SDN控制器主动发送给OpenFlow交换机的消息 Features：用于获取交换机特性 Configuration：用来配置和查询交换机参数 Modify-State：用来修改交换机状态信息（增删改流表项、组表项等） Table-Mod消息 Flow-Mod消息（流表操作，添加、删除、修改流表项） Group-Mod消息 Port-Mod消息 Meter-Mod消息 Read-State：用来读取交换机状态信息（当前配置、统计信息等） Port-Stats消息 Flow-Stats消息 … Packet-Out：用来指定交换机将数据包从指定端口转发出去 Barrier：在不同消息之间使用，确保操作顺序执行 Role Request：控制器用于询问或设置自身在交换机中的角色，常用于交换机与多控制器连接的场景 Asynchronous-Configuration：控制器设置异步消息过滤器，只接收感兴趣的异步消息，一般在多控制器场景下使用 Asynchronous（异步）消息：OpenFlow交换机主动发送给SDN控制器的异步消息 Packet-In：将数据包交给控制器处理，一般流表匹配中出现Table-Miss时或流表项显示指定将数据包交给控制器时，触发该消息 Flow-Removed：通知控制器，流表项被删除；流表项超时或控制器删除流表项时触发该消息（需要在交换机配置时使能该消息） Port-status ：通知控制器，交换机端口状态发生变化 Role-status：通知控制器，控制器在交换机中的角色发送变化 Controller-Status：通知控制器，OpenFlow通道状态发生变化 Flow-monitor：通知控制器，流表发送变化 Symmetric（对称）消息：可由SDN控制器或OpenFlow交换机主动发送的消息 Hello：建立控制器与交换机之间的OpenFlow通道 Echo：检测交换机与控制器之间的连接状态或测量OpenFlow通道的时延和带宽 Error：用于通告错误 Experiment：用于实验，测试新特性 Flow-Mod消息Flow-Mod消息用于流表操作，包括添加、删除、修改流表项。该消息由控制器下发给交换机，从而指导交换机对数据包的处理。 其在OpenFlow1.3中的消息格式如下图所示。 command： ADD:添加流表项 MODIFY：根据匹配域，修改所有匹配的流表项，可能有多条流表项被修改 MODIFY_STRICT：根据匹配域以及优先级，修改特定的流表项，只有一条流表项被修改 DELETE：根据匹配域，删除所有匹配的流表项，可能有多条流表项被删除 DELETE_STRICT：根据匹配域以及优先级，删除特定的流表项，只有一条流表项被删除 参考「OpenFlow」流表项删除DELETE与DELETE_STRICT的区别 Packet-In消息Packet-In消息用于将OpenFlow交换机上指定数据包交给控制器处理，一般流表匹配中出现Table-Miss时或流表项显示指定将数据包交给控制器时，触发该消息。此外，它还能用于主动测量时回收探测包，从而结合Packet-Out消息实现对网络拓扑与链路时延的测量，详情参考基于OpenFlow消息的网络测量方法。 其在OpenFlow1.3中的消息格式如下图所示。 buffer_id：若该字段为-1，表明交换机未缓存数据包，Packet-In消息需要携带完整数据包发送至控制器；否则，表明数据包已在交换机上缓存，Packet-In消息只携带部分数据包上传至控制器。 Packet-Out消息Packet-Out消息用于指定交换机将数据包从指定端口转发出去。触发该消息的情况有两种：1.转发Packet-In消息携带的数据包 2.转发控制器主动构造的数据包（如用于链路发现的LLDP报文）。此外，由于该消息能够携带自定义数据包，控制器通过在Packet-Out消息中封装探测包并下发至指定交换机，就能够发起主动测量任务，配合Packet-In消息可实现对网络拓扑与链路时延的测量，详情参考基于OpenFlow消息的网络测量方法。 其在OpenFlow1.3中的消息格式如下图所示。 buffer_id：若该字段为-1，表明交换机未缓存数据包，Packet-Out消息携带控制器创建的数据包发送至交换机；否则，Packet-Out消息表示交换机需要将本地缓存的数据包按照Packet-Out中的actions进行处理。 Port-Stats消息Port-Stats消息是统计消息（以Stats结尾的消息）的一种，用于控制器查询交换机的端口计数器，从而获取端口的统计信息（如端口接收/发送字节数、接收/发送数据包个数等）。此外，它还能用来测量丢包率和吞吐量，详情参考基于OpenFlow消息的网络测量方法。 该消息具体有两种，一种是Port-Stats-Request消息，用于SDN控制器请求交换机端口统计信息，另一种是Port-Stats-Reply消息，交换机用它来应答SDN控制器，它们在OpenFlow1.3版本中的消息格式如下图所示。 0x0A 参考 openflow-switch-v1.5.1 openflow-switch-v1.3.0 图解OpenFlow openflow协议基础入门-北邮-张健男 Openflow协议详解 重构网络：SDN架构与实现 深度剖析软件定义网络(SDN)]]></content>
      <categories>
        <category>SDN</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「OpenFlow」流表项删除DELETE与DELETE_STRICT的区别]]></title>
    <url>%2F2019%2F12%2F27%2F%E3%80%8COpenFlow%E3%80%8D%E6%B5%81%E8%A1%A8%E9%A1%B9%E5%88%A0%E9%99%A4DELETE%E4%B8%8EDELETE_STRICT%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[0x00 目录 0x00 目录 0x01 流表项操作与Flow_Mod消息 0x02 流表项删除DELETE与DELETE_STRICT区别 0x03 POX + Mininet实验验证 实验环境 实验步骤 1.启动POX 2.运行Mininet 3.添加两条流表项 4.DELETE删除流表项 5.添加两条流表项 6.DELETE_STRICT删除流表项 0x04 总结 0x05 参考 0x01 流表项操作与Flow_Mod消息在OpenFlow中，对流表项的操作，例如增加、修改、删除流表项，都是通过控制器下发Flow_Mod消息完成的。Flow_Mod消息的格式如图所示，其中command字段定义了对流表项的操作（增加、修改、删除），而对于修改和删除操作又分为NON_STRICT和STRICT两个版本。 0x02 流表项删除DELETE与DELETE_STRICT区别要想删除流表项，只需要构造command = DELETE或command = DELETE_STRICT的Flow_Mod消息即可，两者的区别如下： DELETE：根据匹配域，删除所有匹配的流表项，意味着可能有多条流表项被删除 DELETE_STRICT：根据匹配域以及优先级，删除特定的流表项，只有一条流表项被删除 例子：假设使用openflow1.0，且openflow交换机流表中只有以下两条流表项 flow entry1: { prioirity : 42 match : { dl_type : 0x0800 ip_src : 10.0.0.1 ip_dst : 10.0.0.2 } actions : output : &#39;sw1-eth2&#39; } flow entry2: { prioirity : 42 match : { dl_type : 0x0800 ip_src : 10.0.0.1 ip_dst : 10.0.0.2 ip_protocol : 6 tp_dst : 80 } actions : output : &#39;sw1-eth2&#39; } 若控制器下发command = DELETE的Flow_Mod消息 flow_mod msg: { command : DELETE prioirity : 42 match : { dl_type : 0x0800 ip_src : 10.0.0.1 ip_dst : 10.0.0.2 } actions : output : &#39;sw1-eth2&#39; } 那么openflow交换机将会根据Flow_Mod消息中的匹配域（match）去流表中查找所有匹配的流表项（若流表项中的匹配域描述比Flow_Mod消息中的匹配域更详细，也算查找成功），这里flow entry1和flow entry2都满足，因为它们都含有 match : { dl_type : 0x0800 ip_src : 10.0.0.1 ip_dst : 10.0.0.2 } 因此，两条流表项都会被删除 若控制器下发command = DELETE_STRICT的Flow_Mod消息 flow_mod msg: { command : DELETE_STRICT prioirity : 42 match : { dl_type : 0x0800 ip_src : 10.0.0.1 ip_dst : 10.0.0.2 } actions : output : &#39;sw1-eth2&#39; } openflow交换机会根据Flow_Mod消息中的匹配域（match）和优先级（prioirity）去流表中查找特定的流表项，这里只有flow entry1满足条件，因为flow entry2的匹配域多了两个字段 ip_protocol : 6 tp_dst : 80 因此只有flow entry1被删除 0x03 POX + Mininet实验验证按照0x02中提到的例子，使用POX和Mininet进行验证 实验环境- OpenFlow 1.0 : SDN控制器与openflow交换机之间通信的协议 - POX-eel : python实现的SDN控制器，用于构造Flow_Mod消息，并下发至openflow交换机 - Mininet 2.3.0d1 : 创建&quot; h1 -- sw1 -- h2 &quot;拓扑 - POX与Mininet均部署在同一台运行ubuntu 18.04 LTS的机器上 实验步骤1.启动POX打开终端，输入 home/ctz/pox-eel/pox.py openflow.of_01 --address=127.0.0.1 --port=6653 py - home/ctz/pox-eel/pox.py : POX程序的入口 - openflow.of_01 : POX的组件，使用openflow1.0进行通信 - address : openflow.of_01的参数，定义POX控制器的IP地址，这里定义为本地回环 - port : openflow.of_01的参数，定义POX控制器的监听端口，用于监听openflow交换机发来的消息 - py：使用POX交互模式，可在终端与POX控制器进行交互，例如构造Flow_Mod消息并发送给交换机 2.运行Mininet另开一终端，输入 sudo mn --controller=remote,ip=127.0.0.1,port=6653 --mac - controller=remote : mininet连接远程控制器 - ip : controller的参数，定义要连接的远程控制器IP地址 - port : controller的参数，定义要连接的远程控制器端口 - --mac : 从00:00:00:00:00:01开始，按递增序为主机设置MAC地址 3.添加两条流表项在运行POX的终端上，构造两条Flow_Mod消息，用于添加两条流表项到交换机 # 以下三条命令在POX控制器同openflow交换机连接上后只需要输入一次 import pox.openflow.libopenflow_01 as of from pox.lib.addresses import IPAddr core.openflow.connections.keys() # 获取连接的交换机dpid，会在终端上显示dpid # 下发一条流表项（h1 -&gt; h2 基于源目IP） msg = of.ofp_flow_mod() msg.priority = 42 msg.command = of.OFPFC_ADD msg.match.dl_type = 0x800 msg.match.nw_src = IPAddr(&quot;10.0.0.1&quot;) msg.match.nw_dst = IPAddr(&quot;10.0.0.2&quot;) msg.actions.append(of.ofp_action_output(port = 2)) core.openflow.connections[1].send(msg) # 1为交换机的dpid # 下发一条流表项（h1 -&gt; h2 基于源目IP和TCP目的端口号） msg = of.ofp_flow_mod() msg.priority = 42 msg.command = of.OFPFC_ADD msg.match.dl_type = 0x800 msg.match.nw_src = IPAddr(&quot;10.0.0.1&quot;) msg.match.nw_dst = IPAddr(&quot;10.0.0.2&quot;) msg.match.nw_proto = 6 msg.match.tp_dst = 80 msg.actions.append(of.ofp_action_output(port = 2)) core.openflow.connections[1].send(msg) # 1为交换机的dpid 在运行Mininet的终端中输入 dpctl dump-flows 显示交换机中流表信息 4.DELETE删除流表项在运行POX的终端上，构造一条command = DELETE的Flow_Mod消息，删除所有匹配的流表项 # 删除所有匹配流表项（h1 -&gt; h2 基于源目IP） msg = of.ofp_flow_mod() msg.priority = 42 msg.command = of.OFPFC_DELETE msg.match.dl_type = 0x800 msg.match.nw_src = IPAddr(&quot;10.0.0.1&quot;) msg.match.nw_dst = IPAddr(&quot;10.0.0.2&quot;) msg.actions.append(of.ofp_action_output(port = 2)) core.openflow.connections[1].send(msg) # 1为交换机的dpid 如下图所示，交换机根据Flow_Mod消息的match字段查找流表项，所有流表项均被删除 5.添加两条流表项按照步骤3，重新添加两条流表项 6.DELETE_STRICT删除流表项在运行POX的终端上，构造一条command = DELETE_STRICT的Flow_Mod消息，删除指定流表项 # 删除所有匹配流表项（h1 -&gt; h2 基于源目IP） msg = of.ofp_flow_mod() msg.priority = 42 msg.command = of.OFPFC_DELETE_STRICT msg.match.dl_type = 0x800 msg.match.nw_src = IPAddr(&quot;10.0.0.1&quot;) msg.match.nw_dst = IPAddr(&quot;10.0.0.2&quot;) msg.actions.append(of.ofp_action_output(port = 2)) core.openflow.connections[1].send(msg) # 1为交换机的dpid 如下图所示，交换机根据Flow_Mod消息的match字段和priority字段查找流表项，匹配域中含有端口号的流表项被保留，匹配域中不含端口号的流表项被删除 0x04 总结使用Flow_Mod删除流表项时，command = DELETE：删除所有匹配的流表项，只要流表项中Match字段描述 &gt;= Flow_Mod消息中的Match字段（如流表项中Match:{in_port:1,ip_src:10.0.0.1}，Flow_Mod消息中Match:{in_port:1}），则相关流表项均会被删除，因此被删除的流表项可能有多个 DELETE_STRICT：删除特定的流表项，只有同时满足Flow_Mod消息中匹配域以及优先级的流表项会被删除，被删除的流表项只有一个 0x05 参考 openflow控制器POX使用指南 SDN控制器之POX篇]]></content>
      <categories>
        <category>SDN</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「虚拟化」基于virsh实现虚拟机动态迁移]]></title>
    <url>%2F2019%2F12%2F11%2F%E3%80%8C%E8%99%9A%E6%8B%9F%E5%8C%96%E3%80%8D%E5%9F%BA%E4%BA%8Evirsh%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8A%A8%E6%80%81%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[0x00 目录 0x00 目录 0x01 虚拟机迁移方式 静态迁移 动态迁移 基于共享存储 基于本地存储 0x02 虚拟机管理工具 0x03 搭建KVM虚拟化环境 0x04 基于virsh实现虚拟机动态迁移 实验环境 SCP拷贝磁盘文件 virsh动态迁移内存状态 virsh导出配置文件 virsh定义并创建虚拟机 0x05 参考 0x01 虚拟机迁移方式虚拟机迁移一般指虚拟机从一台物理机上迁移到另一台物理机上，迁移的内容包括虚拟机的磁盘文件、配置文件和内存状态。从迁移方式上可分为两种：静态迁移和动态迁移。 静态迁移这种方式又称为离线迁移或线下迁移，指的是虚拟机需要在关机的前提下，完成迁移操作。迁移的过程分为两个阶段： 1.从源物理机上拷贝虚拟机的磁盘文件、配置文件至目的物理机上，可以使用SCP命令完成拷贝工作 2.在目的物理机上，根据拷贝的磁盘文件及配置文件，定义并创建虚拟机 动态迁移这种方式也成为热迁移、在线迁移、线上迁移等，总之就是指虚拟机在运行的情况下，完成从源物理机迁移至目的物理机，在这过程中虚拟机只经历一个很短暂的暂停（虚拟机从源物理机上切换到目的物理机上），用户几乎感受不到服务的中断 根据磁盘文件的存储位置，又可分为以下两类： 基于共享存储 基于本地存储（块存储） 基于共享存储源物理机与目的物理机拥有共享的存储设备，虚拟机的磁盘文件可以被源物理机和目的物理机所访问，因此无需迁移。迁移的过程如下： 1.从源物理机上迁移虚拟机的内存状态到目的物理机 注：迁移结束后，虚拟机就已经在目的物理机上运行了，但是由于目的物理机上无该虚拟机配置文件，若此时关闭虚拟机，就无法找到该虚拟机了，所以需要完成接下来的操作 2.在目的物理机上，根据迁移的内存状态导出虚拟机的配置文件 3.在目的物理机上，根据导出的虚拟机配置文件，定义并创建虚拟机 基于本地存储源物理机与目的物理机都使用独立的存储设备，因此迁移的内容包括虚拟机的磁盘文件、内存状态以及配置文件（从内存状态中导出），迁移的过程如下： 1.从源物理机上拷贝磁盘文件到目的物理机 例如：使用SCP命令，同时要使用相同的目录结构放置虚拟机磁盘文件 2.从物理机上迁移内存状态到目的物理机 例如：使用virsh migrate --live命令，或直接使用virt-manager图形化界面上的迁移操作 注：迁移结束后，虚拟机就已经在目的物理机上运行了，但是由于目的物理机上无该虚拟机配置文件，若此时关闭虚拟机，就无法找到该虚拟机了，所以需要完成接下来的操作 3.在目的物理机上，根据迁移的内存状态导出虚拟机的配置文件 4.在目的物理机上，根据导出的虚拟机配置文件，定义并创建虚拟机 0x02 虚拟机管理工具 libvirt：用于实现虚拟机管理的开源API，可以实现对虚拟机的创建、删除、分配资源等 virt-manager：基于libvirt实现的虚拟机管理工具，图形化界面，类似VMware Workstation和VirtualBox virsh：基于libvirt实现的虚拟机管理工具，命令行 0x03 搭建KVM虚拟化环境 查看CPU是否支持KVM egrep &quot;(svm|vmx)&quot; /proc/cpuinfo 如果有输出，则说明CPU支持KVM 安装KVM及相关依赖包 sudo apt-get install qemu-kvm sudo apt-get install qemu sudo apt-get install virt-manager sudo apt-get install virt-viewer sudo apt-get install libvirt-bin sudo apt-get install bridge-utils 启动KVM虚拟系统管理器 sudo virt-manager 0x04 基于virsh实现虚拟机动态迁移这里采用基于本地存储的动态迁移方式，实现在物理机1上的虚拟机VM1动态迁移到物理机2上。 实验环境名称 主机名 IP地址 操作系统 源物理机 kvm-node1 192.168.111.130 ubuntu-16.04.4-desktop 目的物理机 kvm-node2 192.168.111.132 ubuntu-16.04.4-desktop 虚拟机 VM1 192.168.122.18 ubuntu-16.04.3-server SCP拷贝磁盘文件在源物理机上使用SCP命令拷贝磁盘文件至目的物理机上 sudo scp /var/lib/libvirt/images/node.qcow2 192.168.200.132:/var/lib/libvirt/images /var/lib/libvirt/images：存放虚拟机磁盘文件的目录 node.qcow2：虚拟机VM1的磁盘文件 192.168.200.132：目的物理机IP地址 注1：磁盘文件拷贝到目的物理机上后，要存放在相同的目录结构中 注2：192.168.200.132前若不加用户名，则默认以root身份访问。若kvm@192.168.200.132，则以kvm身份访问 virsh动态迁移内存状态在源物理机上使用virsh命令迁移虚拟机内存状态至目的物理机上 sudo virsh migrate --live --verbose VM1 qemu+ssh://192.168.200.131/system tcp://192.168.200.131 --unsafe virsh migrate —live：动态迁移 —verbose：显示迁移详情 VM1：需要迁移的虚拟机 qemu+ssh：通过ssh连接到目的物理机上的system实例，具有最大权限来管理远程节点上的虚拟机资源 /system： 以root身份进行状态迁移 tcp：使用tcp连接 192.168.200.131：目的物理机IP地址 —unsafe：跳过安全检测 注：可以指定身份访问远程主机，如远程主机用户名为kvm，则可以使用 qemu+ssh://kvm@192.168.200.131/system，若不添加kvm，默认使用root访问 在目的物理机上，查看虚拟机状态 sudo virsh list --all 可见，虚拟机VM1已经迁移成功并且在目的物理机上运行 virsh导出配置文件在目的物理机上，根据内存状态导出虚拟机VM1配置文件，否则迁移后远程主机没有虚拟机VM1的配置文件，关闭VM1后，VM1就没有了 sudo virsh dumpxml VM1 &gt; /etc/libvirt/qemu/VM1.xml virsh定义并创建虚拟机根据VM1的配置文件定义并创建虚拟机 sudo virsh define /etc/libvirt/qemu/VM1.xml 0x05 参考 Virsh 虚拟机迁移 虚拟机迁移（QEMU动态迁移，Libvirt动（静）态迁移） Ubuntu 16.04 搭建KVM环境]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基于LSB算法实现信息隐藏]]></title>
    <url>%2F2019%2F11%2F23%2F%E5%9F%BA%E4%BA%8ELSB%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%2F</url>
    <content type="text"><![CDATA[0x00 目录 0x00 目录 0x01 问题描述 0x02 LSB算法原理 0x03 LSB算法实现 0x04 实验结果分析 实验数据 实验结果 0x05 健壮性分析 0x06 关键代码 秘密信息嵌入 秘密信息提取 加噪处理 0x01 问题描述基于LSB算法实现在320x240的灰度图像上隐藏秘密信息，并分析LSB算法的健壮性（抗攻击）。 0x02 LSB算法原理该算法包含秘密信息嵌入和提取两部分。嵌入：将二进制表示的秘密信息中的每一位，按照某种顺序（例如先按列再按行，如图1所示）依次存储在载体图像像素值的最低位上。提取：按照嵌入时的顺序依次从嵌有秘密信息的载体图像上提取像素值的最低位，将其组合后即可得到秘密信息。 0x03 LSB算法实现使用Python编码实现基于LSB算法的秘密信息嵌入与提取。秘密信息嵌入算法如图2所示，秘密信息提取算法如图3所示。LSB算法完整代码：https://github.com/Chentingz/LSB-Steganography 0x04 实验结果分析实验数据 秘密信息：”secret text is hidden in image using LSB algorithm\n2019.11.21” 原始载体图像名：raw_img.bmp 原始载体图像大小：320 x 240 原始载体图像通道数：单通道（灰度图像） 原始载体图像：见图4 实验结果 嵌入算法：按照图2的算法从文件中读取秘密信息后嵌入到原始载体图像中，从图5可见，嵌入前后的载体图像无明显变化。 提取算法：按照图3算法对嵌入秘密信息的载体图像提取出秘密信息，由图6可见，提取结果与嵌入前的秘密信息一致。 0x05 健壮性分析对嵌有秘密信息的载体图像分别采用高斯噪声和椒盐噪声处理，然后提取秘密信息，观察秘密信息是否遭到破坏，噪声处理前后的图像对比如图7所示。 采用图3中的提取算法，分别对高斯噪声和椒盐噪声处理过的图像提取信息，提取结果如图8所示，可见对基于LSB嵌入秘密信息的图像进行噪声处理后，秘密信息将遭到不同程度的破坏，LSB算法抗攻击性差。 0x06 关键代码秘密信息嵌入from PIL import Image eof_str = &quot;00000000&quot; &quot;&quot;&quot; 将秘密信息嵌入到载体图像中 首先将秘密信息转换成二进制字符串，如&quot;a&quot; -&gt; &quot;0110 0001&quot; 在二进制字符串的末尾添加两个0x0000的ASCII码作为结束标志，如&quot;0110 0001&quot; -&gt; &quot;0110 0001 0000 0000 0000 0000&quot; 按照图像从上到下，从左到右的顺序，将串的每一位依次插入到像素的最低位中，每一个像素用一个字节表示 @param text: string类型的秘密信息 @param raw_img: image类型原始载体图像 @return: image类型嵌入秘密信息后的图像 &quot;&quot;&quot; def insert_text_to_image(text, raw_img): mod_img = raw_img.copy() width = mod_img.size[0] height = mod_img.size[1] binstr = text2binarystring(text) binstr += eof_str + eof_str i = 0 for w in range(width): for h in range(height): if i == len(binstr): break value = mod_img.getpixel((w,h)) value = mod_lsb(value, binstr[i]) mod_img.putpixel((w,h), value) i=i+1 return mod_img &quot;&quot;&quot; 将秘密信息转换成二进制串 先将字符转换成对应的ASCII码，然后转二进制，最后8位对齐，不足的前面用0填充 @param text: string类型表示的秘密信息 @return: string类型表示的二进制串 &quot;&quot;&quot; def text2binarystring(text): binstr = &quot;&quot; for ch in text : # ord(ch): 将ch转换成十进制数 bin():转换成0b开头的二进制字符串 zfill:返回指定长度字符串，不足的前面填充0 binstr += bin(ord(ch)).replace(&#39;0b&#39;, &#39;&#39;).zfill(8) return binstr &quot;&quot;&quot; 将value的最低位替换成bit,返回修改后的value @param value: int类型表示的像素值 @param bit: string类型表示的嵌入位 @return: int类型表示的修改后的像素值 &quot;&quot;&quot; def mod_lsb(value, bit): str = bin(value).replace(&#39;0b&#39;, &#39;&#39;).zfill(8) lsb = str[len(str)-1] if lsb != bit : str = str[0:len(str)-1] + bit return int(str, 2) 秘密信息提取from PIL import Image eof = chr(int(eof_str, 2)) &quot;&quot;&quot; 从图像中提取秘密信息，返回string类型的秘密信息 @param mod_img: 嵌入秘密信息后的图像 @return: string类型表示的秘密信息 &quot;&quot;&quot; def get_text_from_image(mod_img): width = mod_img.size[0] height = mod_img.size[1] bytestr = &quot;&quot; text = &quot;&quot; countEOF = 0 for w in range(width): for h in range(height): value = mod_img.getpixel((w,h)) bytestr += get_lsb(value) if len(bytestr) == 8 : # 转换成ASCII码 # 例：&quot;0110 0001&quot; -&gt; 97 -&gt; &#39;a&#39; ch = chr(int(bytestr, 2)) if ch == eof : countEOF = countEOF + 1 if countEOF == 2 : break text += ch bytestr = &quot;&quot; return text &quot;&quot;&quot; 返回像素值的lsb @param value: int类型表示的像素值 @return: string类型表示的像素值最低位 &quot;&quot;&quot; def get_lsb(value): str = bin(value).replace(&#39;0b&#39;, &#39;&#39;).zfill(8) lsb = str[len(str)-1] return lsb 加噪处理import cv2 import matplotlib.pyplot as plt import skimage.util as ski import LSB from PIL import Image mod_img_path = &quot;./test/mod_img.bmp&quot; img_gaussian_path = &quot;./test/img_gaussian.bmp&quot; img_sp_path = &quot;./test/img_sp.bmp&quot; img_mod_and_noises_compare_path = &quot;./test/img_mod_and_noises_compare.png&quot; &quot;&quot;&quot; 对嵌有秘密信息的载体图像加噪处理，并保存 &quot;&quot;&quot; def noise(): mod_img = cv2.imread(mod_img_path, cv2.IMREAD_GRAYSCALE) img_copy = mod_img.copy() # 高斯噪声处理后的嵌有秘密信息的载体图像 img_gaussian = ski.random_noise(img_copy, mode=&quot;gaussian&quot;, seed=None, clip=True, mean=0,var=0.05) img_gaussian *= 255 # 椒盐噪声处理后的嵌有秘密信息的载体图像 img_sp = ski.random_noise(img_copy, mode=&quot;s&amp;p&quot;, seed=None, clip=True, amount=0.1) img_sp *= 255 # 保存加噪后的图像 cv2.imwrite(img_gaussian_path, img_gaussian) cv2.imwrite(img_sp_path, img_sp) # 构造对比图 plt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;] # 中文字体设置 plt.rcParams[&#39;axes.unicode_minus&#39;] = False plt.subplot(131) plt.title(&quot;嵌有秘密信息的载体图像&quot;) plt.imshow(mod_img,cmap=&#39;gray&#39;) plt.subplot(132) plt.title(&quot;高斯噪声处理后图像&quot;) plt.imshow(img_gaussian, cmap=&#39;gray&#39;) plt.subplot(133) plt.title(&quot;椒盐噪声处理后的图像&quot;) plt.imshow(img_sp,cmap=&#39;gray&#39;) # 保存对比图 plt.savefig(img_compare_path) # 显示对比图 plt.show()]]></content>
      <categories>
        <category>Security</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「Floodlight x Mininet」从0开始搭建环境]]></title>
    <url>%2F2019%2F11%2F01%2F%E3%80%8CFloodlight%20x%20Mininet%E3%80%8D%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[0x00 前言Floodlight是我在学习SDN过程中最早接触的控制器，相比较于ODL和ONOS，它从安装到导入IDE再到使用都十分容易，官方文档也写的很清楚，对新手极其友好。趁着最近给别人搭建SDN实验环境的机会，总结一下在Ubuntu上如何搭建一个Floodlight x Mininet的SDN环境。 0x01 目录 0x00 前言 0x01 目录 0x02 前期准备 Git安装 JDK安装 Apache Ant安装 0x03 Floodlight安装 源码下载 源码编译 参考 0x04 Mininet安装 源码下载 安装 测试 参考 0x05 测试环境 运行Floodlight 运行Mininet 测试Floodlight和Mininet的连通性 参考 0x06 在Eclipse中运行Floodlight 下载Eclipse 安装Eclipse 运行Eclipse 导入Floodlight源码 配置启动项 运行Floodlight 参考 0x02 前期准备 Git JDK Apache Ant Git安装sudo apt-get install git JDK安装Floodlight v1.2以后使用JDK8，这里选择Oracle的JDK8进行下载，在网上找到Oracle JDK8的linux压缩包进行下载并解压到home目录下，然后配置环境变量 # 配置环境变量 sudo gedit ~/.bashrc # 在.bashrc文件末尾添加下面的内容，JAVA_HOME填JDK目录所在路径 export JAVA_HOME=/home/ubuntu/jdk1.8.0_141 export PATH=${JAVA_HOME}/bin:$PATH # 查看配置是否成功，若显示java的版本，则配置成功 java -version 参考：https://blog.csdn.net/EahanZhang/article/details/88085561 Apache Ant安装sudo apt-get install ant 0x03 Floodlight安装源码下载git clone git://github.com/floodlight/floodlight.git 源码编译cd floodlight ant 显示Build Successful，则说明编译成功 参考https://floodlight.atlassian.net/wiki/spaces/floodlightcontroller/pages/1343544/Installation+Guide#InstallationGuide-Linux 0x04 Mininet安装源码下载git clone git://github.com/mininet/mininet 安装cd mininet/util/ sudo ./install.sh 测试sudo mn --test pingall 参考http://mininet.org/download/ 0x05 测试环境运行Floodlightjava -jar target/floodlight.jar # 该命令要在floodlight目录下运行 运行Mininet新开终端，运行命令创建如下拓扑: h1 - sw1 - h2 sudo mn --controller=remote,ip=127.0.0.1 --mac --switch=ovsk,protocols=OpenFlow13 # 如果Floodlight和Mininet分别部署在不同主机上，则上面的IP地址改为Floodlight所在主机的IP地址 测试Floodlight和Mininet的连通性在运行Mininet的终端上，输入 pingall 如果主机之间能够ping通，说明Floodlight与Mininet之间连通 此时还可以在浏览器中打开Floodlight Web GUI进行验证，若显示交换机、主机个数、拓扑，也能说明Floodlight与Mininet之间成功连通http://localhost:8080/ui/pages/index.html 参考https://floodlight.atlassian.net/wiki/spaces/floodlightcontroller/pages/1343544/Installation+Guide#InstallationGuide-SimulatingANetwork 0x06 在Eclipse中运行Floodlight下载Eclipse 安装Eclipse 运行Eclipse 导入Floodlight源码 配置启动项 运行Floodlight 参考https://floodlight.atlassian.net/wiki/spaces/floodlightcontroller/pages/1343544/Installation+Guide#InstallationGuide-EclipseIDE]]></content>
      <categories>
        <category>SDN</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「ONOS x Mininet」从0开始搭建环境]]></title>
    <url>%2F2019%2F10%2F28%2F%E3%80%8CONOS%20x%20Mininet%E3%80%8D%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[0x00 前言这篇教程是基于ONOS Wiki上教程写的，Wiki上写的还是比较清楚的，但在实践过程中还是踩了一些坑，为了总结写下了这篇教程。本教程的环境搭建是在分配有4核CPU、8G内存、运行ubuntu 18.04 desktop虚拟机上完成的。建议搭建环境的主机至少分配4G内存，如果你使用其他版本的ubuntu，本教程也是适用的。 0x01 目录 0x00 前言 0x01 目录 0x02 前期准备 Git安装 JDK安装 Bazel安装 0x03 ONOS安装 下载ONOS源码 ONOS源码目录改名 ONOS源码编译 运行ONOS控制器 参考 0x04 Mininet安装 源码下载 安装 测试 参考 0x05 测试环境 运行ONOS 运行ONOS Apps 运行Mininet 检查ONOS与Mininet连通性 测试主机之间的连通性 参考 0x06 在IntelliJ IDEA中运行ONOS 下载IntelliJ IDEA 运行IntelliJ IDEA 安装Bazel插件 导入ONOS源码并编译 运行ONOS 参考 0x02 前期准备 Git JDK Bazel Git安装sudo apt-get install git JDK安装ONOS-2.2以后的版本都使用JDK11，这里选择OpenJDK-11进行安装 # 安装OpenJDK-11 sudo apt-get install openjdk-11-jdk # 配置环境变量 sudo gedit /etc/profile # 在profile文件末尾添加下面的内容 export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64 export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH # 查看配置是否成功，若显示openjdk version，则配置成功 java -version 参考：https://blog.csdn.net/EahanZhang/article/details/88085561 Bazel安装Bazel是Google开发的用于编译的工具，在Github上选择bazel-0.27.1-installer-linux-x86_64.sh 进行下载https://github.com/bazelbuild/bazel/releases/tag/0.27.1 注：在我搭建环境的时候，参考的是ONOS Wiki于2019/6/19发布的教程，里面使用的是Bazel 0.27.0。https://wiki.onosproject.org/pages/viewpage.action?pageId=28836246我开始时使用了1.0.0但发现编译失败，于是换成0.27.1，经过测试该版本有效。1.0.0编译失败的问题已于2019/10/16被ONOS官方解决，因此你也可以选择安装最新版本的Bazel。https://github.com/opennetworkinglab/onos/commit/2bf24538098ce3d963d7cbe7da4dfbcfc69285e5 根据Bazel官网安装教程进行安装https://docs.bazel.build/versions/master/install-ubuntu.html#install-with-installer-ubuntu 0x03 ONOS安装下载ONOS源码有以下两种方式，选择一种即可 Git命令下载git clone https://gerrit.onosproject.org/onos Github上下载https://github.com/opennetworkinglab/onos ONOS源码目录改名若选择从Github上下载ZIP压缩包，解压缩后得到onos-master目录，将其改名为onos，方便后续操作 mv onos-master onos ONOS源码编译cd onos bazel build onos 当显示build success，说明编译成功 注：由于网络原因，可能某些依赖下载不下来，导致编译失败，此时可以选择重新运行bazel build onos，直到依赖下载成功 运行ONOS控制器cd onos bazel run onos-local 参考https://wiki.onosproject.org/display/ONOS/Development+Environment+Setup 0x04 Mininet安装源码下载git clone git://github.com/mininet/mininet 安装cd mininet/util/ sudo ./install.sh 测试sudo mn --test pingall 参考http://mininet.org/download/ 0x05 测试环境这里ONOS和Mininet都部署在同一台主机中进行测试，当然你也可以选择分别部署在不同主机上。 运行ONOScd onos bazel run onos-local # 若想要删除ONOS上一次运行时产生的状态信息，则输入： # bazel run onos-local -- clean 注：1.运行ONOS之前，ONOS需要监听的端口号6653和6633有可能被其他进程占用，因此可以先检查一下端口使用情况：sudo netstat -atnp | grep 6653sudo netstat -atnp | grep 6633若除java进程外，有其他进程占用端口号6653或6633，例如：ovs-testcontrol，则杀死进程：sudo kill -9 &lt;进程号&gt;2.ONOS启动后，最好等待窗口中不再弹出INFO信息后，再运行Mininet 运行ONOS AppsONOS开启后，默认不运行Reactive Forwarding和Basic Pipelines应用程序，这样的话ONOS就无法处理2层和3层的转发，Mininet中主机之间无法ping通。因此在运行Mininet前，先运行这两个应用程序。下面介绍两种方法，选择其中一种即可 ONOS Web GUI 浏览器中打开ONOS Web GUI http://localhost:8181/onos/ui/输入用户名：onos 密码：rocks打开应用程序选项卡 运行Basic Pipelines和Reactive Forwarding应用程序 ONOS CLI 新开终端，输入 onos/tools/test/bin/onos localhost 打开ONOS命令行界面 输入命令运行Basic Pipelines和Reactive Forwarding应用程序 app activate org.onosproject.pipelines.basic app activate org.onosproject.fwd 注：Basic Pipelines对应的应用程序ID为org.onosproject.pipelines.basicReactive Forwarding对应的ID为org.onosproject.fwd 运行Mininet新开终端，运行命令创建如下拓扑: h1 - sw1 - h2 sudo mn --controller=remote,ip=127.0.0.1 --mac --switch=ovsk,protocols=OpenFlow13 # 如果ONOS和Mininet分别部署在不同主机上，则上面的IP地址改为ONOS所在主机的IP地址 检查ONOS与Mininet连通性下面介绍两种判断ONOS与Mininet是否连通的方法 若拓扑中显示设备，说明ONOS和Mininet中的交换机成功连接 若ONOS与Mininet连通，运行ONOS的终端会显示下面的INFO信息 测试主机之间的连通性在运行Mininet的终端上，输入 pingall 参考https://wiki.onosproject.org/display/ONOS/Basic+ONOS+Tutorial#BasicONOSTutorial-Setupyourenvironment 0x06 在IntelliJ IDEA中运行ONOS下载IntelliJ IDEAhttps://www.jetbrains.com/idea/download/#section=linux 运行IntelliJ IDEA解压缩IDEA后，cd到IDEA的bin目录，运行IDEA ./idea.sh 安装Bazel插件然后搜索Bazel并安装 导入ONOS源码并编译生成最小的.bazelproject文件 cd onos/tools/dev/bin/ ./onos-gen-bazel-project &gt; /tmp/onos_bazelproject 等待IDEA完成ONOS源码的编译 运行ONOS 参考https://wiki.onosproject.org/pages/viewpage.action?pageId=28836246]]></content>
      <categories>
        <category>SDN</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
