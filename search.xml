<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「OpenFlow」流表项删除DELETE与DELETE_STRICT的区别]]></title>
    <url>%2F2019%2F12%2F27%2F%E3%80%8COpenFlow%E3%80%8D%E6%B5%81%E8%A1%A8%E9%A1%B9%E5%88%A0%E9%99%A4DELETE%E4%B8%8EDELETE_STRICT%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[0x00 目录 0x00 目录 0x01 流表项操作与Flow_Mod消息 0x02 流表项删除DELETE与DELETE_STRICT区别 0x03 POX + Mininet实验验证 实验环境 实验步骤 1.启动POX 2.运行Mininet 3.添加两条流表项 4.DELETE删除流表项 5.添加两条流表项 6.DELETE_STRICT删除流表项 0x04 总结 0x05 参考 0x01 流表项操作与Flow_Mod消息在OpenFlow中，对流表项的操作，例如增加、修改、删除流表项，都是通过控制器下发Flow_Mod消息完成的。Flow_Mod消息的格式如图所示，其中command字段定义了对流表项的操作（增加、修改、删除），而对于修改和删除操作又分为NON_STRICT和STRICT两个版本。 0x02 流表项删除DELETE与DELETE_STRICT区别要想删除流表项，只需要构造command = DELETE或command = DELETE_STRICT的Flow_Mod消息即可，两者的区别如下： DELETE：根据匹配域，删除所有匹配的流表项，意味着可能有多条流表项被删除 DELETE_STRICT：根据匹配域以及优先级，删除特定的流表项，只有一条流表项被删除 例子：假设使用openflow1.0，且openflow交换机流表中只有以下两条流表项12345678910111213141516171819202122232425flow entry1:&#123; prioirity : 42 match : &#123; dl_type : 0x0800 ip_src : 10.0.0.1 ip_dst : 10.0.0.2 &#125; actions : output : &apos;sw1-eth2&apos;&#125;flow entry2:&#123; prioirity : 42 match : &#123; dl_type : 0x0800 ip_src : 10.0.0.1 ip_dst : 10.0.0.2 ip_protocol : 6 tp_dst : 80 &#125; actions : output : &apos;sw1-eth2&apos;&#125; 若控制器下发command = DELETE的Flow_Mod消息123456789101112flow_mod msg:&#123; command : DELETE prioirity : 42 match : &#123; dl_type : 0x0800 ip_src : 10.0.0.1 ip_dst : 10.0.0.2 &#125; actions : output : &apos;sw1-eth2&apos;&#125; 那么openflow交换机将会根据Flow_Mod消息中的匹配域（match）去流表中查找所有匹配的流表项（若流表项中的匹配域描述比Flow_Mod消息中的匹配域更详细，也算查找成功），这里flow entry1和flow entry2都满足，因为它们都含有123456match :&#123; dl_type : 0x0800 ip_src : 10.0.0.1 ip_dst : 10.0.0.2&#125; 因此，两条流表项都会被删除 若控制器下发command = DELETE_STRICT的Flow_Mod消息 123456789101112flow_mod msg:&#123; command : DELETE_STRICT prioirity : 42 match : &#123; dl_type : 0x0800 ip_src : 10.0.0.1 ip_dst : 10.0.0.2 &#125; actions : output : &apos;sw1-eth2&apos;&#125; openflow交换机会根据Flow_Mod消息中的匹配域（match）和优先级（prioirity）去流表中查找特定的流表项，这里只有flow entry1满足条件，因为flow entry2的匹配域多了两个字段12ip_protocol : 6tp_dst : 80 因此只有flow entry1被删除 0x03 POX + Mininet实验验证按照0x02中提到的例子，使用POX和Mininet进行验证 实验环境1234- OpenFlow 1.0 : SDN控制器与openflow交换机之间通信的协议- POX-eel : python实现的SDN控制器，用于构造Flow_Mod消息，并下发至openflow交换机- Mininet 2.3.0d1 : 创建&quot; h1 -- sw1 -- h2 &quot;拓扑- POX与Mininet均部署在同一台运行ubuntu 18.04 LTS的机器上 实验步骤1.启动POX打开终端，输入1234567home/ctz/pox-eel/pox.py openflow.of_01 --address=127.0.0.1 --port=6653 py- home/ctz/pox-eel/pox.py : POX程序的入口- openflow.of_01 : POX的组件，使用openflow1.0进行通信- address : openflow.of_01的参数，定义POX控制器的IP地址，这里定义为本地回环- port : openflow.of_01的参数，定义POX控制器的监听端口，用于监听openflow交换机发来的消息- py：使用POX交互模式，可在终端与POX控制器进行交互，例如构造Flow_Mod消息并发送给交换机 2.运行Mininet另开一终端，输入123456sudo mn --controller=remote,ip=127.0.0.1,port=6653 --mac- controller=remote : mininet连接远程控制器- ip : controller的参数，定义要连接的远程控制器IP地址- port : controller的参数，定义要连接的远程控制器端口- --mac : 从00:00:00:00:00:01开始，按递增序为主机设置MAC地址 3.添加两条流表项在运行POX的终端上，构造两条Flow_Mod消息，用于添加两条流表项到交换机1234567891011121314151617181920212223242526# 以下三条命令在POX控制器同openflow交换机连接上后只需要输入一次import pox.openflow.libopenflow_01 as offrom pox.lib.addresses import IPAddrcore.openflow.connections.keys() # 获取连接的交换机dpid，会在终端上显示dpid# 下发一条流表项（h1 -&gt; h2 基于源目IP）msg = of.ofp_flow_mod()msg.priority = 42msg.command = of.OFPFC_ADDmsg.match.dl_type = 0x800msg.match.nw_src = IPAddr(&quot;10.0.0.1&quot;)msg.match.nw_dst = IPAddr(&quot;10.0.0.2&quot;)msg.actions.append(of.ofp_action_output(port = 2))core.openflow.connections[1].send(msg) # 1为交换机的dpid# 下发一条流表项（h1 -&gt; h2 基于源目IP和TCP目的端口号）msg = of.ofp_flow_mod()msg.priority = 42msg.command = of.OFPFC_ADDmsg.match.dl_type = 0x800msg.match.nw_src = IPAddr(&quot;10.0.0.1&quot;)msg.match.nw_dst = IPAddr(&quot;10.0.0.2&quot;)msg.match.nw_proto = 6msg.match.tp_dst = 80msg.actions.append(of.ofp_action_output(port = 2))core.openflow.connections[1].send(msg) # 1为交换机的dpid 在运行Mininet的终端中输入1dpctl dump-flows 显示交换机中流表信息 4.DELETE删除流表项在运行POX的终端上，构造一条command = DELETE的Flow_Mod消息，删除所有匹配的流表项123456789# 删除所有匹配流表项（h1 -&gt; h2 基于源目IP）msg = of.ofp_flow_mod()msg.priority = 42msg.command = of.OFPFC_DELETEmsg.match.dl_type = 0x800msg.match.nw_src = IPAddr(&quot;10.0.0.1&quot;)msg.match.nw_dst = IPAddr(&quot;10.0.0.2&quot;)msg.actions.append(of.ofp_action_output(port = 2))core.openflow.connections[1].send(msg) # 1为交换机的dpid 如下图所示，交换机根据Flow_Mod消息的match字段查找流表项，所有流表项均被删除 5.添加两条流表项按照步骤3，重新添加两条流表项 6.DELETE_STRICT删除流表项在运行POX的终端上，构造一条command = DELETE_STRICT的Flow_Mod消息，删除指定流表项123456789# 删除所有匹配流表项（h1 -&gt; h2 基于源目IP）msg = of.ofp_flow_mod()msg.priority = 42msg.command = of.OFPFC_DELETE_STRICTmsg.match.dl_type = 0x800msg.match.nw_src = IPAddr(&quot;10.0.0.1&quot;)msg.match.nw_dst = IPAddr(&quot;10.0.0.2&quot;)msg.actions.append(of.ofp_action_output(port = 2))core.openflow.connections[1].send(msg) # 1为交换机的dpid 如下图所示，交换机根据Flow_Mod消息的match字段和priority字段查找流表项，匹配域中含有端口号的流表项被保留，匹配域中不含端口号的流表项被删除 0x04 总结使用Flow_Mod删除流表项时，command = DELETE：删除所有匹配的流表项，只要流表项中Match字段描述 &gt;= Flow_Mod消息中的Match字段（如流表项中Match:{in_port:1,ip_src:10.0.0.1}，Flow_Mod消息中Match:{in_port:1}），则相关流表项均会被删除，因此被删除的流表项可能有多个 DELETE_STRICT：删除特定的流表项，只有同时满足Flow_Mod消息中匹配域以及优先级的流表项会被删除，被删除的流表项只有一个 0x05 参考 openflow控制器POX使用指南 SDN控制器之POX篇]]></content>
      <categories>
        <category>SDN</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「虚拟化」基于virsh实现虚拟机动态迁移]]></title>
    <url>%2F2019%2F12%2F11%2F%E3%80%8C%E8%99%9A%E6%8B%9F%E5%8C%96%E3%80%8D%E5%9F%BA%E4%BA%8Evirsh%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8A%A8%E6%80%81%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[0x00 目录 0x00 目录 0x01 虚拟机迁移方式 静态迁移 动态迁移 基于共享存储 基于本地存储 0x02 虚拟机管理工具 0x03 搭建KVM虚拟化环境 0x04 基于virsh实现虚拟机动态迁移 实验环境 SCP拷贝磁盘文件 virsh动态迁移内存状态 virsh导出配置文件 virsh定义并创建虚拟机 0x05 参考 0x01 虚拟机迁移方式虚拟机迁移一般指虚拟机从一台物理机上迁移到另一台物理机上，迁移的内容包括虚拟机的磁盘文件、配置文件和内存状态。从迁移方式上可分为两种：静态迁移和动态迁移。 静态迁移这种方式又称为离线迁移或线下迁移，指的是虚拟机需要在关机的前提下，完成迁移操作。迁移的过程分为两个阶段： 1.从源物理机上拷贝虚拟机的磁盘文件、配置文件至目的物理机上，可以使用SCP命令完成拷贝工作 2.在目的物理机上，根据拷贝的磁盘文件及配置文件，定义并创建虚拟机 动态迁移这种方式也成为热迁移、在线迁移、线上迁移等，总之就是指虚拟机在运行的情况下，完成从源物理机迁移至目的物理机，在这过程中虚拟机只经历一个很短暂的暂停（虚拟机从源物理机上切换到目的物理机上），用户几乎感受不到服务的中断 根据磁盘文件的存储位置，又可分为以下两类： 基于共享存储 基于本地存储（块存储） 基于共享存储源物理机与目的物理机拥有共享的存储设备，虚拟机的磁盘文件可以被源物理机和目的物理机所访问，因此无需迁移。迁移的过程如下： 1.从源物理机上迁移虚拟机的内存状态到目的物理机1注：迁移结束后，虚拟机就已经在目的物理机上运行了，但是由于目的物理机上无该虚拟机配置文件，若此时关闭虚拟机，就无法找到该虚拟机了，所以需要完成接下来的操作 2.在目的物理机上，根据迁移的内存状态导出虚拟机的配置文件 3.在目的物理机上，根据导出的虚拟机配置文件，定义并创建虚拟机 基于本地存储源物理机与目的物理机都使用独立的存储设备，因此迁移的内容包括虚拟机的磁盘文件、内存状态以及配置文件（从内存状态中导出），迁移的过程如下： 1.从源物理机上拷贝磁盘文件到目的物理机1例如：使用SCP命令，同时要使用相同的目录结构放置虚拟机磁盘文件 2.从物理机上迁移内存状态到目的物理机1例如：使用virsh migrate --live命令，或直接使用virt-manager图形化界面上的迁移操作 1注：迁移结束后，虚拟机就已经在目的物理机上运行了，但是由于目的物理机上无该虚拟机配置文件，若此时关闭虚拟机，就无法找到该虚拟机了，所以需要完成接下来的操作 3.在目的物理机上，根据迁移的内存状态导出虚拟机的配置文件 4.在目的物理机上，根据导出的虚拟机配置文件，定义并创建虚拟机 0x02 虚拟机管理工具 libvirt：用于实现虚拟机管理的开源API，可以实现对虚拟机的创建、删除、分配资源等 virt-manager：基于libvirt实现的虚拟机管理工具，图形化界面，类似VMware Workstation和VirtualBox virsh：基于libvirt实现的虚拟机管理工具，命令行 0x03 搭建KVM虚拟化环境 查看CPU是否支持KVM1egrep &quot;(svm|vmx)&quot; /proc/cpuinfo 如果有输出，则说明CPU支持KVM 安装KVM及相关依赖包 123456sudo apt-get install qemu-kvmsudo apt-get install qemusudo apt-get install virt-managersudo apt-get install virt-viewer sudo apt-get install libvirt-bin sudo apt-get install bridge-utils 启动KVM虚拟系统管理器 1sudo virt-manager 0x04 基于virsh实现虚拟机动态迁移这里采用基于本地存储的动态迁移方式，实现在物理机1上的虚拟机VM1动态迁移到物理机2上。 实验环境1234名称 主机名 IP地址 操作系统 源物理机 kvm-node1 192.168.111.130 ubuntu-16.04.4-desktop目的物理机 kvm-node2 192.168.111.132 ubuntu-16.04.4-desktop虚拟机 VM1 192.168.122.18 ubuntu-16.04.3-server SCP拷贝磁盘文件在源物理机上使用SCP命令拷贝磁盘文件至目的物理机上1sudo scp /var/lib/libvirt/images/node.qcow2 192.168.200.132:/var/lib/libvirt/images /var/lib/libvirt/images：存放虚拟机磁盘文件的目录 node.qcow2：虚拟机VM1的磁盘文件 192.168.200.132：目的物理机IP地址 注1：磁盘文件拷贝到目的物理机上后，要存放在相同的目录结构中 注2：192.168.200.132前若不加用户名，则默认以root身份访问。若kvm@192.168.200.132，则以kvm身份访问 virsh动态迁移内存状态在源物理机上使用virsh命令迁移虚拟机内存状态至目的物理机上 1sudo virsh migrate --live --verbose VM1 qemu+ssh://192.168.200.131/system tcp://192.168.200.131 --unsafe virsh migrate –live：动态迁移 –verbose：显示迁移详情 VM1：需要迁移的虚拟机 qemu+ssh：通过ssh连接到目的物理机上的system实例，具有最大权限来管理远程节点上的虚拟机资源 /system： 以root身份进行状态迁移 tcp：使用tcp连接 192.168.200.131：目的物理机IP地址 –unsafe：跳过安全检测 注：可以指定身份访问远程主机，如远程主机用户名为kvm，则可以使用 qemu+ssh://kvm@192.168.200.131/system，若不添加kvm，默认使用root访问 在目的物理机上，查看虚拟机状态1sudo virsh list --all 可见，虚拟机VM1已经迁移成功并且在目的物理机上运行 virsh导出配置文件在目的物理机上，根据内存状态导出虚拟机VM1配置文件，否则迁移后远程主机没有虚拟机VM1的配置文件，关闭VM1后，VM1就没有了1sudo virsh dumpxml VM1 &gt; /etc/libvirt/qemu/VM1.xml virsh定义并创建虚拟机根据VM1的配置文件定义并创建虚拟机1sudo virsh define /etc/libvirt/qemu/VM1.xml 0x05 参考 Virsh 虚拟机迁移 虚拟机迁移（QEMU动态迁移，Libvirt动（静）态迁移） Ubuntu 16.04 搭建KVM环境]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基于LSB算法实现信息隐藏]]></title>
    <url>%2F2019%2F11%2F23%2F%E5%9F%BA%E4%BA%8ELSB%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%2F</url>
    <content type="text"><![CDATA[0x00 目录 0x00 目录 0x01 问题描述 0x02 LSB算法原理 0x03 LSB算法实现 0x04 实验结果分析 实验数据 实验结果 0x05 健壮性分析 0x06 关键代码 秘密信息嵌入 秘密信息提取 加噪处理 0x01 问题描述基于LSB算法实现在320x240的灰度图像上隐藏秘密信息，并分析LSB算法的健壮性（抗攻击）。 0x02 LSB算法原理该算法包含秘密信息嵌入和提取两部分。嵌入：将二进制表示的秘密信息中的每一位，按照某种顺序（例如先按列再按行，如图1所示）依次存储在载体图像像素值的最低位上。提取：按照嵌入时的顺序依次从嵌有秘密信息的载体图像上提取像素值的最低位，将其组合后即可得到秘密信息。 0x03 LSB算法实现使用Python编码实现基于LSB算法的秘密信息嵌入与提取。秘密信息嵌入算法如图2所示，秘密信息提取算法如图3所示。LSB算法完整代码：https://github.com/Chentingz/LSB-Steganography 0x04 实验结果分析实验数据 秘密信息：”secret text is hidden in image using LSB algorithm\n2019.11.21” 原始载体图像名：raw_img.bmp 原始载体图像大小：320 x 240 原始载体图像通道数：单通道（灰度图像） 原始载体图像：见图4 实验结果 嵌入算法：按照图2的算法从文件中读取秘密信息后嵌入到原始载体图像中，从图5可见，嵌入前后的载体图像无明显变化。 提取算法：按照图3算法对嵌入秘密信息的载体图像提取出秘密信息，由图6可见，提取结果与嵌入前的秘密信息一致。 0x05 健壮性分析对嵌有秘密信息的载体图像分别采用高斯噪声和椒盐噪声处理，然后提取秘密信息，观察秘密信息是否遭到破坏，噪声处理前后的图像对比如图7所示。 采用图3中的提取算法，分别对高斯噪声和椒盐噪声处理过的图像提取信息，提取结果如图8所示，可见对基于LSB嵌入秘密信息的图像进行噪声处理后，秘密信息将遭到不同程度的破坏，LSB算法抗攻击性差。 0x06 关键代码秘密信息嵌入1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from PIL import Imageeof_str = &quot;00000000&quot;&quot;&quot;&quot;将秘密信息嵌入到载体图像中首先将秘密信息转换成二进制字符串，如&quot;a&quot; -&gt; &quot;0110 0001&quot;在二进制字符串的末尾添加两个0x0000的ASCII码作为结束标志，如&quot;0110 0001&quot; -&gt; &quot;0110 0001 0000 0000 0000 0000&quot;按照图像从上到下，从左到右的顺序，将串的每一位依次插入到像素的最低位中，每一个像素用一个字节表示@param text: string类型的秘密信息@param raw_img: image类型原始载体图像@return: image类型嵌入秘密信息后的图像&quot;&quot;&quot;def insert_text_to_image(text, raw_img): mod_img = raw_img.copy() width = mod_img.size[0] height = mod_img.size[1] binstr = text2binarystring(text) binstr += eof_str + eof_str i = 0 for w in range(width): for h in range(height): if i == len(binstr): break value = mod_img.getpixel((w,h)) value = mod_lsb(value, binstr[i]) mod_img.putpixel((w,h), value) i=i+1 return mod_img&quot;&quot;&quot;将秘密信息转换成二进制串先将字符转换成对应的ASCII码，然后转二进制，最后8位对齐，不足的前面用0填充@param text: string类型表示的秘密信息@return: string类型表示的二进制串&quot;&quot;&quot;def text2binarystring(text): binstr = &quot;&quot; for ch in text : # ord(ch): 将ch转换成十进制数 bin():转换成0b开头的二进制字符串 zfill:返回指定长度字符串，不足的前面填充0 binstr += bin(ord(ch)).replace(&apos;0b&apos;, &apos;&apos;).zfill(8) return binstr&quot;&quot;&quot;将value的最低位替换成bit,返回修改后的value@param value: int类型表示的像素值@param bit: string类型表示的嵌入位@return: int类型表示的修改后的像素值&quot;&quot;&quot;def mod_lsb(value, bit): str = bin(value).replace(&apos;0b&apos;, &apos;&apos;).zfill(8) lsb = str[len(str)-1] if lsb != bit : str = str[0:len(str)-1] + bit return int(str, 2) 秘密信息提取1234567891011121314151617181920212223242526272829303132333435363738from PIL import Imageeof = chr(int(eof_str, 2))&quot;&quot;&quot;从图像中提取秘密信息，返回string类型的秘密信息@param mod_img: 嵌入秘密信息后的图像@return: string类型表示的秘密信息&quot;&quot;&quot;def get_text_from_image(mod_img): width = mod_img.size[0] height = mod_img.size[1] bytestr = &quot;&quot; text = &quot;&quot; countEOF = 0 for w in range(width): for h in range(height): value = mod_img.getpixel((w,h)) bytestr += get_lsb(value) if len(bytestr) == 8 : # 转换成ASCII码 # 例：&quot;0110 0001&quot; -&gt; 97 -&gt; &apos;a&apos; ch = chr(int(bytestr, 2)) if ch == eof : countEOF = countEOF + 1 if countEOF == 2 : break text += ch bytestr = &quot;&quot; return text&quot;&quot;&quot;返回像素值的lsb@param value: int类型表示的像素值@return: string类型表示的像素值最低位&quot;&quot;&quot;def get_lsb(value): str = bin(value).replace(&apos;0b&apos;, &apos;&apos;).zfill(8) lsb = str[len(str)-1] return lsb 加噪处理123456789101112131415161718192021222324252627282930313233343536373839404142import cv2import matplotlib.pyplot as pltimport skimage.util as skiimport LSBfrom PIL import Imagemod_img_path = &quot;./test/mod_img.bmp&quot;img_gaussian_path = &quot;./test/img_gaussian.bmp&quot;img_sp_path = &quot;./test/img_sp.bmp&quot;img_mod_and_noises_compare_path = &quot;./test/img_mod_and_noises_compare.png&quot;&quot;&quot;&quot;对嵌有秘密信息的载体图像加噪处理，并保存&quot;&quot;&quot;def noise(): mod_img = cv2.imread(mod_img_path, cv2.IMREAD_GRAYSCALE) img_copy = mod_img.copy() # 高斯噪声处理后的嵌有秘密信息的载体图像 img_gaussian = ski.random_noise(img_copy, mode=&quot;gaussian&quot;, seed=None, clip=True, mean=0,var=0.05) img_gaussian *= 255 # 椒盐噪声处理后的嵌有秘密信息的载体图像 img_sp = ski.random_noise(img_copy, mode=&quot;s&amp;p&quot;, seed=None, clip=True, amount=0.1) img_sp *= 255 # 保存加噪后的图像 cv2.imwrite(img_gaussian_path, img_gaussian) cv2.imwrite(img_sp_path, img_sp) # 构造对比图 plt.rcParams[&apos;font.sans-serif&apos;]=[&apos;SimHei&apos;] # 中文字体设置 plt.rcParams[&apos;axes.unicode_minus&apos;] = False plt.subplot(131) plt.title(&quot;嵌有秘密信息的载体图像&quot;) plt.imshow(mod_img,cmap=&apos;gray&apos;) plt.subplot(132) plt.title(&quot;高斯噪声处理后图像&quot;) plt.imshow(img_gaussian, cmap=&apos;gray&apos;) plt.subplot(133) plt.title(&quot;椒盐噪声处理后的图像&quot;) plt.imshow(img_sp,cmap=&apos;gray&apos;) # 保存对比图 plt.savefig(img_compare_path) # 显示对比图 plt.show()]]></content>
      <categories>
        <category>Security</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「Floodlight x Mininet」从0开始搭建环境]]></title>
    <url>%2F2019%2F11%2F01%2F%E3%80%8CFloodlight%20x%20Mininet%E3%80%8D%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[0x00 前言Floodlight是我在学习SDN过程中最早接触的控制器，相比较于ODL和ONOS，它从安装到导入IDE再到使用都十分容易，官方文档也写的很清楚，对新手极其友好。趁着最近给别人搭建SDN实验环境的机会，总结一下在Ubuntu上如何搭建一个Floodlight x Mininet的SDN环境。 0x01 目录 0x00 前言 0x01 目录 0x02 前期准备 Git安装 JDK安装 Apache Ant安装 0x03 Floodlight安装 源码下载 源码编译 参考 0x04 Mininet安装 源码下载 安装 测试 参考 0x05 测试环境 运行Floodlight 运行Mininet 测试Floodlight和Mininet的连通性 参考 0x06 在Eclipse中运行Floodlight 下载Eclipse 安装Eclipse 运行Eclipse 导入Floodlight源码 配置启动项 运行Floodlight 参考 0x02 前期准备 Git JDK Apache Ant Git安装1sudo apt-get install git JDK安装Floodlight v1.2以后使用JDK8，这里选择Oracle的JDK8进行下载，在网上找到Oracle JDK8的linux压缩包进行下载并解压到home目录下，然后配置环境变量123456789# 配置环境变量sudo gedit ~/.bashrc# 在.bashrc文件末尾添加下面的内容，JAVA_HOME填JDK目录所在路径export JAVA_HOME=/home/ubuntu/jdk1.8.0_141export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH# 查看配置是否成功，若显示java的版本，则配置成功java -version 参考：https://blog.csdn.net/EahanZhang/article/details/88085561 Apache Ant安装1sudo apt-get install ant 0x03 Floodlight安装源码下载1git clone git://github.com/floodlight/floodlight.git 源码编译12cd floodlightant 显示Build Successful，则说明编译成功 参考https://floodlight.atlassian.net/wiki/spaces/floodlightcontroller/pages/1343544/Installation+Guide#InstallationGuide-Linux 0x04 Mininet安装源码下载1git clone git://github.com/mininet/mininet 安装12cd mininet/util/sudo ./install.sh 测试1sudo mn --test pingall 参考http://mininet.org/download/ 0x05 测试环境运行Floodlight123java -jar target/floodlight.jar# 该命令要在floodlight目录下运行 运行Mininet新开终端，运行命令创建如下拓扑: h1 - sw1 - h2 123sudo mn --controller=remote,ip=127.0.0.1 --mac --switch=ovsk,protocols=OpenFlow13# 如果Floodlight和Mininet分别部署在不同主机上，则上面的IP地址改为Floodlight所在主机的IP地址 测试Floodlight和Mininet的连通性在运行Mininet的终端上，输入1pingall 如果主机之间能够ping通，说明Floodlight与Mininet之间连通 此时还可以在浏览器中打开Floodlight Web GUI进行验证，若显示交换机、主机个数、拓扑，也能说明Floodlight与Mininet之间成功连通http://localhost:8080/ui/pages/index.html 参考https://floodlight.atlassian.net/wiki/spaces/floodlightcontroller/pages/1343544/Installation+Guide#InstallationGuide-SimulatingANetwork 0x06 在Eclipse中运行Floodlight下载Eclipse 安装Eclipse 运行Eclipse 导入Floodlight源码 配置启动项 运行Floodlight 参考https://floodlight.atlassian.net/wiki/spaces/floodlightcontroller/pages/1343544/Installation+Guide#InstallationGuide-EclipseIDE]]></content>
      <categories>
        <category>SDN</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「ONOS x Mininet」从0开始搭建环境]]></title>
    <url>%2F2019%2F10%2F28%2F%E3%80%8CONOS%20x%20Mininet%E3%80%8D%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[0x00 前言这篇教程是基于ONOS Wiki上教程写的，Wiki上写的还是比较清楚的，但在实践过程中还是踩了一些坑，为了总结写下了这篇教程。本教程的环境搭建是在分配有4核CPU、8G内存、运行ubuntu 18.04 desktop虚拟机上完成的。建议搭建环境的主机至少分配4G内存，如果你使用其他版本的ubuntu，本教程也是适用的。 0x01 目录 0x00 前言 0x01 目录 0x02 前期准备 Git安装 JDK安装 Bazel安装 0x03 ONOS安装 下载ONOS源码 ONOS源码目录改名 ONOS源码编译 运行ONOS控制器 参考 0x04 Mininet安装 源码下载 安装 测试 参考 0x05 测试环境 运行ONOS 运行ONOS Apps 运行Mininet 检查ONOS与Mininet连通性 测试主机之间的连通性 参考 0x06 在IntelliJ IDEA中运行ONOS 下载IntelliJ IDEA 运行IntelliJ IDEA 安装Bazel插件 导入ONOS源码并编译 运行ONOS 参考 0x02 前期准备 Git JDK Bazel Git安装1sudo apt-get install git JDK安装ONOS-2.2以后的版本都使用JDK11，这里选择OpenJDK-11进行安装1234567891011121314# 安装OpenJDK-11sudo apt-get install openjdk-11-jdk# 配置环境变量sudo gedit /etc/profile# 在profile文件末尾添加下面的内容export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH# 查看配置是否成功，若显示openjdk version，则配置成功java -version 参考：https://blog.csdn.net/EahanZhang/article/details/88085561 Bazel安装Bazel是Google开发的用于编译的工具，在Github上选择bazel-0.27.1-installer-linux-x86_64.sh 进行下载https://github.com/bazelbuild/bazel/releases/tag/0.27.1 注：在我搭建环境的时候，参考的是ONOS Wiki于2019/6/19发布的教程，里面使用的是Bazel 0.27.0。https://wiki.onosproject.org/pages/viewpage.action?pageId=28836246我开始时使用了1.0.0但发现编译失败，于是换成0.27.1，经过测试该版本有效。1.0.0编译失败的问题已于2019/10/16被ONOS官方解决，因此你也可以选择安装最新版本的Bazel。https://github.com/opennetworkinglab/onos/commit/2bf24538098ce3d963d7cbe7da4dfbcfc69285e5 根据Bazel官网安装教程进行安装https://docs.bazel.build/versions/master/install-ubuntu.html#install-with-installer-ubuntu 0x03 ONOS安装下载ONOS源码有以下两种方式，选择一种即可 Git命令下载 1git clone https://gerrit.onosproject.org/onos Github上下载https://github.com/opennetworkinglab/onos ONOS源码目录改名若选择从Github上下载ZIP压缩包，解压缩后得到onos-master目录，将其改名为onos，方便后续操作1mv onos-master onos ONOS源码编译12cd onosbazel build onos 当显示build success，说明编译成功 注：由于网络原因，可能某些依赖下载不下来，导致编译失败，此时可以选择重新运行bazel build onos，直到依赖下载成功 运行ONOS控制器12cd onosbazel run onos-local 参考https://wiki.onosproject.org/display/ONOS/Development+Environment+Setup 0x04 Mininet安装源码下载1git clone git://github.com/mininet/mininet 安装12cd mininet/util/sudo ./install.sh 测试1sudo mn --test pingall 参考http://mininet.org/download/ 0x05 测试环境这里ONOS和Mininet都部署在同一台主机中进行测试，当然你也可以选择分别部署在不同主机上。 运行ONOS12345cd onosbazel run onos-local# 若想要删除ONOS上一次运行时产生的状态信息，则输入：# bazel run onos-local -- clean 注：1.运行ONOS之前，ONOS需要监听的端口号6653和6633有可能被其他进程占用，因此可以先检查一下端口使用情况：sudo netstat -atnp | grep 6653sudo netstat -atnp | grep 6633若除java进程外，有其他进程占用端口号6653或6633，例如：ovs-testcontrol，则杀死进程：sudo kill -9 &lt;进程号&gt;2.ONOS启动后，最好等待窗口中不再弹出INFO信息后，再运行Mininet 运行ONOS AppsONOS开启后，默认不运行Reactive Forwarding和Basic Pipelines应用程序，这样的话ONOS就无法处理2层和3层的转发，Mininet中主机之间无法ping通。因此在运行Mininet前，先运行这两个应用程序。下面介绍两种方法，选择其中一种即可 ONOS Web GUI 浏览器中打开ONOS Web GUI http://localhost:8181/onos/ui/输入用户名：onos 密码：rocks打开应用程序选项卡 运行Basic Pipelines和Reactive Forwarding应用程序 ONOS CLI 新开终端，输入 1onos/tools/test/bin/onos localhost 打开ONOS命令行界面 输入命令运行Basic Pipelines和Reactive Forwarding应用程序 12app activate org.onosproject.pipelines.basicapp activate org.onosproject.fwd 注：Basic Pipelines对应的应用程序ID为org.onosproject.pipelines.basicReactive Forwarding对应的ID为org.onosproject.fwd 运行Mininet新开终端，运行命令创建如下拓扑: h1 - sw1 - h2 123sudo mn --controller=remote,ip=127.0.0.1 --mac --switch=ovsk,protocols=OpenFlow13# 如果ONOS和Mininet分别部署在不同主机上，则上面的IP地址改为ONOS所在主机的IP地址 检查ONOS与Mininet连通性下面介绍两种判断ONOS与Mininet是否连通的方法 若拓扑中显示设备，说明ONOS和Mininet中的交换机成功连接 若ONOS与Mininet连通，运行ONOS的终端会显示下面的INFO信息 测试主机之间的连通性在运行Mininet的终端上，输入1pingall 参考https://wiki.onosproject.org/display/ONOS/Basic+ONOS+Tutorial#BasicONOSTutorial-Setupyourenvironment 0x06 在IntelliJ IDEA中运行ONOS下载IntelliJ IDEAhttps://www.jetbrains.com/idea/download/#section=linux 运行IntelliJ IDEA解压缩IDEA后，cd到IDEA的bin目录，运行IDEA1./idea.sh 安装Bazel插件然后搜索Bazel并安装 导入ONOS源码并编译生成最小的.bazelproject文件12cd onos/tools/dev/bin/./onos-gen-bazel-project &gt; /tmp/onos_bazelproject 等待IDEA完成ONOS源码的编译 运行ONOS 参考https://wiki.onosproject.org/pages/viewpage.action?pageId=28836246]]></content>
      <categories>
        <category>SDN</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
