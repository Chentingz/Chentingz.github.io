<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「Floodlight」链路丢包率测量]]></title>
    <url>%2F2020%2F02%2F22%2F%E3%80%8CFloodlight%E3%80%8D%E9%93%BE%E8%B7%AF%E4%B8%A2%E5%8C%85%E7%8E%87%E6%B5%8B%E9%87%8F%2F</url>
    <content type="text"><![CDATA[0x00 目录 0x00 目录 0x01 前言 0x02 基于OpenFlow的Port-Stats消息测量链路丢包率原理 0x03 链路丢包率测量模块设计 StatisticsCollector模块分析 linkdiscovery包分析 链路丢包率测量模块设计思路 0x04 链路丢包率测量模块实现 0x05 Mininet搭建拓扑测量链路丢包率 0x06 参考 0x01 前言Floodlight控制器中StatisticsCollector模块已经实现了用Port-Stats消息测量OpenFlow交换机端口的吞吐量，本文通过对StatisticsCollector模块进行扩展，并用Mininet搭建拓扑，实现在SDN网络中测量中链路丢包率。 0x02 基于OpenFlow的Port-Stats消息测量链路丢包率原理请参考基于OpenFlow消息的网络测量方法 0x03 链路丢包率测量模块设计StatisticsCollector模块分析如图1所示，src/main/java目录下，net.floodlightcontroller.statistics包中StatisticsCollector.java文件定义了StatisticsCollector模块。该模块每隔10s创建多个线程轮询拓扑中所有交换机以获取Port-Stats响应消息，通过Port-Stats响应消息中的rx_bytes、tx_bytes、duration_sec和duration_nsec四个字段来测量端口吞吐量。因此，可以在该模块获取Port-Stats响应消息基础上，添加代码以实现链路丢包率的测量。 StatisticsCollector模块中的PortStatsCollector内部类实现了端口吞吐量测量，如图2所示，它通过调用getSwitchStatistics方法来获取所有交换机的统计信息，然后根据上一次查询的Port-Stats消息以及本次查询的Port-Stats消息，分别提取rx_bytes、tx_bytes、duration_sec和duration_nsec字段，通过公式（2）和公式（3）即可计算出交换机端口发送吞吐量或接收吞吐量。 StatisticsCollector模块中的getSwitchStatistics方法有两个重载版本，分别是123protected List&lt;OFStatsReply&gt; getSwitchStatistics(DatapathId switchId, OFStatsType statsType)Map&lt;DatapathId, List&lt;OFStatsReply&gt;&gt; getSwitchStatistics(Set&lt;DatapathId&gt; dpids, OFStatsType statsType) 其中前者的作用是获取单台交换机的统计消息（以Stats结尾的消息，如Port-Stats消息）。该方法的实现如图3所示，首先构造一个Stats请求消息根据交换机DPID发送给指定交换机，然后接收交换机返回的Stats响应消息，并保存在List列表中。 后者的作用是创建多个线程，每个线程通过调用getSwitchStatistics(DatapathId switchId, OFStatsType statsType)方法负责获取一台交换机的统计消息，从而实现并行获取网络中所有交换机的统计消息。该方法的实现如图4所示。 linkdiscovery包分析如图5所示，src/main/java目录下，net.floodlightcontroller.linkdiscovery包中包含了链路的定义Link.java，可获取拓扑中所有链路的接口ILinkDiscoveryService.java。 如图6所示，在Floodlight中，由起始交换机DPID和端口ID以及终点交换机DPID和端口ID定义一条链路，可见链路是指交换机之间的连接关系，不包含主机与交换机之间的连接关系，同时链路是有方向的。 如图7所示，ILinkDiscoveryService接口中定义了许多获取链路、链路类型等方法，其中1public Map&lt;Link, LinkInfo&gt; getLinks(); 方法可用于获取拓扑中所有的链路。 链路丢包率测量模块设计思路链路丢包率测量模块将在StatisticsCollector模块的基础上实现，其设计思路： 12345a.通过getSwitchStatistics方法发起查询，获取所有交换机的Port-Stats消息，并根据交换机DPID和其Port-Stats消息的映射关系存储在replies哈希表中b.通过ILinkDiscoveryService接口获取所有链路，存储在links集合中c.循环遍历links，分别从previousReplies和replies中获取上一次查询以及本次查询的Port-Stats消息，并从中提取tx_packets、rx_packets字段根据公式（1）计算当前遍历的链路的丢包率，将链路和链路丢包率的映射关系存储在linkLossResults哈希表中d.用replies更新previousRepliese.根据linkLossResults打印链路丢包率 0x04 链路丢包率测量模块实现 在Eclipse中，src/main/java目录下，net.floodlightcontroller.statistics包中新建一个LinkLoss类，用于存储某条链路在查询间隙接收、发送数据包个数，以及丢包率，该类的实现代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class LinkLoss &#123; private Link link; // 链路 = 起点（srcDPID + srcPort） + 终点（dstDPID + dstPort） private U64 txPackets; // 两次查询间隙，链路起点发送的数据包个数 private U64 rxPackets; // 两次查询间隙，链路终点接收的数据包个数 private U64 linkLoss; // 两次查询间隙，链路丢包率 public LinkLoss() &#123; super(); &#125; public LinkLoss(Link link, U64 txPackets, U64 rxPackets,U64 linkLoss) &#123; super(); this.link = link; this.txPackets = txPackets; this.rxPackets = rxPackets; this.linkLoss = linkLoss; &#125; public Link getLink() &#123; return link; &#125; public void setLink(Link link) &#123; this.link = link; &#125; public U64 getRxPackets() &#123; return rxPackets; &#125; public void setRxPackets(U64 rxPackets) &#123; this.rxPackets = rxPackets; &#125; public U64 getTxPackets() &#123; return txPackets; &#125; public void setTxPackets(U64 txPackets) &#123; this.txPackets = txPackets; &#125; public U64 getLinkLoss() &#123; return linkLoss; &#125; public void setLinkLoss(U64 linkLoss) &#123; this.linkLoss = linkLoss; &#125; @Override public String toString() &#123; return "(" + link.getSrc() + "/" + link.getSrcPort() + ") -&gt; (" + link.getDst() + "/" + link.getDstPort() + ") TxPackets:" + txPackets.getValue() + " RxPackets:" + rxPackets.getValue() + " LinkLoss:" + linkLoss.getValue() + "%"; &#125;&#125; 打开net.floodlightcontroller.statistics包中StatisticsCollector.java文件，在StatisticsCollector类中添加下列属性: 1234567891011121314// 获取链路的接口private static ILinkDiscoveryService linkDiscoveryService;// 保存上一次查询的Port-Stats消息private static HashMap&lt;Link, List&lt;OFPortStatsEntry&gt;&gt; priorLinkPortStats = new HashMap&lt;Link, List&lt;OFPortStatsEntry&gt;&gt;(); // 保存本次查询的Port-Stats消息private static HashMap&lt;Link, List&lt;OFPortStatsEntry&gt;&gt; linkPortStats = new HashMap&lt;Link, List&lt;OFPortStatsEntry&gt;&gt;();// 保存上一次查询与本次查询间隙的链路丢包率private static HashMap&lt;Link, LinkLoss&gt; linkLossResults = new HashMap&lt;Link, LinkLoss&gt;();//保存查询次数private static int lookupCounter = 0; 为了保证ILinkDiscoveryService接口能够正常使用，还需要添加接口的依赖并进行初始化，StatisticsCollector.java的相应方法中添加下列带有ADD注释的代码： 12345678910111213141516171819202122232425262728293031323334353637383940@Overridepublic Collection&lt;Class&lt;? extends IFloodlightService&gt;&gt; getModuleDependencies() &#123; Collection&lt;Class&lt;? extends IFloodlightService&gt;&gt; l = new ArrayList&lt;Class&lt;? extends IFloodlightService&gt;&gt;(); l.add(IOFSwitchService.class); l.add(IThreadPoolService.class); l.add(IRestApiService.class); // ADD:添加依赖 l.add(ILinkDiscoveryService.class); return l;&#125;@Overridepublic void init(FloodlightModuleContext context) throws FloodlightModuleException &#123; switchService = context.getServiceImpl(IOFSwitchService.class); threadPoolService = context.getServiceImpl(IThreadPoolService.class); restApiService = context.getServiceImpl(IRestApiService.class); // ADD:初始化接口 linkDiscoveryService = context.getServiceImpl(ILinkDiscoveryService.class); Map&lt;String, String&gt; config = context.getConfigParams(this); if (config.containsKey(ENABLED_STR)) &#123; try &#123; isEnabled = Boolean.parseBoolean(config.get(ENABLED_STR).trim()); &#125; catch (Exception e) &#123; log.error("Could not parse '&#123;&#125;'. Using default of &#123;&#125;", ENABLED_STR, isEnabled); &#125; &#125; log.info("Statistics collection &#123;&#125;", isEnabled ? "enabled" : "disabled"); if (config.containsKey(INTERVAL_PORT_STATS_STR)) &#123; try &#123; portStatsInterval = Integer.parseInt(config.get(INTERVAL_PORT_STATS_STR).trim()); &#125; catch (Exception e) &#123; log.error("Could not parse '&#123;&#125;'. Using default of &#123;&#125;", INTERVAL_PORT_STATS_STR, portStatsInterval); &#125; &#125; log.info("Port statistics collection interval set to &#123;&#125;s", portStatsInterval);&#125; StatisticsCollector.java文件中将原来用于测量端口吞吐量的内部类PortStatsCollector的实现逻辑替换成以下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107Private class PortStatsCollector implements Runnable &#123; @Override // 计算丢包率 public void run() &#123; // 发起查询，获取所有交换机的Port-Stats消息，存储在replies中 Map&lt;DatapathId, List&lt;OFStatsReply&gt;&gt; replies = getSwitchStatistics(switchService.getAllSwitchDpids(), OFStatsType.PORT); log.info("Replies Num:" + replies.size()); // 查询次数计数器加一 ++lookupCounter; log.info("Lookup Counter:" + lookupCounter); // 获取所有链路 Set&lt;Link&gt; links = linkDiscoveryService.getLinks().keySet(); log.info("Total Links:" + links.size()); // 遍历链路 for(Link l : links) &#123; log.info(l.toString()); // 从replies中获取本次查询中，与当前链路起点有关的Port-Stats消息，存储到HashMap&lt;Link, List&lt;OFPortStatsEntry&gt;&gt; linkPortStats中 List&lt;OFStatsReply&gt; srcPortStatsReplies = replies.get(l.getSrc()); boolean breakFlag = false; for(OFStatsReply r : srcPortStatsReplies) &#123; OFPortStatsReply psr = (OFPortStatsReply) r; for (OFPortStatsEntry pse : psr.getEntries()) &#123; if(pse.getPortNo().equals(l.getSrcPort())) &#123; List&lt;OFPortStatsEntry&gt; tmpList = linkPortStats.get(l); if(tmpList == null || tmpList.isEmpty()) &#123; tmpList = new ArrayList&lt;OFPortStatsEntry&gt;(); tmpList.add(pse); &#125; else &#123; tmpList.add(pse); &#125; linkPortStats.put(l, tmpList); breakFlag = true; break; &#125; &#125; if(breakFlag) break; &#125; // 从replies中获取本次查询中，与当前链路终点有关的Port-Stats消息，存储到HashMap&lt;Link, List&lt;OFPortStatsEntry&gt;&gt; linkPortStats中 List&lt;OFStatsReply&gt; dstPortStatsReplies = replies.get(l.getDst()); breakFlag = false; for(OFStatsReply r : dstPortStatsReplies) &#123; OFPortStatsReply psr = (OFPortStatsReply) r; for (OFPortStatsEntry pse : psr.getEntries()) &#123; if(pse.getPortNo().equals(l.getDstPort())) &#123; List&lt;OFPortStatsEntry&gt; tmpList = linkPortStats.get(l); if(tmpList == null || tmpList.isEmpty()) &#123; tmpList = new ArrayList&lt;OFPortStatsEntry&gt;(); tmpList.add(pse); &#125; else &#123; tmpList.add(pse); &#125; linkPortStats.put(l, tmpList); breakFlag = true; break; &#125; &#125; if(breakFlag) break; &#125; // 若只有一次查询，则不计算丢包率 if(lookupCounter == 1) &#123; continue; &#125; // 获取上一次查询和本次查询的该链路的Port-Stats消息，计算该链路丢包率 OFPortStatsEntry srcPriorPSE = priorLinkPortStats.get(l).get(0); OFPortStatsEntry dstPriorPSE = priorLinkPortStats.get(l).get(1); OFPortStatsEntry srcCurrentPSE = linkPortStats.get(l).get(0); OFPortStatsEntry dstCurrentPSE = linkPortStats.get(l).get(1); U64 linkLoss = U64.ZERO; // 丢包率范围：[0,1],linkloss中存储百分比 if(srcPriorPSE != null &amp;&amp; dstPriorPSE != null &amp;&amp; srcCurrentPSE != null &amp;&amp; dstCurrentPSE != null) &#123; U64 srcTxPackets = U64.ofRaw(srcCurrentPSE.getTxPackets().getValue() - srcPriorPSE.getTxPackets().getValue() ); U64 dstRxPackets = U64.ofRaw(dstCurrentPSE.getRxPackets().getValue() - dstPriorPSE.getRxPackets().getValue() ); if(srcTxPackets.equals(U64.ZERO)) // 上一次查询与本次查询的间隙内，该链路上无数据包发送 linkLoss = U64.ZERO; else if(srcTxPackets.compareTo(dstRxPackets) &lt; 0) linkLoss = U64.ofRaw(100); else if(!srcTxPackets.equals(U64.ZERO)) linkLoss = U64.ofRaw(100 - (dstRxPackets.getValue() * 100 / srcTxPackets.getValue())) ; linkLossResults.put(l, new LinkLoss(l, srcTxPackets, dstRxPackets, linkLoss)); &#125;//if &#125;//for // 更新priorLinkPortStats，并清空本次查询结果linkPortStats priorLinkPortStats = new HashMap&lt;Link, List&lt;OFPortStatsEntry&gt;&gt;(linkPortStats); linkPortStats.clear(); // 打印所有链路丢包率 if(!linkLossResults.isEmpty()) &#123; String result = ""; for(Link l : linkLossResults.keySet()) &#123; result += linkLossResults.get(l).toString() + "\n"; &#125; log.info(result); &#125; &#125;//function&#125;//class 在Floodlight源码src/main/resources目录下的floodlightdefault.properties文件中，修改代码设置StatisticsCollector模块随着Floodlight控制器一起启动。 1net.floodlightcontroller.statistics.StatisticsCollector.enable=TRUE 0x05 Mininet搭建拓扑测量链路丢包率假设拓扑如图8所示，使用带有链路丢包率测量模块的Floodlight控制器测量拓扑中所有交换机之间链路的丢包率。 新开终端编译并启动Floodlight控制器。 cd floodlight ant java –jar target/floodlight.jar 新开终端启动Mininet，构造如图8所示的测试拓扑。 sudo mn --controller=remote,ip=127.0.0.1 --switch ovsk,protocols=OpenFlow13 --mac --topo=linear,2 在Mininet交互模式下打开主机H1的终端。 mininet &gt; xterm h1 在主机H1终端上使用hping3发包工具以500pps（packet per second）的速率发送数据包给主机H2，Floodlight控制器终端显示测量的S1与S2之间链路丢包率结果如图9所示。 hping3 –i u2000 10.0.0.2 0x06 参考 基于OpenFlow消息的网络测量方法]]></content>
      <categories>
        <category>SDN</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基于OpenFlow消息的网络测量方法]]></title>
    <url>%2F2020%2F02%2F12%2F%E5%9F%BA%E4%BA%8EOpenFlow%E6%B6%88%E6%81%AF%E7%9A%84%E7%BD%91%E7%BB%9C%E6%B5%8B%E9%87%8F%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[0x00 目录 0x00 目录 0x01 前言 0x02 基于OpenFlow的Port-Stats消息测量丢包率和吞吐量 Port-Stats消息 测量丢包率 测量吞吐量 0x03 基于OpenFlow的Packet-Out消息和Packet-In消息测量拓扑和时延 Packet-Out消息 Packet-In消息 测量拓扑 测量时延 0x04 参考 0x01 前言网络运行情况需要通过链路丢包率、时延、吞吐量等网络性能指标来体现。本文总结了SDN中，利用OpenFlow消息去测量网络拓扑、链路丢包率和时延、以及交换机端口吞吐量的方法。 0x02 基于OpenFlow的Port-Stats消息测量丢包率和吞吐量OpenFlow交换机中维护了多种计数器，会对每张流表、每条流表项、每个物理端口、每条队列等进行信息统计。通过OpenFlow统计消息，SDN控制器可以周期性的查询并获取OpenFlow交换机的计数器统计信息，这些信息可用于测量丢包率和吞吐量，这种通过查询的测量方法属于被动测量。 OpenFlow统计消息包含Port-Stats消息、Flow-Stats消息、Aggregate-Stats消息、Queue-Stats消息、Group-Stats消息、Meter-Stats消息和Table-Stats消息，这些消息可用于获取OpenFlow交换机中指定计数器的统计信息，如Port-Stats消息可以用于获取指定OpenFlow交换机物理端口的统计信息，Flow-Stats消息用于获取指定流表项的统计信息。 Port-Stats消息测量链路丢包率和端口吞吐量需要用到Port-Stats消息。 Port-Stats消息具体有两种，一种是Port-Stats-Request消息，用于SDN控制器请求交换机端口统计信息，另一种是Port-Stats-Reply消息，交换机用它来应答SDN控制器，具体过程是交换机读取指定端口的计数器，获得端口的统计信息并将其封装在该消息中，然后将消息发送给SDN控制器。在OpenFlow 1.3中，Port-Stats-Request和Port-Stats-Reply消息格式如图1和图2所示，SDN控制器可以从Port-Stats-Reply消息中获取到交换机端口的接收/发送数据包个数（rx_packets/tx_packets），接收/发送字节数（rx_bytes/tx_bytes），丢弃数据包个数(rx_dropped/tx_dropped)，冲突次数（collisions），端口生存时间（duration_sec和duration_nsec）等统计信息，这些信息将用于计算链路丢包率、端口吞吐量。 测量丢包率丢包率是指一段时间内，数据包丢失数与总发送数的比值。 如图3所示，测量S1到S2方向的链路丢包率时，SDN控制器需定期向交换机S1和S2发送Port-Stats-Request消息，来获取S1的1端口发送数据包个数tx_packetss1以及S2的2端口接收数据包个数rx_packetss2。通过每隔一段时间进行轮询，利用公式（1）可以计算得到S1到S2方向的链路在第i-1次和第i次查询时间段内的丢包率。 测量吞吐量吞吐量是指单位时间内传输无差错数据总量。 测量交换机端口吞吐量时，依然按图3所示，SDN控制器将周期性发送Port-Stats-Request消息到指定交换机，并从交换机的Port-Stats-Reply消息中获取接收/发送字节数（rx_bytes/tx_bytes）和端口生存时间（duration_sec和duration_nsec），利用公式（2）和（3）可以计算第i-1次和第i次查询时间段内的吞吐量大小。 1注：交换机的一个物理端口实际上是由一个TX端口和一个RX端口组成，分别用于发送和接收数据，因此端口吞吐量实际指的是TX端口的发送吞吐量，以及RX端口的接收吞吐量。例如，计算发送吞吐量，则公式2中的分子为tx_bytes(i) - tx_bytes(i-1)。 0x03 基于OpenFlow的Packet-Out消息和Packet-In消息测量拓扑和时延根据主动测量的思想，可由SDN控制器生成探测数据包并下发至指定的交换机，当测量过程结束时，被测交换机需要触发相应机制将探测包返回控制器，由控制器分析并计算得到测量结果。由于SDN网络中交换机处理数据包的规则，即流表项，需要由控制器指定，因此实现主动测量的关键在于控制器如何生成和回收探测数据包，以及如何制定探测包的转发规则。 Packet-Out消息OpenFlow协议规定了控制器和交换机相互发送数据包的消息类型。由控制器发起的Controller-to-Switch消息类型中，包含一类Packet-Out消息，其格式如图4所示。控制器能够自定义该消息中携带的数据包内容，以及交换机收到Packet-Out消息后的行为。控制器通过在Packet-Out消息中封装探测数据包并下发至指定交换机，就能够发起主动测量任务。 Packet-In消息在由交换机发起的Asynchronous消息类型中，包含Packet-In消息，其格式如图5所示，该消息与Packet-Out类似，可以封装交换机上的指定数据包并发送至控制器做进一步处理。当交换机中的流表项无法匹配某个数据包时，会默认触发Packet-In消息。由于探测数据包通常与网络中的正常流量有所不同，因此基于OpenFlow的SDN主动测量可以利用Packet-In消息机制实现探测包的回收。 测量拓扑拓扑测量负责对网络中各个设备之间的链路关系进行定期的检测，并维护完整的网络拓扑，是控制器和上层应用实现对整个网络资源进行统一调度和管理的基础。在传统IP网络中，拓扑测量采用链路发现协议(LLDP)。LLDP报文格式如图6所示，其中包含了Chassis ID TLV(设备标示符)，Port ID TLV(端口标示符)等字段，每个网络节点将自己和相邻设备的链路信息发送给其他节点，最终实现在各个网络设备上分散地测量链路信息。 目前，OpenFlow的拓扑发现协议(OFDP)依然沿用了LLDP协议，基于OpenFlow的Packet-Out和Packet-In消息测量拓扑，其采用了主动测量方式，原理如图7所示，基本思想如下： （1）控制器构造包含LLDP数据包的Packet-Out消息下发至交换机S1，并指定从某端口转发至交换机S2，其中LLDP数据包中的Chassis ID TLV字段设置为交换机S1的Datapath ID，Port ID TLV字段设置为交换机目标转发端口。 （2）S2接收到LLDP数据包，触发Packet-In消息，将LLDP数据包发回控制器。 （3）控制器通过分析LLDP数据包，可以得到LLDP数据包在交换机S1上的发出端口和在交换机S2上的接收端口存在链接关系，从而获得一条链路信息。通过这种方式，控制器可以实现对整个网络的拓扑测量，发送的Packet-Out信息数量与网络中所有交换机活动端口的数量有关。 测量时延交换机之间传输时延是表明链路运行状态的重要参数。由于OpenFlow交换机不具备在正常传输的报文中打时间戳的功能，无法采用传统IP网络中的被动测量方式。因此，需要利用主动测量思想，在交换机之间生成并发送探测包。如图8所示，控制器的测量目标是交换机S1到交换机S2的时延，则控制器将探测包发送至S1，并下发规则指定S1将探测包发送至S2。S2接收到探测包后，由于没有对应的转发规则，会将探测包返回控制器，控制器则会计算出探测包在路径中传输的总时间。由于控制器和交换机之间的通信也存在时延，因此控制器还需要发送通信消息，获得控制器和各个交换机之间的消息往返时间，通过计算差值，获得最终的链路时延结果。 因此，测量时延的详细步骤如下： (1)获得探测包传输时间Ttravel：控制器生成探测数据包，其中包含交换机S1的目标转发端口和生成探测数据包时的时间戳，用来记录探测包的转发路径和发送探测包的时间。然后，控制器通过Packet-Out消息封装探测数据包，并下发至交换机S1，并从指定端口将探测包转发至S2。S2接收到数据包后，由于没有匹配的流表项，会触发Packet-In消息，将探测包封装并返回控制器。控制器通过对探测包的字段进行分析，可以得到探测包在“控制器一S1—S2一控制器”路径上的传输时间Ttravel。 (2)获得控制器和交换机的往返时间RTT：得到Ttravel后，还需要知道数据包控制器和交换机往返传输时间，从而计算得到控制器下发探测包以及交换机返回探测包的时延。根据OpenFlow协议，控制器生成Echo Request消息分别下发交换机S1和S2，并记录收到Echo Reply消息的时间，得到控制器和交换机的往返传输时间RTT (3)计算交换机链路时延：根据上述测量结果，通过公式(4)计算得到交换机S1和S2之间的时延Tdelay。 0x04 参考 刘一童. SDN网络测量系统的研究与实现[D]. 2016. 张恒, 蔡志平, 李阳. SDN网络测量技术综述[J]. 中国科学:信息科学, 2018, v.48(03):65-86. 基于SDN的网络状态测量 / 北邮李呈 图解OpenFlow openflow-spec-v1.3.0]]></content>
      <categories>
        <category>SDN</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「OpenFlow」协议入门]]></title>
    <url>%2F2019%2F12%2F30%2F%E3%80%8COpenFlow%E3%80%8D%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[0x00 目录 0x00 目录 0x01 前言 0x02 OpenFlow简介 0x03 SDN与OpenFlow的关系 0x04 基于OpenFlow的SDN网络工作原理 传统网络中网络设备的工作过程 基于OpenFlow的SDN网络中网络设备的工作过程 小结 0x05 流表与流水线处理 流 流表 匹配域 指令与动作 流表匹配过程 例子——使用单流表转发数据包 多级流表与流水线处理 例子——多级流表实现对流的细粒度控制 0x06 OpenFlow的两种下发流表方式 Proactive Reactive 0x07 组表 例子——使用组表实现多播 0x08 计量表 例子——对流进行限速 0x09 OpenFlow消息 种类 Flow-Mod消息 Packet-In消息 Packet-Out消息 Port-Stats消息 0x0A 参考 0x01 前言本文主要参考OpenFlow v1.5.1协议、v1.3.0协议以及SDN相关书籍，对OpenFlow中主要机制（如流表与流水线处理、组表、计量表等）的原理进行解析 0x02 OpenFlow简介OpenFlow由斯坦福大学Nick Mckeown教授提出，为SDN控制平面与数据平面之间提供通信接口标准，以实现SDN网络的转控分离架构。OpenFlow协议允许SDN控制器直接访问和操作数据平面中的网络设备，控制网络转发行为，数据平面采用基于流的方式进行转发。目前由ONF（Open Networking Foundation）负责推广和制定OpenFlow标准，截至本文发表时，最新版本为1.5.1 0x03 SDN与OpenFlow的关系可以说OpenFlow是SDN中非常重要的技术，以至于许多人（包括笔者在内）在谈及SDN时就自然联想到OpenFlow。但SDN与OpenFlow不是划等号的关系，而是SDN包含OpenFlow的关系。实际上，SDN有多种实现方案，在ONF SDN方案中OpenFlow充当南向接口的作用。南向接口的定义是控制平面与数据平面之间进行交互的协议，南向接口除了可以采用OpenFlow外，还有许多别的协议，如OF-CONFIG、OVSDB、NETCONF、PCEP、XMPP等等 0x04 基于OpenFlow的SDN网络工作原理传统网络中网络设备的工作过程假设主机A向主机B发送IP数据包，且所有路由表和MAC地址表中都有该数据包的相应表项 路由器之间运行分布式路由协议构建路由表。查表成功则基于目的IP地址转发；查表失败时，丢弃数据包 交换机根据自学习算法构建MAC地址表。查表成功则基于目的MAC地址转发；查表失败时，除入端口外其余所有端口转发出去 基于OpenFlow的SDN网络中网络设备的工作过程假设主机A向主机B发送IP数据包，且所有流表有该数据包相应表项 OpenFlow交换机查询流表来转发数据包，查表成功则基于匹配域（如目的IP地址+源IP地址）转发；查表失败时，则询问SDN控制器 流表由SDN控制器来构建 假设主机A向主机B发送IP数据包，且OpenFlow交换机中流表为空 OF交换机接收IP数据包 OF交换机解析数据包首部并查询流表，由于流表为空，不知道如何转发，因此需要询问控制器 OF交换机向控制器发送Packet-In消息 控制器为主机A发送给主机B的IP数据包计算路由 控制器向OF交换机下发流表，使用FlowMod消息承载流表信息，OF交换机接收该消息后安装流表 控制器向OF交换机发送Packet-Out消息，指示OF交换机按照刚安装好的流表转发IP数据包 OF交换机收到Packet-Out消息后转发数据包 小结 路由计算、转发规则（流表）下发由控制器完成 OF交换机只需要按照流表进行转发，查表失败时，通过Pacekt-In消息询问控制器 0x05 流表与流水线处理流在介绍流表之前，需要先解释流的概念，流（Flow）就是具有相同特征的数据包集合。例如，源MAC地址为MAC_A，目的MAC地址为MAC_B的所有数据包集合就可以视为一条流，可见流具有方向性。有别于传统网络中路由器基于数据包独立转发的模式，使用OpenFlow的SDN网络是基于流进行转发的，即对相同特征的数据包集合采用同样的处理。 流表流表（Flow Table）是OpenFlow中最重要的一张表，它用于指导OpenFlow交换机对收到的数据包进行转发，相当于二层的MAC地址表和三层的路由表。在OpenFlow 1.1以后的版本中，每台交换机支持使用多张流表，构成流水线处理，从而完成对数据包更为复杂的处理。 流表由若干条流表项（Flow Entry）组成，流表项结构如下图所示。 匹配域（Match Fields）：用于定义某条流，也是流表匹配的依据 指令（Instructions）：表示对该条流应该如何处理 优先级（Priority）：表示该流表项的优先匹配程度 计数器（Counters）：用于统计该条流的信息 生存时间（Timeouts）：表示流表项的有效存活时间 Cookie：控制器设置用来过滤被流统计、流修改和流删除操作请求影响的流表项 标志（Flags）：用于流表项管理 流表项最为重要的两项为匹配域和指令，当OpenFlow交换机收到一个数据包，将它包头解析后与流表中流表项匹配域进行匹配，匹配成功则执行指令，因此流表可以简化理解为key-value形式的{匹配域-指令}表。 匹配域OpenFlow提供丰富的匹配域字段来定义不同粒度的流，如可以基于目的IP地址定义一条流，也可以根据源IP地址 + 目的IP地址来定义一条流 指令与动作指令（Instruction）是流表项匹配成功时的处理动作，分为三类 更新动作集（Action Set）：添加、修改、清空动作集，前面两个对应Write-Actions指令，清空动作集对应Clear-Actions指令 修改流水线处理次序：从序号低的表跳转到序号高的表，对应Go-To-Table指令 其他：更新元数据以及设定触发器，分别对应Write-Metadata指令和Stat-Trigger指令 动作（Action）Action是指对数据包的具体处理动作，可分为两类，一类是定义数据包的转发，另一类是修改数据包包头字段 流表匹配过程解析数据包得到的首部字段，用于与流表项匹配域进行匹配。若一个数据包与多个流表项匹配成功，最后只与优先级最高的流表项进行匹配。 匹配成功，更新计数器，执行相应指令 匹配失败 流表中没有设置Table-Miss流表项，匹配失败时，丢弃数据包 流表中设置有Table-Miss流表项（优先级为0且匹配域为ANY），则最后会匹配该表项，执行相应指令（如丢弃、交由控制器处理、交给下一张流表处理） 例子——使用单流表转发数据包假设主机A发送数据包给主机B，使用单张流表的OF交换机处理数据包过程，如图所示 OF交换机从1端口接收数据包 OF交换机解析数据包首部，并查询流表进行流表匹配，匹配第一条流表项，并执行相应指令 将数据包转发到OF交换机的2端口 多级流表与流水线处理从OpenFlow1.1开始引入了多级流表和流水线处理机制，多级流表的出现一方面能够实现对数据包的复杂处理，另一方面又能有效降低单张流表的长度，提高查表效率。每张表都有序号，数据包通过跳转指令按照流表序号递增的方向在多个流表之间进行匹配，这样就构成了一条流水线，如下图所示，可见流水线处理是有方向的。流水线处理可以在OpenFlow交换机的入端口或出端口上进行，一般都在入端口出进行流水线处理。当流水线上只有一张流表时，就简化成单流表匹配的情况。 流水线处理开始：OpenFlow交换机接收数据包后，执行入端口的流水线处理，同时给该流水线分配一个动作集（Action Set） 流表匹配 匹配成功 更新相应流表项的计数器，完成对该条流的统计工作 执行流表项对应的指令 匹配失败：一个数据包可能在流表中与所有的流表项都不匹配或者匹配到Table-Miss流表项（优先级为0且匹配域为ANY），这两种情况都称为Table-Miss，对于前者，OpenFlow交换机将丢弃数据包；对于后者，OpenFlow交换机根据Table-Miss流表项，处理数据包（丢弃数据包、转发给控制器、交给下一个流表处理） 流水线处理结束：若当前不是执行跳转指令，则执行动作集中的所有动作，完成对数据包的处理，然后结束流水线处理 例子——多级流表实现对流的细粒度控制使用多级流表实现主机A发送到给主机B的所有TCP报文正常转发，UDP报文均丢弃，从而实现对不同流的细粒度控制基本思想： 流表0中匹配主机A到主机B的IP流，然后跳转到其他流表，如流表2 流表2中在IP流的基础上进一步匹配TCP流或UDP流，根据要求将TCP流正常转发，UDP流丢弃 0x06 OpenFlow的两种下发流表方式根据流表的安装时机，可分为Proactive方式和Reactive方式 Proactive在数据包还未到达OpenFlow交换机前，SDN控制器就向OpenFlow交换机主动下发流表，这种方式相当于预置路由 例如Table-Miss表项，就需要采用Proactive方式在SDN控制器与OpenFlow交换机建立连接后下发，显示的指定数据包查表失败时，OpenFlow交换机的处理方式 Reactive数据包到达OpenFlow交换机因查流表失败时，产生Packet-In消息询问SDN控制器，SDN控制器计算路由后下发流表到OpenFlow交换机，这种方式相当于按需下发路由，只有在有路由需求且查流表失败时，才会触发新的流表安装 0x07 组表独立于流水线之外，每台OpenFlow交换机只有一张组表。组表（Group Table）由若干条组表项（Group Entry）组成，具有将多个端口定义为一个组的能力，从而实现广播、多播，负载均衡、链路聚合、故障转移等 组表项结构如图所示，定义了一到多个动作桶（Action Bucket），用于描述转发到指定端口前，对数据包的处理。 例子——使用组表实现多播假设主机A使用多播方式向主机B和C发送IP数据包 0x08 计量表对流进行测量，从而为流提供QoS功能，如限速、DiffServ 每台OpenFlow交换机只有一张计量表（Meter Table），由若干计量表项（Meter Entry）组成，每个计量表项可以定义一至多个计量带（Meter Band），计量带定义了带宽阈值和数据包处理方式（丢弃、DSCP标记） 例子——对流进行限速假设对某条流X（目的IP地址：10.0.0.2）进行限速，且当前测得流X数据包的速率为1200kBps 流表匹配后，交由计量1处理 由于测得数据包速率1200kBps &gt; 带宽阈值1000，根据计量带0定义的处理方式丢弃数据包，从而实现限速1注：带宽阈值本身是无单位的数值，其表示含义取决于应用场景 0x09 OpenFlow消息种类消息按照发送的位置可分为三大类，每一大类中有若干子消息 Controller-to-Switch消息：SDN控制器主动发送给OpenFlow交换机的消息 Features：用于获取交换机特性 Configuration：用来配置和查询交换机参数 Modify-State：用来修改交换机状态信息（增删改流表项、组表项等） Table-Mod消息 Flow-Mod消息（流表操作，添加、删除、修改流表项） Group-Mod消息 Port-Mod消息 Meter-Mod消息 Read-State：用来读取交换机状态信息（当前配置、统计信息等） Port-Stats消息 Flow-Stats消息 … Packet-Out：用来指定交换机将数据包从指定端口转发出去 Barrier：在不同消息之间使用，确保操作顺序执行 Role Request：控制器用于询问或设置自身在交换机中的角色，常用于交换机与多控制器连接的场景 Asynchronous-Configuration：控制器设置异步消息过滤器，只接收感兴趣的异步消息，一般在多控制器场景下使用 Asynchronous（异步）消息：OpenFlow交换机主动发送给SDN控制器的异步消息 Packet-In：将数据包交给控制器处理，一般流表匹配中出现Table-Miss时或流表项显示指定将数据包交给控制器时，触发该消息 Flow-Removed：通知控制器，流表项被删除；流表项超时或控制器删除流表项时触发该消息（需要在交换机配置时使能该消息） Port-status ：通知控制器，交换机端口状态发生变化 Role-status：通知控制器，控制器在交换机中的角色发送变化 Controller-Status：通知控制器，OpenFlow通道状态发生变化 Flow-monitor：通知控制器，流表发送变化 Symmetric（对称）消息：可由SDN控制器或OpenFlow交换机主动发送的消息 Hello：建立控制器与交换机之间的OpenFlow通道 Echo：检测交换机与控制器之间的连接状态或测量OpenFlow通道的时延和带宽 Error：用于通告错误 Experiment：用于实验，测试新特性 Flow-Mod消息Flow-Mod消息用于流表操作，包括添加、删除、修改流表项。该消息由控制器下发给交换机，从而指导交换机对数据包的处理。 其在OpenFlow1.3中的消息格式如下图所示。 command： ADD:添加流表项 MODIFY：根据匹配域，修改所有匹配的流表项，可能有多条流表项被修改 MODIFY_STRICT：根据匹配域以及优先级，修改特定的流表项，只有一条流表项被修改 DELETE：根据匹配域，删除所有匹配的流表项，可能有多条流表项被删除 DELETE_STRICT：根据匹配域以及优先级，删除特定的流表项，只有一条流表项被删除 参考「OpenFlow」流表项删除DELETE与DELETE_STRICT的区别 Packet-In消息Packet-In消息用于将OpenFlow交换机上指定数据包交给控制器处理，一般流表匹配中出现Table-Miss时或流表项显示指定将数据包交给控制器时，触发该消息。此外，它还能用于主动测量时回收探测包，从而结合Packet-Out消息实现对网络拓扑与链路时延的测量，详情参考基于OpenFlow消息的网络测量方法。 其在OpenFlow1.3中的消息格式如下图所示。 buffer_id：若该字段为-1，表明交换机未缓存数据包，Packet-In消息需要携带完整数据包发送至控制器；否则，表明数据包已在交换机上缓存，Packet-In消息只携带部分数据包上传至控制器。 Packet-Out消息Packet-Out消息用于指定交换机将数据包从指定端口转发出去。触发该消息的情况有两种：1.转发Packet-In消息携带的数据包 2.转发控制器主动构造的数据包（如用于链路发现的LLDP报文）。此外，由于该消息能够携带自定义数据包，控制器通过在Packet-Out消息中封装探测包并下发至指定交换机，就能够发起主动测量任务，配合Packet-In消息可实现对网络拓扑与链路时延的测量，详情参考基于OpenFlow消息的网络测量方法。 其在OpenFlow1.3中的消息格式如下图所示。 buffer_id：若该字段为-1，表明交换机未缓存数据包，Packet-Out消息携带控制器创建的数据包发送至交换机；否则，Packet-Out消息表示交换机需要将本地缓存的数据包按照Packet-Out中的actions进行处理。 Port-Stats消息Port-Stats消息是统计消息（以Stats结尾的消息）的一种，用于控制器查询交换机的端口计数器，从而获取端口的统计信息（如端口接收/发送字节数、接收/发送数据包个数等）。此外，它还能用来测量丢包率和吞吐量，详情参考基于OpenFlow消息的网络测量方法。 该消息具体有两种，一种是Port-Stats-Request消息，用于SDN控制器请求交换机端口统计信息，另一种是Port-Stats-Reply消息，交换机用它来应答SDN控制器，它们在OpenFlow1.3版本中的消息格式如下图所示。 0x0A 参考 openflow-switch-v1.5.1 openflow-switch-v1.3.0 图解OpenFlow openflow协议基础入门-北邮-张健男 Openflow协议详解 重构网络：SDN架构与实现 深度剖析软件定义网络(SDN)]]></content>
      <categories>
        <category>SDN</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「OpenFlow」流表项删除DELETE与DELETE_STRICT的区别]]></title>
    <url>%2F2019%2F12%2F27%2F%E3%80%8COpenFlow%E3%80%8D%E6%B5%81%E8%A1%A8%E9%A1%B9%E5%88%A0%E9%99%A4DELETE%E4%B8%8EDELETE_STRICT%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[0x00 目录 0x00 目录 0x01 流表项操作与Flow_Mod消息 0x02 流表项删除DELETE与DELETE_STRICT区别 0x03 POX + Mininet实验验证 实验环境 实验步骤 1.启动POX 2.运行Mininet 3.添加两条流表项 4.DELETE删除流表项 5.添加两条流表项 6.DELETE_STRICT删除流表项 0x04 总结 0x05 参考 0x01 流表项操作与Flow_Mod消息在OpenFlow中，对流表项的操作，例如增加、修改、删除流表项，都是通过控制器下发Flow_Mod消息完成的。Flow_Mod消息的格式如图所示，其中command字段定义了对流表项的操作（增加、修改、删除），而对于修改和删除操作又分为NON_STRICT和STRICT两个版本。 0x02 流表项删除DELETE与DELETE_STRICT区别要想删除流表项，只需要构造command = DELETE或command = DELETE_STRICT的Flow_Mod消息即可，两者的区别如下： DELETE：根据匹配域，删除所有匹配的流表项，意味着可能有多条流表项被删除 DELETE_STRICT：根据匹配域以及优先级，删除特定的流表项，只有一条流表项被删除 例子：假设使用openflow1.0，且openflow交换机流表中只有以下两条流表项12345678910111213141516171819202122232425flow entry1:&#123; prioirity : 42 match : &#123; dl_type : 0x0800 ip_src : 10.0.0.1 ip_dst : 10.0.0.2 &#125; actions : output : &apos;sw1-eth2&apos;&#125;flow entry2:&#123; prioirity : 42 match : &#123; dl_type : 0x0800 ip_src : 10.0.0.1 ip_dst : 10.0.0.2 ip_protocol : 6 tp_dst : 80 &#125; actions : output : &apos;sw1-eth2&apos;&#125; 若控制器下发command = DELETE的Flow_Mod消息123456789101112flow_mod msg:&#123; command : DELETE prioirity : 42 match : &#123; dl_type : 0x0800 ip_src : 10.0.0.1 ip_dst : 10.0.0.2 &#125; actions : output : &apos;sw1-eth2&apos;&#125; 那么openflow交换机将会根据Flow_Mod消息中的匹配域（match）去流表中查找所有匹配的流表项（若流表项中的匹配域描述比Flow_Mod消息中的匹配域更详细，也算查找成功），这里flow entry1和flow entry2都满足，因为它们都含有123456match :&#123; dl_type : 0x0800 ip_src : 10.0.0.1 ip_dst : 10.0.0.2&#125; 因此，两条流表项都会被删除 若控制器下发command = DELETE_STRICT的Flow_Mod消息 123456789101112flow_mod msg:&#123; command : DELETE_STRICT prioirity : 42 match : &#123; dl_type : 0x0800 ip_src : 10.0.0.1 ip_dst : 10.0.0.2 &#125; actions : output : &apos;sw1-eth2&apos;&#125; openflow交换机会根据Flow_Mod消息中的匹配域（match）和优先级（prioirity）去流表中查找特定的流表项，这里只有flow entry1满足条件，因为flow entry2的匹配域多了两个字段12ip_protocol : 6tp_dst : 80 因此只有flow entry1被删除 0x03 POX + Mininet实验验证按照0x02中提到的例子，使用POX和Mininet进行验证 实验环境1234- OpenFlow 1.0 : SDN控制器与openflow交换机之间通信的协议- POX-eel : python实现的SDN控制器，用于构造Flow_Mod消息，并下发至openflow交换机- Mininet 2.3.0d1 : 创建&quot; h1 -- sw1 -- h2 &quot;拓扑- POX与Mininet均部署在同一台运行ubuntu 18.04 LTS的机器上 实验步骤1.启动POX打开终端，输入1234567home/ctz/pox-eel/pox.py openflow.of_01 --address=127.0.0.1 --port=6653 py- home/ctz/pox-eel/pox.py : POX程序的入口- openflow.of_01 : POX的组件，使用openflow1.0进行通信- address : openflow.of_01的参数，定义POX控制器的IP地址，这里定义为本地回环- port : openflow.of_01的参数，定义POX控制器的监听端口，用于监听openflow交换机发来的消息- py：使用POX交互模式，可在终端与POX控制器进行交互，例如构造Flow_Mod消息并发送给交换机 2.运行Mininet另开一终端，输入123456sudo mn --controller=remote,ip=127.0.0.1,port=6653 --mac- controller=remote : mininet连接远程控制器- ip : controller的参数，定义要连接的远程控制器IP地址- port : controller的参数，定义要连接的远程控制器端口- --mac : 从00:00:00:00:00:01开始，按递增序为主机设置MAC地址 3.添加两条流表项在运行POX的终端上，构造两条Flow_Mod消息，用于添加两条流表项到交换机1234567891011121314151617181920212223242526# 以下三条命令在POX控制器同openflow交换机连接上后只需要输入一次import pox.openflow.libopenflow_01 as offrom pox.lib.addresses import IPAddrcore.openflow.connections.keys() # 获取连接的交换机dpid，会在终端上显示dpid# 下发一条流表项（h1 -&gt; h2 基于源目IP）msg = of.ofp_flow_mod()msg.priority = 42msg.command = of.OFPFC_ADDmsg.match.dl_type = 0x800msg.match.nw_src = IPAddr(&quot;10.0.0.1&quot;)msg.match.nw_dst = IPAddr(&quot;10.0.0.2&quot;)msg.actions.append(of.ofp_action_output(port = 2))core.openflow.connections[1].send(msg) # 1为交换机的dpid# 下发一条流表项（h1 -&gt; h2 基于源目IP和TCP目的端口号）msg = of.ofp_flow_mod()msg.priority = 42msg.command = of.OFPFC_ADDmsg.match.dl_type = 0x800msg.match.nw_src = IPAddr(&quot;10.0.0.1&quot;)msg.match.nw_dst = IPAddr(&quot;10.0.0.2&quot;)msg.match.nw_proto = 6msg.match.tp_dst = 80msg.actions.append(of.ofp_action_output(port = 2))core.openflow.connections[1].send(msg) # 1为交换机的dpid 在运行Mininet的终端中输入1dpctl dump-flows 显示交换机中流表信息 4.DELETE删除流表项在运行POX的终端上，构造一条command = DELETE的Flow_Mod消息，删除所有匹配的流表项123456789# 删除所有匹配流表项（h1 -&gt; h2 基于源目IP）msg = of.ofp_flow_mod()msg.priority = 42msg.command = of.OFPFC_DELETEmsg.match.dl_type = 0x800msg.match.nw_src = IPAddr(&quot;10.0.0.1&quot;)msg.match.nw_dst = IPAddr(&quot;10.0.0.2&quot;)msg.actions.append(of.ofp_action_output(port = 2))core.openflow.connections[1].send(msg) # 1为交换机的dpid 如下图所示，交换机根据Flow_Mod消息的match字段查找流表项，所有流表项均被删除 5.添加两条流表项按照步骤3，重新添加两条流表项 6.DELETE_STRICT删除流表项在运行POX的终端上，构造一条command = DELETE_STRICT的Flow_Mod消息，删除指定流表项123456789# 删除所有匹配流表项（h1 -&gt; h2 基于源目IP）msg = of.ofp_flow_mod()msg.priority = 42msg.command = of.OFPFC_DELETE_STRICTmsg.match.dl_type = 0x800msg.match.nw_src = IPAddr(&quot;10.0.0.1&quot;)msg.match.nw_dst = IPAddr(&quot;10.0.0.2&quot;)msg.actions.append(of.ofp_action_output(port = 2))core.openflow.connections[1].send(msg) # 1为交换机的dpid 如下图所示，交换机根据Flow_Mod消息的match字段和priority字段查找流表项，匹配域中含有端口号的流表项被保留，匹配域中不含端口号的流表项被删除 0x04 总结使用Flow_Mod删除流表项时，command = DELETE：删除所有匹配的流表项，只要流表项中Match字段描述 &gt;= Flow_Mod消息中的Match字段（如流表项中Match:{in_port:1,ip_src:10.0.0.1}，Flow_Mod消息中Match:{in_port:1}），则相关流表项均会被删除，因此被删除的流表项可能有多个 DELETE_STRICT：删除特定的流表项，只有同时满足Flow_Mod消息中匹配域以及优先级的流表项会被删除，被删除的流表项只有一个 0x05 参考 openflow控制器POX使用指南 SDN控制器之POX篇]]></content>
      <categories>
        <category>SDN</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「虚拟化」基于virsh实现虚拟机动态迁移]]></title>
    <url>%2F2019%2F12%2F11%2F%E3%80%8C%E8%99%9A%E6%8B%9F%E5%8C%96%E3%80%8D%E5%9F%BA%E4%BA%8Evirsh%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8A%A8%E6%80%81%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[0x00 目录 0x00 目录 0x01 虚拟机迁移方式 静态迁移 动态迁移 基于共享存储 基于本地存储 0x02 虚拟机管理工具 0x03 搭建KVM虚拟化环境 0x04 基于virsh实现虚拟机动态迁移 实验环境 SCP拷贝磁盘文件 virsh动态迁移内存状态 virsh导出配置文件 virsh定义并创建虚拟机 0x05 参考 0x01 虚拟机迁移方式虚拟机迁移一般指虚拟机从一台物理机上迁移到另一台物理机上，迁移的内容包括虚拟机的磁盘文件、配置文件和内存状态。从迁移方式上可分为两种：静态迁移和动态迁移。 静态迁移这种方式又称为离线迁移或线下迁移，指的是虚拟机需要在关机的前提下，完成迁移操作。迁移的过程分为两个阶段： 1.从源物理机上拷贝虚拟机的磁盘文件、配置文件至目的物理机上，可以使用SCP命令完成拷贝工作 2.在目的物理机上，根据拷贝的磁盘文件及配置文件，定义并创建虚拟机 动态迁移这种方式也成为热迁移、在线迁移、线上迁移等，总之就是指虚拟机在运行的情况下，完成从源物理机迁移至目的物理机，在这过程中虚拟机只经历一个很短暂的暂停（虚拟机从源物理机上切换到目的物理机上），用户几乎感受不到服务的中断 根据磁盘文件的存储位置，又可分为以下两类： 基于共享存储 基于本地存储（块存储） 基于共享存储源物理机与目的物理机拥有共享的存储设备，虚拟机的磁盘文件可以被源物理机和目的物理机所访问，因此无需迁移。迁移的过程如下： 1.从源物理机上迁移虚拟机的内存状态到目的物理机1注：迁移结束后，虚拟机就已经在目的物理机上运行了，但是由于目的物理机上无该虚拟机配置文件，若此时关闭虚拟机，就无法找到该虚拟机了，所以需要完成接下来的操作 2.在目的物理机上，根据迁移的内存状态导出虚拟机的配置文件 3.在目的物理机上，根据导出的虚拟机配置文件，定义并创建虚拟机 基于本地存储源物理机与目的物理机都使用独立的存储设备，因此迁移的内容包括虚拟机的磁盘文件、内存状态以及配置文件（从内存状态中导出），迁移的过程如下： 1.从源物理机上拷贝磁盘文件到目的物理机1例如：使用SCP命令，同时要使用相同的目录结构放置虚拟机磁盘文件 2.从物理机上迁移内存状态到目的物理机1例如：使用virsh migrate --live命令，或直接使用virt-manager图形化界面上的迁移操作 1注：迁移结束后，虚拟机就已经在目的物理机上运行了，但是由于目的物理机上无该虚拟机配置文件，若此时关闭虚拟机，就无法找到该虚拟机了，所以需要完成接下来的操作 3.在目的物理机上，根据迁移的内存状态导出虚拟机的配置文件 4.在目的物理机上，根据导出的虚拟机配置文件，定义并创建虚拟机 0x02 虚拟机管理工具 libvirt：用于实现虚拟机管理的开源API，可以实现对虚拟机的创建、删除、分配资源等 virt-manager：基于libvirt实现的虚拟机管理工具，图形化界面，类似VMware Workstation和VirtualBox virsh：基于libvirt实现的虚拟机管理工具，命令行 0x03 搭建KVM虚拟化环境 查看CPU是否支持KVM1egrep &quot;(svm|vmx)&quot; /proc/cpuinfo 如果有输出，则说明CPU支持KVM 安装KVM及相关依赖包 123456sudo apt-get install qemu-kvmsudo apt-get install qemusudo apt-get install virt-managersudo apt-get install virt-viewer sudo apt-get install libvirt-bin sudo apt-get install bridge-utils 启动KVM虚拟系统管理器 1sudo virt-manager 0x04 基于virsh实现虚拟机动态迁移这里采用基于本地存储的动态迁移方式，实现在物理机1上的虚拟机VM1动态迁移到物理机2上。 实验环境1234名称 主机名 IP地址 操作系统 源物理机 kvm-node1 192.168.111.130 ubuntu-16.04.4-desktop目的物理机 kvm-node2 192.168.111.132 ubuntu-16.04.4-desktop虚拟机 VM1 192.168.122.18 ubuntu-16.04.3-server SCP拷贝磁盘文件在源物理机上使用SCP命令拷贝磁盘文件至目的物理机上1sudo scp /var/lib/libvirt/images/node.qcow2 192.168.200.132:/var/lib/libvirt/images /var/lib/libvirt/images：存放虚拟机磁盘文件的目录 node.qcow2：虚拟机VM1的磁盘文件 192.168.200.132：目的物理机IP地址 注1：磁盘文件拷贝到目的物理机上后，要存放在相同的目录结构中 注2：192.168.200.132前若不加用户名，则默认以root身份访问。若kvm@192.168.200.132，则以kvm身份访问 virsh动态迁移内存状态在源物理机上使用virsh命令迁移虚拟机内存状态至目的物理机上 1sudo virsh migrate --live --verbose VM1 qemu+ssh://192.168.200.131/system tcp://192.168.200.131 --unsafe virsh migrate –live：动态迁移 –verbose：显示迁移详情 VM1：需要迁移的虚拟机 qemu+ssh：通过ssh连接到目的物理机上的system实例，具有最大权限来管理远程节点上的虚拟机资源 /system： 以root身份进行状态迁移 tcp：使用tcp连接 192.168.200.131：目的物理机IP地址 –unsafe：跳过安全检测 注：可以指定身份访问远程主机，如远程主机用户名为kvm，则可以使用 qemu+ssh://kvm@192.168.200.131/system，若不添加kvm，默认使用root访问 在目的物理机上，查看虚拟机状态1sudo virsh list --all 可见，虚拟机VM1已经迁移成功并且在目的物理机上运行 virsh导出配置文件在目的物理机上，根据内存状态导出虚拟机VM1配置文件，否则迁移后远程主机没有虚拟机VM1的配置文件，关闭VM1后，VM1就没有了1sudo virsh dumpxml VM1 &gt; /etc/libvirt/qemu/VM1.xml virsh定义并创建虚拟机根据VM1的配置文件定义并创建虚拟机1sudo virsh define /etc/libvirt/qemu/VM1.xml 0x05 参考 Virsh 虚拟机迁移 虚拟机迁移（QEMU动态迁移，Libvirt动（静）态迁移） Ubuntu 16.04 搭建KVM环境]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基于LSB算法实现信息隐藏]]></title>
    <url>%2F2019%2F11%2F23%2F%E5%9F%BA%E4%BA%8ELSB%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%2F</url>
    <content type="text"><![CDATA[0x00 目录 0x00 目录 0x01 问题描述 0x02 LSB算法原理 0x03 LSB算法实现 0x04 实验结果分析 实验数据 实验结果 0x05 健壮性分析 0x06 关键代码 秘密信息嵌入 秘密信息提取 加噪处理 0x01 问题描述基于LSB算法实现在320x240的灰度图像上隐藏秘密信息，并分析LSB算法的健壮性（抗攻击）。 0x02 LSB算法原理该算法包含秘密信息嵌入和提取两部分。嵌入：将二进制表示的秘密信息中的每一位，按照某种顺序（例如先按列再按行，如图1所示）依次存储在载体图像像素值的最低位上。提取：按照嵌入时的顺序依次从嵌有秘密信息的载体图像上提取像素值的最低位，将其组合后即可得到秘密信息。 0x03 LSB算法实现使用Python编码实现基于LSB算法的秘密信息嵌入与提取。秘密信息嵌入算法如图2所示，秘密信息提取算法如图3所示。LSB算法完整代码：https://github.com/Chentingz/LSB-Steganography 0x04 实验结果分析实验数据 秘密信息：”secret text is hidden in image using LSB algorithm\n2019.11.21” 原始载体图像名：raw_img.bmp 原始载体图像大小：320 x 240 原始载体图像通道数：单通道（灰度图像） 原始载体图像：见图4 实验结果 嵌入算法：按照图2的算法从文件中读取秘密信息后嵌入到原始载体图像中，从图5可见，嵌入前后的载体图像无明显变化。 提取算法：按照图3算法对嵌入秘密信息的载体图像提取出秘密信息，由图6可见，提取结果与嵌入前的秘密信息一致。 0x05 健壮性分析对嵌有秘密信息的载体图像分别采用高斯噪声和椒盐噪声处理，然后提取秘密信息，观察秘密信息是否遭到破坏，噪声处理前后的图像对比如图7所示。 采用图3中的提取算法，分别对高斯噪声和椒盐噪声处理过的图像提取信息，提取结果如图8所示，可见对基于LSB嵌入秘密信息的图像进行噪声处理后，秘密信息将遭到不同程度的破坏，LSB算法抗攻击性差。 0x06 关键代码秘密信息嵌入1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from PIL import Imageeof_str = "00000000""""将秘密信息嵌入到载体图像中首先将秘密信息转换成二进制字符串，如"a" -&gt; "0110 0001"在二进制字符串的末尾添加两个0x0000的ASCII码作为结束标志，如"0110 0001" -&gt; "0110 0001 0000 0000 0000 0000"按照图像从上到下，从左到右的顺序，将串的每一位依次插入到像素的最低位中，每一个像素用一个字节表示@param text: string类型的秘密信息@param raw_img: image类型原始载体图像@return: image类型嵌入秘密信息后的图像"""def insert_text_to_image(text, raw_img): mod_img = raw_img.copy() width = mod_img.size[0] height = mod_img.size[1] binstr = text2binarystring(text) binstr += eof_str + eof_str i = 0 for w in range(width): for h in range(height): if i == len(binstr): break value = mod_img.getpixel((w,h)) value = mod_lsb(value, binstr[i]) mod_img.putpixel((w,h), value) i=i+1 return mod_img"""将秘密信息转换成二进制串先将字符转换成对应的ASCII码，然后转二进制，最后8位对齐，不足的前面用0填充@param text: string类型表示的秘密信息@return: string类型表示的二进制串"""def text2binarystring(text): binstr = "" for ch in text : # ord(ch): 将ch转换成十进制数 bin():转换成0b开头的二进制字符串 zfill:返回指定长度字符串，不足的前面填充0 binstr += bin(ord(ch)).replace('0b', '').zfill(8) return binstr"""将value的最低位替换成bit,返回修改后的value@param value: int类型表示的像素值@param bit: string类型表示的嵌入位@return: int类型表示的修改后的像素值"""def mod_lsb(value, bit): str = bin(value).replace('0b', '').zfill(8) lsb = str[len(str)-1] if lsb != bit : str = str[0:len(str)-1] + bit return int(str, 2) 秘密信息提取1234567891011121314151617181920212223242526272829303132333435363738from PIL import Imageeof = chr(int(eof_str, 2))"""从图像中提取秘密信息，返回string类型的秘密信息@param mod_img: 嵌入秘密信息后的图像@return: string类型表示的秘密信息"""def get_text_from_image(mod_img): width = mod_img.size[0] height = mod_img.size[1] bytestr = "" text = "" countEOF = 0 for w in range(width): for h in range(height): value = mod_img.getpixel((w,h)) bytestr += get_lsb(value) if len(bytestr) == 8 : # 转换成ASCII码 # 例："0110 0001" -&gt; 97 -&gt; 'a' ch = chr(int(bytestr, 2)) if ch == eof : countEOF = countEOF + 1 if countEOF == 2 : break text += ch bytestr = "" return text"""返回像素值的lsb@param value: int类型表示的像素值@return: string类型表示的像素值最低位"""def get_lsb(value): str = bin(value).replace('0b', '').zfill(8) lsb = str[len(str)-1] return lsb 加噪处理123456789101112131415161718192021222324252627282930313233343536373839404142import cv2import matplotlib.pyplot as pltimport skimage.util as skiimport LSBfrom PIL import Imagemod_img_path = "./test/mod_img.bmp"img_gaussian_path = "./test/img_gaussian.bmp"img_sp_path = "./test/img_sp.bmp"img_mod_and_noises_compare_path = "./test/img_mod_and_noises_compare.png""""对嵌有秘密信息的载体图像加噪处理，并保存"""def noise(): mod_img = cv2.imread(mod_img_path, cv2.IMREAD_GRAYSCALE) img_copy = mod_img.copy() # 高斯噪声处理后的嵌有秘密信息的载体图像 img_gaussian = ski.random_noise(img_copy, mode="gaussian", seed=None, clip=True, mean=0,var=0.05) img_gaussian *= 255 # 椒盐噪声处理后的嵌有秘密信息的载体图像 img_sp = ski.random_noise(img_copy, mode="s&amp;p", seed=None, clip=True, amount=0.1) img_sp *= 255 # 保存加噪后的图像 cv2.imwrite(img_gaussian_path, img_gaussian) cv2.imwrite(img_sp_path, img_sp) # 构造对比图 plt.rcParams['font.sans-serif']=['SimHei'] # 中文字体设置 plt.rcParams['axes.unicode_minus'] = False plt.subplot(131) plt.title("嵌有秘密信息的载体图像") plt.imshow(mod_img,cmap='gray') plt.subplot(132) plt.title("高斯噪声处理后图像") plt.imshow(img_gaussian, cmap='gray') plt.subplot(133) plt.title("椒盐噪声处理后的图像") plt.imshow(img_sp,cmap='gray') # 保存对比图 plt.savefig(img_compare_path) # 显示对比图 plt.show()]]></content>
      <categories>
        <category>Security</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「Floodlight x Mininet」从0开始搭建环境]]></title>
    <url>%2F2019%2F11%2F01%2F%E3%80%8CFloodlight%20x%20Mininet%E3%80%8D%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[0x00 前言Floodlight是我在学习SDN过程中最早接触的控制器，相比较于ODL和ONOS，它从安装到导入IDE再到使用都十分容易，官方文档也写的很清楚，对新手极其友好。趁着最近给别人搭建SDN实验环境的机会，总结一下在Ubuntu上如何搭建一个Floodlight x Mininet的SDN环境。 0x01 目录 0x00 前言 0x01 目录 0x02 前期准备 Git安装 JDK安装 Apache Ant安装 0x03 Floodlight安装 源码下载 源码编译 参考 0x04 Mininet安装 源码下载 安装 测试 参考 0x05 测试环境 运行Floodlight 运行Mininet 测试Floodlight和Mininet的连通性 参考 0x06 在Eclipse中运行Floodlight 下载Eclipse 安装Eclipse 运行Eclipse 导入Floodlight源码 配置启动项 运行Floodlight 参考 0x02 前期准备 Git JDK Apache Ant Git安装1sudo apt-get install git JDK安装Floodlight v1.2以后使用JDK8，这里选择Oracle的JDK8进行下载，在网上找到Oracle JDK8的linux压缩包进行下载并解压到home目录下，然后配置环境变量123456789# 配置环境变量sudo gedit ~/.bashrc# 在.bashrc文件末尾添加下面的内容，JAVA_HOME填JDK目录所在路径export JAVA_HOME=/home/ubuntu/jdk1.8.0_141export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH# 查看配置是否成功，若显示java的版本，则配置成功java -version 参考：https://blog.csdn.net/EahanZhang/article/details/88085561 Apache Ant安装1sudo apt-get install ant 0x03 Floodlight安装源码下载1git clone git://github.com/floodlight/floodlight.git 源码编译12cd floodlightant 显示Build Successful，则说明编译成功 参考https://floodlight.atlassian.net/wiki/spaces/floodlightcontroller/pages/1343544/Installation+Guide#InstallationGuide-Linux 0x04 Mininet安装源码下载1git clone git://github.com/mininet/mininet 安装12cd mininet/util/sudo ./install.sh 测试1sudo mn --test pingall 参考http://mininet.org/download/ 0x05 测试环境运行Floodlight123java -jar target/floodlight.jar# 该命令要在floodlight目录下运行 运行Mininet新开终端，运行命令创建如下拓扑: h1 - sw1 - h2 123sudo mn --controller=remote,ip=127.0.0.1 --mac --switch=ovsk,protocols=OpenFlow13# 如果Floodlight和Mininet分别部署在不同主机上，则上面的IP地址改为Floodlight所在主机的IP地址 测试Floodlight和Mininet的连通性在运行Mininet的终端上，输入1pingall 如果主机之间能够ping通，说明Floodlight与Mininet之间连通 此时还可以在浏览器中打开Floodlight Web GUI进行验证，若显示交换机、主机个数、拓扑，也能说明Floodlight与Mininet之间成功连通http://localhost:8080/ui/pages/index.html 参考https://floodlight.atlassian.net/wiki/spaces/floodlightcontroller/pages/1343544/Installation+Guide#InstallationGuide-SimulatingANetwork 0x06 在Eclipse中运行Floodlight下载Eclipse 安装Eclipse 运行Eclipse 导入Floodlight源码 配置启动项 运行Floodlight 参考https://floodlight.atlassian.net/wiki/spaces/floodlightcontroller/pages/1343544/Installation+Guide#InstallationGuide-EclipseIDE]]></content>
      <categories>
        <category>SDN</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「ONOS x Mininet」从0开始搭建环境]]></title>
    <url>%2F2019%2F10%2F28%2F%E3%80%8CONOS%20x%20Mininet%E3%80%8D%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[0x00 前言这篇教程是基于ONOS Wiki上教程写的，Wiki上写的还是比较清楚的，但在实践过程中还是踩了一些坑，为了总结写下了这篇教程。本教程的环境搭建是在分配有4核CPU、8G内存、运行ubuntu 18.04 desktop虚拟机上完成的。建议搭建环境的主机至少分配4G内存，如果你使用其他版本的ubuntu，本教程也是适用的。 0x01 目录 0x00 前言 0x01 目录 0x02 前期准备 Git安装 JDK安装 Bazel安装 0x03 ONOS安装 下载ONOS源码 ONOS源码目录改名 ONOS源码编译 运行ONOS控制器 参考 0x04 Mininet安装 源码下载 安装 测试 参考 0x05 测试环境 运行ONOS 运行ONOS Apps 运行Mininet 检查ONOS与Mininet连通性 测试主机之间的连通性 参考 0x06 在IntelliJ IDEA中运行ONOS 下载IntelliJ IDEA 运行IntelliJ IDEA 安装Bazel插件 导入ONOS源码并编译 运行ONOS 参考 0x02 前期准备 Git JDK Bazel Git安装1sudo apt-get install git JDK安装ONOS-2.2以后的版本都使用JDK11，这里选择OpenJDK-11进行安装1234567891011121314# 安装OpenJDK-11sudo apt-get install openjdk-11-jdk# 配置环境变量sudo gedit /etc/profile# 在profile文件末尾添加下面的内容export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH# 查看配置是否成功，若显示openjdk version，则配置成功java -version 参考：https://blog.csdn.net/EahanZhang/article/details/88085561 Bazel安装Bazel是Google开发的用于编译的工具，在Github上选择bazel-0.27.1-installer-linux-x86_64.sh 进行下载https://github.com/bazelbuild/bazel/releases/tag/0.27.1 注：在我搭建环境的时候，参考的是ONOS Wiki于2019/6/19发布的教程，里面使用的是Bazel 0.27.0。https://wiki.onosproject.org/pages/viewpage.action?pageId=28836246我开始时使用了1.0.0但发现编译失败，于是换成0.27.1，经过测试该版本有效。1.0.0编译失败的问题已于2019/10/16被ONOS官方解决，因此你也可以选择安装最新版本的Bazel。https://github.com/opennetworkinglab/onos/commit/2bf24538098ce3d963d7cbe7da4dfbcfc69285e5 根据Bazel官网安装教程进行安装https://docs.bazel.build/versions/master/install-ubuntu.html#install-with-installer-ubuntu 0x03 ONOS安装下载ONOS源码有以下两种方式，选择一种即可 Git命令下载 1git clone https://gerrit.onosproject.org/onos Github上下载https://github.com/opennetworkinglab/onos ONOS源码目录改名若选择从Github上下载ZIP压缩包，解压缩后得到onos-master目录，将其改名为onos，方便后续操作1mv onos-master onos ONOS源码编译12cd onosbazel build onos 当显示build success，说明编译成功 注：由于网络原因，可能某些依赖下载不下来，导致编译失败，此时可以选择重新运行bazel build onos，直到依赖下载成功 运行ONOS控制器12cd onosbazel run onos-local 参考https://wiki.onosproject.org/display/ONOS/Development+Environment+Setup 0x04 Mininet安装源码下载1git clone git://github.com/mininet/mininet 安装12cd mininet/util/sudo ./install.sh 测试1sudo mn --test pingall 参考http://mininet.org/download/ 0x05 测试环境这里ONOS和Mininet都部署在同一台主机中进行测试，当然你也可以选择分别部署在不同主机上。 运行ONOS12345cd onosbazel run onos-local# 若想要删除ONOS上一次运行时产生的状态信息，则输入：# bazel run onos-local -- clean 注：1.运行ONOS之前，ONOS需要监听的端口号6653和6633有可能被其他进程占用，因此可以先检查一下端口使用情况：sudo netstat -atnp | grep 6653sudo netstat -atnp | grep 6633若除java进程外，有其他进程占用端口号6653或6633，例如：ovs-testcontrol，则杀死进程：sudo kill -9 &lt;进程号&gt;2.ONOS启动后，最好等待窗口中不再弹出INFO信息后，再运行Mininet 运行ONOS AppsONOS开启后，默认不运行Reactive Forwarding和Basic Pipelines应用程序，这样的话ONOS就无法处理2层和3层的转发，Mininet中主机之间无法ping通。因此在运行Mininet前，先运行这两个应用程序。下面介绍两种方法，选择其中一种即可 ONOS Web GUI 浏览器中打开ONOS Web GUI http://localhost:8181/onos/ui/输入用户名：onos 密码：rocks打开应用程序选项卡 运行Basic Pipelines和Reactive Forwarding应用程序 ONOS CLI 新开终端，输入 1onos/tools/test/bin/onos localhost 打开ONOS命令行界面 输入命令运行Basic Pipelines和Reactive Forwarding应用程序 12app activate org.onosproject.pipelines.basicapp activate org.onosproject.fwd 注：Basic Pipelines对应的应用程序ID为org.onosproject.pipelines.basicReactive Forwarding对应的ID为org.onosproject.fwd 运行Mininet新开终端，运行命令创建如下拓扑: h1 - sw1 - h2 123sudo mn --controller=remote,ip=127.0.0.1 --mac --switch=ovsk,protocols=OpenFlow13# 如果ONOS和Mininet分别部署在不同主机上，则上面的IP地址改为ONOS所在主机的IP地址 检查ONOS与Mininet连通性下面介绍两种判断ONOS与Mininet是否连通的方法 若拓扑中显示设备，说明ONOS和Mininet中的交换机成功连接 若ONOS与Mininet连通，运行ONOS的终端会显示下面的INFO信息 测试主机之间的连通性在运行Mininet的终端上，输入1pingall 参考https://wiki.onosproject.org/display/ONOS/Basic+ONOS+Tutorial#BasicONOSTutorial-Setupyourenvironment 0x06 在IntelliJ IDEA中运行ONOS下载IntelliJ IDEAhttps://www.jetbrains.com/idea/download/#section=linux 运行IntelliJ IDEA解压缩IDEA后，cd到IDEA的bin目录，运行IDEA1./idea.sh 安装Bazel插件然后搜索Bazel并安装 导入ONOS源码并编译生成最小的.bazelproject文件12cd onos/tools/dev/bin/./onos-gen-bazel-project &gt; /tmp/onos_bazelproject 等待IDEA完成ONOS源码的编译 运行ONOS 参考https://wiki.onosproject.org/pages/viewpage.action?pageId=28836246]]></content>
      <categories>
        <category>SDN</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
